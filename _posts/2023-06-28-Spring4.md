---
title: "싱글톤 컨테이너"
categories: 
    - Spring
tags:
    - Spring
---

![img1](/assets/images/4_1.png){: width="70%"", height="40%""} <br><br>

* 여러 클라이언트가 요청할 때마다 새로운 객체를 생성하는 것은 메모리 낭비가 심하다.
* 객체를 하나만 생성하고 이를 공유하도록 설계하면 된다. (싱글톤) <br><br>

**싱글톤 패턴**
* 클래스의 인스턴스를 딱 1개만 생성되도록 보장하는 디자인 패턴이다. <br><br>

~~~java

public class SingletonService {
//1. static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();
//2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
      public static SingletonService getInstance() {
          return instance;
      }
//3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다. private SingletonService() {
      private SingletonService() {
      }
      
      public void logic() { System.out.println("싱글톤 객체 로직 호출");
      } 
}
~~~

<br>
* 객체를 미리 생성해두고 생성자를 private으로 막아서 getInstance()를 통해서만 객체에 접근할 수 있게 한다.
* 유연성이 떨어지고 코드 길이도 길어지고 구체 클래스를 의존해야 되서 DIP, OCP를 위반할 가능성이 높다.
* 이러한 문제들은 Spring이 다 해결해준다. <br><br>

![img2](/assets/images/4_2.png){: width="70%"", height="40%""} <br><br>

* 스프링 컨테이너는 요청이 올 때마다 객체를 생성하는 것이 아니라 미리 만들어둔 instance를 공유하는 방식으로 돌아간다.
* 객체 하나를 공유하는 방식이기 때문에 빈을 구현할 때 반드시 stateless로 설계해야 한다. <br><br>

**Configuration과 바이트 조작** <br><br>

![img3](/assets/images/4_3.png){: width="70%"", height="40%""} <br><br>

* 스프링 설정 정보로 넘긴 AppConfig도 빈으로 등록되는데 바이트조작된 AppConfig를 상속하는 객체가 빈으로 등록된다. (CGLIB 기술) <- @Configuration이 붙으면 해줌.
* @Configuration을 안 넣으면 @Bean이 붙은 method가 빈으로 등록되긴 하지만 싱글톤으로 관리되지 않는다.
 




