---
title: "[Network] 보안"
toc: true
toc_sticky: true
categories: 
    - Network
tags:
    - Netowrk
---

<br>


# 안전한 통신

기밀성

- 송신자와 지정된 수신자만이 전송되는 메시지의 내용을 이해할 수 있어야 한다.
- 메시지를 어떠한 방식으로든 암호화해야 한다.

메시지 무결성

- 전송중에 메시지의 내용이 변하지 않아야 한다.

종단점 인증

- 송신자와 수신자는 상대방이 실제로 누구인지 신원을 확인할 수 있어야 한다.

운영 보안

- 대부분의 기관은 공용 네트워크에 연결되어있기 때문에 공격에 노출될 수 있다.
- 이를 막기 위해 기관 네트워크와 공공 네트워크 사이에 방화벽을 설치하고 드나드는 패킷을 제어할 수 있어야 한다.

---

# 암호학

### 암호화 구성요소

송신자가 보내려는 원래 형태의 메시지를 **평문**이라고 한다. 그리고 이를 암호화 알고리즘을 사용하여 만든 메시지를 **암호문**이라고 한다.

이 암호화 알고리즘은 누구에게나 다 알려져 있다. 때문에 전송한 데이터를 중간에서 가로채서 복원할 수 없도록 해주는 장치가 필요한데 이것이 `키` 이다.

**→ 평문을 암호문으로 바꿈으로서 `기밀성`을 실현한다.**

![img1](/assets/images/44_1.png){: width="70%"", height="40%""} <br><br>

1. Alice가 키(A)를 이용해서 평문을 암호화해서 밥에게 보낸다.
2. Bob은 키(B)를 사용해서 암호문을 복호화하여 평문으로 복원한다.

키는 Alice와 Bob만 가지고 있고 있기 때문에 Trudy가 중간에서 메시지를 가로채도 평문으로 복원할 방법이 없다.

### 대칭키 시스템

- 위 시나리오에서 Alice와 Bob이 동일한 키(A)를 가지고 암호화, 복호화를 한다면 이것은 `대칭키`를 이용하는 방식이다.
- 키(A)는 통신하고 있는 송수신자 이외에는 알 수 없다.

### 공개키 시스템

![img1](/assets/images/44_2.png){: width="70%"", height="40%""} <br><br>

- 모두에게 공개하는 키(공개키, K+)와 자기 자신만 가지는 키(개인키, K-)를 사용하는 방식이다.
- RSA알고리즘이 공개키 암호화와 거의 동의어처럼 사용된다.

- 송신자는 수신자의 공개키(K+)로 암호문을 생성해서 송신한다.
- 수신자는 자신의 개인키(K-)로 암호문을 복호화한다.

## RSA

- 모듈러 연산의 성질을 이용한 알고리즘인데 자세한 내용은 생략한다.
- RSA는 종종 대칭키 암호화와 같이 사용되는데 이때 사용되는 키가 `세션키`이다.
    - 여기서 세션키는 대칭키 암호화에 사용되는 키이다.

### 흐름

- 송신자가 세션키를 수신자의 공개키로 암호화한다.
- 수신자는 자신의 개인키로 복호화하여 세션키를 얻는다.

→ 이를 통해 안전하게 대칭키를 상대방에게 배포할 수 있다.

## 블록 암호화

- **블록 암호화**는 PGP(보안 전자 메일에 사용), TLS(안전한 TCP 연결에 사용), IPsec(네트워크 계층 전송에 사용) 에 자주 사용되는 방식으로서 메시지를 K비트의 블록 단위로 쪼개서 암호화한다.

### 문제점

- 이 방식은 2^k 만큼의 테이블을 유지해야 하기 때문에 K가 크다면 사용할 수 없다.
- 블록 암호화는 평문 블록이 동일하다면 동일한 암호문을 생성한다. 때문에 공격자가 이를 해독할 여지가 있다.

### CBC (Cipher Block Chaning)

- 블록 암호화의 문제를 해결하기 위한 방법 중 하나로 송신자가 처음에 초기화 백터라 불리는 임의의 비트열을 생성해서 수신자에게 보낸다.
- 수신자는 이를 이용해서 블록 C1~Cn까지 암호화를 수행한다.
    - 여기서 Cn을 암호화할 때, Cn-1의 값과 초기화 백터값이 사용된다.
- CBC를 사용하면 송신할때마다 초기화 백터가 다르기 때문에 같은 평문에 대해서 다른 암호문이 도출된다.

## 메시지 무결성

### 메시지 인증

- 메시지가 정말 해당 송신자로부터 온 것인가?
- 메시지가 나한테 전달되는 과정에서 변경되지 않았는가?

→ 이 두가지를 만족시켜야 한다.

### 해시 함수

- 해시 함수는 메시지 m을 입력값으로 받아서 고정된 크기의 문자열 H(m)을 도출한다.
- 메시지 m을 해시값으로 넣었을 때 생성되는 해시값 H(m)과 같은 해시값을 만들어내는 H(m`)을 찾는 것이 산술적으로 불가능(시간상)해야 한다.

### 메시지 인증 코드 (MAC)

![img1](/assets/images/44_3.png){: width="70%"", height="40%""} <br><br>

- 단순히 해시 함수를 통해서 (m, H(m))을 생성해서 보내는 것은 누구나 할 수 있다.
    - Alice도 보낼 수 있고, Trudy가 Alice인척 보낼 수도 있다.
- MAC 에서는 송수신자가 비밀키(s)를 공유하여 해시값을 계산할 때, 메시지에 s를 붙인다.
    - (m, H(m+s)) ← 송신할 때 이렇게 보낸다.
    - 비밀키 s는 송수신자만 공유하기 때문에 중간에 공격가 Trudy가 메시지(m)을 갈아껴서 (m`, H(m`))을 보내도 수신자는 H(m`) ≠ H(m`+s)이기 때문에 이상을 감지할 수 있다.

## 전자 서명

- 문서의 소유자 또는 작성자를 명시하거나 어떤 사람이 문서 내용에 동의했다는 것을 표시할 때 사용한다.
- **서명자를 입증**할 수 있어야 하고 **위조할 수 없어야 한다.**
- 공개키 암호화 방법이 사용된다.

### 흐름

- 자신의 개인키로 문서나 메시지 m을 암호화한다. → K-(m)
- 네트워크상에서 K-(m)을 받은 사람들은 공개키 K+를 사용해서 복호화한다.

### 특징

- 송신자의 개인키(K-)를 통해서만 서명할 수 있기 때문에 위조가 불가능하고 내가 나임을 증명할 수 있다.
- 공격자 Trudy가 메시지를 조작해서 m`을 만들어도 수신자는 바로 이상을 감지할 수 있다.
- 메시지 m은 길어질 수 있고 m에 바로 복호화, 암호화를 하게 되면 계산량이 늘어난다.
    - 해시 함수를 사용해서 m의 길이를 고정길이 해시값으로 변환해서 암호화한다.

![img1](/assets/images/44_4.png){: width="70%"", height="40%""} <br><br>

### 해시 함수 사용 흐름

- 메시지를 해시 함수에 넣어서 해시값 H(m)을 생성한다.
- H(m)을 개인키 K-로 암호화해서 보낸다. → (m, K-(H(m)))
    - 수신자에게는 (m, h)로 보인다.
- 수신자는 h값을 k+로 복호화하고 H(m)값과 비교한다.

## 공개키 인증

![img1](/assets/images/44_5.png){: width="70%"", height="40%""} <br><br>

위와 같이 Trudy가 자신의 개인키(K-)를 사용해서 Bob이 피자를 주문한다는 메시지를 암호화한 후 (m’, K-(H(m`)))을 Alice(피자집)에 보낸 경우를 생각해보자.

Alice는 Trudy의 공개키를 통해서 메시지를 복호화할 것이고 메시지의 내용이 위조가 없음을 판단할 것이다.

그리고 주문하지 않은 Bob에게 피자를 보낼 것이다. (억울…)

→ 이를 막기 위해서는 서명자의 공개키라고 생각되는 것이 정말 서명자의 것인지 알 수 있어야 하고 이를 `CA`가 해준다.

![img1](/assets/images/44_6.png){: width="70%"", height="40%""} <br><br>

- 공개키가 누구의 것인지 보증하는 일을 CA에서 담당한다.

### 흐름

- Bob이 자신의 공개키를 들고 CA에게 인증을 요구한다.
- CA가 적절하게 검증을 해준다.
    - 전적으로 CA의 검증을 신뢰해야 한다.
- CA는 공개키와 신분 확인서를 결합한 인증서를 Bob에게 준다.

→ 다음 통신부터는 인증서와 메시지를 같이 암호화하여 보냄으로서 신원을 보증할 수 있다.

## 종단점 인증

![img1](/assets/images/44_7.png){: width="70%"", height="40%""} <br><br>

- 대칭키와 `넌스`를 동시에 사용하면 종단점 인증을 할 수 있다.

### 흐름

- Alice는 메시지를 Bob에게 보낸다.
- Bob은 넌스 R을 생성하고 이것을 Alice에게 보낸다.
- Alice는 Bob과 공유하는 대칭키를 사용하여 넌스 R을 암호화하고 Bob에게 다시 보낸다.
- Bob은 이 값을 복호화하고 지금 통신하는 주체가 Alice임을 확인할 수 있다.

---

## Layer5 에서 제공하는 보안 서비스

### 전자메일

요구되는 사항들

- 기밀성
- 송신자 인증
- 메시지 무결성
- 수신자 인증

### 기밀성

![img1](/assets/images/44_8.png){: width="70%"", height="40%""} <br><br>

- Alice는 대칭 세션키(Ks)를 선택한다.
- Ks로 m을 암호화하고, Bob의 공개키 (K+B)로 Ks를 암호화한 쌍을 Bob에게 전송한다.
    - (K+B(Ks), Ks(m))
- Bob은 자신의 개인키로 세션키(Ks)를 얻고 Ks로 메시지를 복호화한다.

→ 이를 통해서 메시지의 `기밀성`을 충족시킬 수 있다. (Bob만이 메시지를 열람할 수 있음.)

### 송신자 인증 & 메시지 무결성

![img1](/assets/images/44_9.png){: width="70%"", height="40%""} <br><br>

- Alice는 m를 해시 함수에 넣어서 해시값 H(m)을 얻는다.
- H(m)을 자신의 개인키로 암호화한다. (전자서명)
- 이를 Bob에게 전송하고 Bob은 이를 수신하여 Alice의 공개키로 복호화한다.
- 복호화한 결과가 메시지m과 동일하면 메시지의 `무결성`이 확인된다.

→ 전자서명을 통해서 `송신자를 인증`할 수 있다.

위의 두 가지를 합치면 `기밀성`, `무결성`, `송신자 인증`을 만족시킬 수 있다.

![img1](/assets/images/44_10.png){: width="70%"", height="40%""} <br><br>

- Alice는 m과 m을 자신의 개인키로 암호화한 쌍을 하나의 값으로 묶는다.
- 이 값을 세션키(Ks)로 한번 더 암호화한다.
- 그리고 세션키(Ks)는 수신자의 공개키로 암호화한다.
- 이 두 쌍을 묶어서 전송한다.
    - (Ks(K-A(H(m), m), K+b(K(s))

→ 수신자는 Alice의 공개키를 알아야 하는데 이는 `CA`를 통해서 인증을 받는다.

## Layer4 에서 제공하는 보안 서비스

### TLS (Transport Layer Security)

- `기밀성`, `무결성`, `서버인증`, `클라이언트 인증`을 제공한다.

### 핸드셰이크

![img1](/assets/images/44_11.png){: width="70%"", height="40%""} <br><br>

- 위 흐름은 약식 TLS 핸드셰이크 과정이다.

### 흐름

- 클라이언트(Bob)은 넌스와 함께 자신이 지원하는 암호화 알고리즘을 서버(Alice)에 보낸다.
    - 넌스를 사용하는 이유는 메시지에 유일성이 생기기 때문에 동일한 메시지를 공격자가 서버에 보내도 구분할 수 있다.
- 서버(Alice)는 대칭키, 공개키, HMAC 알고리즘과 HMAC 키를 선택하고 이를 서버 넌스와 인증서와 함께 클라이언트(Bob)에게 보낸다.
- 클라이언트(Bob)은 서버의 공개키를 알아내고 PMS를 생성한다. 그리고 PMS를 서버(Alice)의 공개키로 암호화하고 서버(Alice)로 보낸다.
- 클라이언트, 서버는 동일한 키 유도 함수를 사용하여 PMS와 넌스로부터 MS를 계산한다.
- MS는 2개의 암호화 키와 2개의 HMAC 키를 생성하기 위해 분할된다.
- 이후부터 모든 메시지는 암호화되고 인증된다. (HMAC에 의해)
    - 클라이언트, 서버의 모든 핸드셰이크 메시지의 HMAC을 전송한다.

### 연결 종료

- 레코드의 타입 필드에 TLS 세션을 종료할 것인지 표시해야 한다.
    - 이렇게 하지 않으면 공격자로부터 `절단 공격`을 받을 수 있다.
    - 공격자가 중간에서 TCP FIN을 보내는 것을 **절단 공격**이라고 한다.

## Layer3 에서 제공하는 보안 서비스

- `기밀성`, `메시지 무결성`, `송신자 인증`을 제공한다.

### IPsec

![img1](/assets/images/44_12.png){: width="70%"", height="40%""} <br><br>

- 호스트간 안전하고 `기밀성`이 보장된 통신을 제공한다.
- 기존에는 사설 네트워크를 설치해서 이를 실현했는데 비용이 많이들기 때문에 요즘에는 공공 네트워크 상에 VPN을 설치한다.
- 공공 인터넷에 접근하기 직전에 IPsec으로 데이터그램을 바꾸고 진입한다.
    - IPsec도 IPv4의 헤더를 가지기 때문에 라우터는 이 둘을 구분하지 못한다.

### ESP 프로토콜

- 기밀성, 데이터 무결성을 제공한다.
- AH프로토콜도 있는데 기밀성을 제공하지 못하기 때문에 ESP가 주로 사용된다.

### SA

- 송신지와 수신지는 IPsec 데이터그램을 전송하기 전에 둘 사이에 논리적 연결을 설립한다.
    - 이를 `SA(security association)`라고 한다.
- SA는 단방향이라서 양방향으로 데이터를 전송하기 위해서는 2개의 SA를 설립해야 한다.

### IPsec 데이터그램

![img1](/assets/images/44_13.png){: width="70%"", height="40%""} <br><br>

---

## 방화벽

![img1](/assets/images/44_14.png){: width="70%"", height="40%""} <br><br>

- 전체 인터넷으로부터 기관의 내부 네트워크를 분리시킨 하드웨어와 소프트웨어의 조합으로, 어떤 패킷은 통과가 허용되나 어떤 패킷은 차단된다.
- 쉽게 말하면 공공 네트워크와 기관 내부 네트워크 사이에서 패킷을 필터링하는 역할을 수행한다.

### 역할

- 공공 네트워크와 기관 네트워크를 지나는 모든 트래픽은 방화벽을 거친다.
- 기관 네트워크의 정책에 허용된 트래픽만 방화벽을 통과할 수 있다.