---
title: "[디자인패턴] 퍼사드 패턴"
toc: true
toc_sticky: true
categories: 
    - 디자인패턴
tags:
    - 디자인패턴
typora-root-url: ../

---



# 퍼사드 패턴

## 정의

> Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.
>
> Wrap a complicated subsystem with a simpler interface.
>
> -GoF design pattern

퍼사드 패턴은 서브 시스템에 있는 여러 개의 인터페이스를 통합하여 하나의 인터페이스를 제공한다.

복잡한 서브 시스템을 사용하기 쉽게 고수준의 인터페이스를 정의하는 패턴이다.



## 구조

![img1](/assets/images/52_1.png){: width="90%"", height="40%""}

### Client

`클라이언트`는 `서브 시스템`에 바로 접근할 수도 있고 `Facade`를 통해서 `서브 시스템`의 기능을 사용할 수 있다.

### Facade

`서브 시스템` 기능을 묶은 고수준의 인터페이스이다. 이를 통해서 `클라이언트`와 `서브 시스템`간의 의존성을 낮출 수 있다.

### Additional Facade

`Facade`가 하나라는 규칙은 존재하지 않는다. 다양한 `서브 시스템`을 묶어서 새로운 `Facade`를 만들수도 있다.

이렇게 묶인 `Facade`는 다른 `Facade`에 포함될 수도 있고 `클라이언트`에서 바로 사용될 수도 있다.

### SubSystem

여러개의 `서브 클래스`를 나타낸다.



## 특징

### 장점

그렇다면 퍼사드 패턴은 언제 사용하면 좋을까?

#### 1. 시스템이 복잡할 때

시스템이 굉장히 복잡한 경우를 생각해보자. 이런 경우 서브 시스템의 인터페이스를 하나씩 사용하여 로직을 구성해야 하는데 굉장히 복잡할 수 있다.

이때 퍼사드 패턴을 사용하면 복잡한 서브 시스템 호출을 내부에 감추면서 `고수준의 인터페이스` 하나로 사용할 수 있게 된다.

#### 2. 의존성을 낮추고 싶을 때

시스템을 사용하는 클라이언트와 서브 시스템간의 의존성이 높을 때 퍼사드 패턴이 유용하다.

퍼사드 패턴을 통해 서브 시스템의 기능을 사용하게 되면 **클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.**



### 단점

그렇다면 퍼사드 패턴을 사용하는 것이 무조건 좋을까?

#### 1. 퍼사드 패턴과 서브 시스템 사이의 의존성

퍼사드 패턴을 사용하게 되더라도 퍼사드 객체와 서브 시스템 사이의 의존성은 피할 수 없다.

#### 2. 추가적인 코드

퍼사드 패턴을 사용하기 위해서는 퍼사드 객체를 만들어야 한다. 이는 코드의 증가를 유발하고 유지보수 관점에서 비용이 발생한다.

-> **퍼사드 패턴을 사용하면서 얻을 수 있는 이점과 추가적인 유지보수 비용을 잘 비교하여 사용 여부를 결정하는 것이 중요하다!**



## 예시

집에서 스크린을 통해서 영화를 보는 상황을 생각해보자.

방에서 스크린으로 영화를 보기 위해서는 스크린을 내리고 화면도 나오게 세팅해야 한다. 그리고 음향도 적절하게 조절하고 방의 불도 꺼야 한다.

리모컨 버튼 하나로 이 모든 것이 된다면 얼마나 좋을까??

이를 실현해주는 것이 `퍼사드 패턴`이다!

아래 코드를 보며 이해해보자.



### Screen, Speaker, Lighter, Projector (SubSystem)

![img2](/assets/images/52_2.png){: width="90%"", height="40%""}

`스크린`, `스피커`, `라이터`, `프로젝터`는 위에서 말한 `서브 시스템`이다. 퍼사드 패턴을 사용하지 않고 영화를 보는 환경을 세팅하기 위해서는 아래와 같이 클라이언트에서 서브 시스템 각각을 호출해야 한다.



### Main (Client)

![img3](/assets/images/52_3.png){: width="90%"", height="40%""}

클라이언트(`Main`)과 서브 시스템의 의존성이 강한 것을 확인할 수 있다. 그리고 각각의 서브 시스템을 클라이언트에서 호출해야 한다.

퍼사드 패턴을 사용하면 좀 더 간단한 인터페이스를 사용하여 서브 클래스의 동작을 제어할 수 있다.

아래 코드를 보자.



### MovieFacade (Facade)

![img4](/assets/images/52_4.png){: width="90%"", height="40%""}

여러 서브 시스템을 묶어서 하나의 인터페이스(`setMovieEnv()`)를 제공하는 것을 볼 수 있다.

이제 `MovieFacade`를 통해서 클라이언트에서 서브 시스템에 접근하는 코드를 보자.



### Main (Client)

![img5](/assets/images/52_5.png){: width="90%"", height="40%""}

클라이언트에서 `MovieFacade`의 `setMovieEnv()`를 통해서 서브 시스템에 접근하는 것을 볼 수 있다.

**물론 여전히 클라이언트는 각 서브 시스템에도 직접 접근할 수 있다.**



## 정리

지금까지 퍼사드 패턴에 대해서 알아봤다. 퍼사드 패턴은 복잡한 서브 시스템을 묶어서 클라이언트와 서브 시스템의 의존성을 낮추고 좀 더 간단한 인터페이스로 접근할 수 있게 도와준다.

이렇게 좋은 점도 있지만 추가적인 유지보수 비용도 있기 때문에 득실을 잘 따져서 적절하게 사용하는 것이 중요하다.



## 참고

* [인파님 블로그](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)

* 헤드 퍼스트 디자인 패턴













