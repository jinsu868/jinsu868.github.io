---
title: "[운영체제] 메모리 (진행중)"
toc: true
toc_sticky: true
categories: 
    - 운영체제
tags:
    - 운영체제
    - CS
typora-root-url: ../
---

## 메모리의 종류

CPU에 가까운 순서대로 레지스터, 캐시, 주기억장치, 보조기억장치가 있다.

![img1](/assets/images/61_4.png){: width="100%"", height="40%""}



## 캐시

캐시는 CPU와 메모리 사이의 속도 차이를 완화하기 위해서 사용한다. 

캐시는 메모리의 데이터를 미리 가져와 저장해두는 임시 저장소로, 크기는 메인 메모리보다 작기 때문에 앞으로 사용될 것으로 예상되는 데이터를 미리 저장하는 것이 키 포인트이다. 캐시에 있는 데이터를 가져와서 사용하는 것을 캐시 적중이라 하고 적중을 높이기 위해 **지역성의 원리**가 사용된다.

### 시간 지역성

최근 사용한 데이터에 다시 접근하려는 특성을 말한다.

반복문 for문의 인덱스 변수가 여기에 해당한다.

### 공간 지역성

최근 사용한 데이터의 인접한 주소의 내용을 다시 접근하는 것을 말한다.

배열의 연속된 원소들이 같이 조회되는 것을 생각하면 된다.

## 

## 메모리 할당

메모리에 프로그램을 할당할 때는 시작 메모리의 위치와 메모리 할당 크기를 기반으로 할당한다. 방법에는 연속 할당, 불연속 할당 방식이 있다.

### 연속 할당

연속 할당 방식은 프로세스 이미지가 분리되지 않고 온전한 프로세스를 메인 메모리에 적재하는 방식이다.

연속 할당 방식에는 고정 분할 방식, 가변 분할 방식이 있다.

#### 고정 분할 방식

메모리를 고정된 파트로 분리하고, 프로세스를 해당 파트에 삽입한다. 고정된 길이의 파트 내에 프로세스가 들어가기 때문에 여백이 생길 수 있는데 이것을 **내부 단편화**라고 한다.



#### 가변 분할 방식

메모리를 프로세스의 길이에 알맞게 파트를 분리하고, 해당 프로세스를 적재하는 방식이다. 내부 단편화는 발생하지 않지만 가변적인 길이 할당에 의해서 메모리의 일부분이 남기 때문에 **외부 단편화**가 발생한다.

최초 적합 : 메모리의 처음부터 검사하여 크기가 충분한 첫번째 공간에 할당한다.

최적 적합 : 프로세스의 크기 이상인 공간 중 가장 작은 공간에 할당한다.

최악 적합 : 프로세스의 크기와 가장 많이 차이가 나는 공간에 할당한다.



### 불연속 할당

프로세스를 연속된 이미지가 아닌 분리된 이미지로 구성하여 메인 메모리에 적재하는 방식을 말한다. 페이징, 세그멘테이션 방식이 있다.

### 페이징

![img1](/assets/images/62_1.png){: width="100%"", height="40%""}

프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리하여 메인 메모리에 불연속적으로 저장하는 방식이다. 

**내부 단편화**가 발생할 수 있다. (프로세스의 크기를 페이지의 크기로 나누고 남은 나머지의 크기만큼)



### 세그멘테이션

![img1](/assets/images/62_2.png){: width="100%"", height="40%""}

프로세스를 가변적인 크기의 세그먼트로 분리하여 메모리에 적재하는 방식이다. 주로 논리적인 블록 단위로 나누며 Code, Date, Heap, Stack 으로 분리할 수 있다. 세그멘테이션은 **외부 단편화**가 발생할 수 있다. 



## 내부, 외부 단편화

### 단편화

단편화란 프로세스들이 차지하는 메모리 사이에 사용하지 못할 만큼의 작은 공간을 의미한다.

### 내부 단편화

내부 단편화는 고정 분할 방식 / 페이지에서 나타나며, 물리 메모리를 고정적인 파트로 잘랐을 때, 해당 파트의 길이보다 더 작은 크기의 조각이 들어가게 되서 생기게 된다.

### 외부 단편화

메모리가 할당되고 해제되는 과정이 반복될 때, 작은 메모리가 사이사이에 생겨나는 것을 말한다. 이러한 메모리 공간이 많이자면 총 사용 가능한 메모리 공간은 충분하지만 메모리를 할당할 수 없는 상황이 생기는데 이를 외부 단편화라고 한다.



## 가상 메모리

가상 메모리는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.

가상 주소 -> MMU -> 실제 주소

TLB : CPU와 메모리 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하여 CPU가 페이지 테이블까지 가지 않도록 하여 속도를 향상시킨다.

### 장점

가상 메모리를 사용하면 동시에 많은 프로세스를 실행할 수 있고, 응답 시간을 유지하며 CPU 이용률과 처리률을 높일 수 있다.

### 단점

물리 메모리로 사용하는 것보다는 느리다.



## 요구 페이징

요구 페이징은 프로그램을 실행할 때, 프로그램 전체를 물리 메모리에 적재하는 대신 초기에 필요한 부분들만 적재하여 구동시키는 방식이다. 가상 메모리와 페이지 개념을 활용하여 관리된다.

### 페이지 교체

요구 페이징 방식을 사용하게 되면 초기에 필요한 페이지들만 메인 메모리에 올라가게 된다. 프로세스 동작 중에, 필요한 페이지가 물리 메모리에 없는 상황이 발생할 수 있는데 이를 **페이지 부재**라고 한다.

페이지 부재가 발생하면 원하는 페이지를 하드디스크에 스왑 공간으로부터 가져오게 된다. 하지만 물리 메모리가 모두 사용중이라서 원하는 페이지를 가져오지 못한다면 페이지 교체가 일어난다.

### 스와핑

메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 사용하는 것을 스와핑이라고 한다.



### 페이지 교체 알고리즘

**FIFO** : 가장 간단한 방식으로 메모리에 올리온 지 가장 오래된 페이지를 교체하는 알고리즘이다. 페이지가 올라온 순서를 큐에 저장하여 구현한다.

**최적 페이지 교체** **(OPT)**: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식이다. 프로세스가 앞으로 사용할 페이지를 미리 알아야 하는데 이는 불가능하기 때문에 구현이 불가능하다.

**LRU (Least Recently Used)** : 가장 오래 사용되지 않은 페이지를 교체하는 방식이다. OPT 알고리즘보다 페이지 교체 횟수가 높지만  FIFO 알고리즘보다는 효율적이다.

**LFU (Least Frequency Used)** : 참조 횟수가 가장 적은 페이지를 교체하는 방식이다. 만약 대상인 페이지가 여러개일 경우 LRU 알고리즘에 따라 가장 오래 사용되지 않은 페이지를 교체한다.

**MFU (Most Frequency Used)** : LFU 알고리즘의 반대로 참조 횟수가 가장 많은 페이지를 교체하는 방식이다.





## 스레싱

페이지 부재율이 높은 상태를 말한다. 페이지 부재가 발생하면 페이지 교체, 페이지 로드가 일어난다. 다양한 프로세스가 메모리에 올라오면서 메모리의 유효 공간은 줄어들고 CPU의 가동 시간은 올라가며 자원을 최대한 사용하게 된다.

하지만 메모리의 프로세스가 일정 수 이상 올라가면 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령어가 진행될 때마다 페이지 부재가 발생한다. 이 경우 역으로 CPU 사용률이 줄어들게 된다.

페이지를 교체하는 과정에서는 CPU가 사용되지 않기 때문에 페이지 교체만 계속해서 실행되면 운영체제는 CPU가 놀고 있다고 판단하고 더 많은 프로세스를 메모리에 적재한다. 이렇게 되면 더 많은 페이지 부재가 발생하는 악순환이 반복된다. 이를 **스레싱**이라고 한다.

### 해결

#### 작업 세트

프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 메모리에 로드하는 것을 말한다. 미리 메모리에 로드하면 탐색 비용도 줄일 수 있고 스와핑또한 줄일 수 있다.

### PFF

페이지 폴트 빈도를 조절하는 방식으로 상한선과 하한선을 만드는 방식이다. 만약 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다.

-> CPU 사용률과 메모리 적재량을 함께 체크해야 스레싱 유무를 확인할 수 있다.
