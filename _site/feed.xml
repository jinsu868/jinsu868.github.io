<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-09T16:02:26+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[운영체제] 프로세스 동기화 (진행중)</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59/" rel="alternate" type="text/html" title="[운영체제] 프로세스 동기화 (진행중)" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59/">&lt;p&gt;프로세스 동기화에 대해서 이해하기 위해서는 우선 임계 영역과 경쟁 상태에 대해서 이해해야 한다. 차례대로 살펴보며 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;임계-영역-critical-section&quot;&gt;임계 영역 (Critical Section)&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;임계 영역(Critical Section)이란 프로세스간에 공유자원을 접근함에 있어서 문제가 발생하지 않도록 한번에 하나의 프로세스만 공유자원에 접근하도록 보장해줘야 하는 영역을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;상호 배제 (Mutual Exclusion)&lt;/strong&gt; : 하나의 프로세스가 임계 영역에 들어가 있으면 다른 프로세스는 들어갈 수 없어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;진행 (Progress)&lt;/strong&gt; : 임계 영역에 들어간 프로세스가 없는 상태에서 임계 영역에 들어가려는 프로세스가 여러 개라면 어느 프로세스가 먼저 들어갈 지 결정할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;한정 대기 (Bounded Waiting)&lt;/strong&gt; : 다른 프로세스의 기아를 방지하기 위해, 한번 임계 영역에 들어간 프로세스는 다음 임계 영역에 들어갈 때 제한을 두어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태-race-condition&quot;&gt;경쟁 상태 (Race Condition)&lt;/h1&gt;

&lt;h2 id=&quot;정의-1&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;경쟁 상태 (Race Condition)이란 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값이 접근 순서나 접근 시점에 따라 달라질 수 있는 것을 말한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;발생할-수-있는-상황&quot;&gt;발생할 수 있는 상황&lt;/h2&gt;

&lt;h4 id=&quot;커널-작업-수행-중에-인터럽트가-발생하는-경우&quot;&gt;커널 작업 수행 중에 인터럽트가 발생하는 경우&lt;/h4&gt;

&lt;p&gt;해결 방법 : 커널 모드에서 작업을 수행하는 동안 인터럽트를 disable 시켜서 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스가-시스템콜을-호출하여-커널-모드로-진입하여-작업을-수행하는-도중에-문맥교환이-발생한-경우&quot;&gt;프로세스가 시스템콜을 호출하여 커널 모드로 진입하여 작업을 수행하는 도중에 문맥교환이 발생한 경우&lt;/h4&gt;

&lt;p&gt;프로세스가 커널 모드에서 작업하는 경우에는 CPU 허용 시간이 초과되더라도 CPU 제어권을 다른 프로세스로 넘기지 않게 함으로써 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;멀티-프로세스-환경에서-공유-메모리-내의-커널-데이터에-접근할-경우&quot;&gt;멀티 프로세스 환경에서 공유 메모리 내의 커널 데이터에 접근할 경우&lt;/h4&gt;

&lt;p&gt;커널 내부의 공유 메모리에 접근할 때마다 Lock/UnLock을 하여 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;간단한 예를 살펴보며 이해해 보자.&lt;/p&gt;

&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/58_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 코드에서 counter는 공급자와 소비자가 공유하는 부분이다. 만약 공급자에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;을 하는 시점에 소비자에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 동시에 실행하게 되면 어떻게 될까? (여기서의 counter 연산은 원자적이지 않다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;이라는 연산은 원자적인 연산처럼 보이지만 사실 어셈블러로 내려가면 그렇지 않다. 위의 코드를 보면 알 수 있듯이 3개의 연산으로 쪼개진다.  공급자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;을 호출한 시점에 소비자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 호출한 상황을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;register1에는 6이 저장되고 counter에 옮기는 작업을 하는 중간에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;가 끼어들어서 counter의 값이 6이 되자마자 register2(4)의 값으로 덮어써서 공급자 입장에서 counter값 6을 기대했지만 4가 나오는 결과가 도출된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이러한 문제들을 해결할 수 있을까? 이제부터 이에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스-mutex&quot;&gt;뮤텍스 (Mutex)&lt;/h2&gt;

&lt;h3 id=&quot;정의-2&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;뮤텍스란 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 매커니즘이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;연산&quot;&gt;연산&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Acquire&lt;/strong&gt; : 현재의 임계 구역에 들어갈 권한을 가져온다. 만약 다른 프로세스가 임계 구역에 있다면 나올때까지 대기한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Release&lt;/strong&gt; : 현재의 임계 구역을 모두 사용했음을 알린다. Release후에 다른 프로세스가 임계 구역에 접근할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;boolean 타입의 lock 변수를 통해 잠금 여부를 확인할 수 있고 한 개의 프로세스/스레드만 공유자원을 소유하고 해제할 수 있다. 그리고 대기중인 프로세스/스레드가 busy waiting 방식으로 대기하지 않고 대기 큐에 잠들어서 기다린다.(CPU 자원 소비 X)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;busy waiting&lt;/strong&gt; : CPU의 자원을 지속적으로 사용하며 특정 조건이 만족할 때까지 대기하는 방식 (while 문을 계속 돌고있다고 생각하면 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세마포어-semaphore&quot;&gt;세마포어 (Semaphore)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세마포어는 교착 상태에 대한 해법으로 두 개의 원자적 함수로 제어되는 정수 변수로 멀티프로그래밍 환경에서 공유자원에 대한 접근 제어를 하는 방법으로 사용되며, 1개의 공유되는 자원에 제한된 개수의 프로세스, 또는 스레드만 접근할 수 있도록 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;흐름&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허용되는 공유 자원에 접근할 수 있는 수로 세마포어 값을 초기화한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로세스/스레드가 공유 자원에 접근할 때마다 세마포어 변수의 값을 1감소 시킨다. (세마포어 변수가 0이 되면 꽉찬 것이다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세마포어 변수값이 0이하면 더 이상 접근할 수 없다는 의미이고 세마포어 변수에 절대값을 씌운 값이 현재 대기큐에서 잠들고 있는 프로세스/스레드의 수이다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;뮤텍스와 다르게 한 개 이상의 프로세스/스레드가 공유 자원에 접근할 수 있다. Wait(P) 연산을 통해 공유자원을 획득하고 Signal(V) 연산을 통해 해제한다. 세마포어도 뮤텍스와 마찬가지로 busy waiting 방식이 아닌 대기 큐에서 잠들다가 깨어나는 방식을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;이진 세마포어&lt;/strong&gt; : 세마포어 변수값이 0, 1만 될 수 있으며 최대 한개의 프로세스/스레드가 공유 자원에 접근 가능한 세마포어이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;카운팅 세마포어&lt;/strong&gt; : 최대 n개의 프로세스/스레드가 공유 자원에 접근 가능한 세마포어이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스와-세마포어의-차이점&quot;&gt;뮤텍스와 세마포어의 차이점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;뮤텍스는 소유한 프로세스/스레드만 뮤텍스 락을 변경할 수 있다. 반면 세마포어는 여러 프로세스/스레드가 세마포어 변수값을 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;뮤텍스는 세마포어로 사용될 수 없지만 세마포어는 뮤텍스로서 사용될 수 있다.&lt;/li&gt;
  &lt;li&gt;세마포어는 실행순서의 동기화를 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NL9JQh5bbZ8&quot;&gt;https://www.youtube.com/watch?v=NL9JQh5bbZ8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">프로세스 동기화에 대해서 이해하기 위해서는 우선 임계 영역과 경쟁 상태에 대해서 이해해야 한다. 차례대로 살펴보며 이해해보자.</summary></entry><entry><title type="html">[운영체제] 스레드</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58/" rel="alternate" type="text/html" title="[운영체제] 스레드" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58/">&lt;h1 id=&quot;스레드&quot;&gt;스레드&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드는 프로세스 내의 여러 실행 흐름의 단위이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;프로세스내의 스레드끼리는 Stack을 제외한 메모리 공간 (Code, Data, Heap)을 공유한다. 메모리 공간을 공유하기 때문에 하나의 스레드에서 오류가 발생한다면 다른 스레드에서 영향을 받을 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;독립적으로-할당되는-자원&quot;&gt;독립적으로 할당되는 자원&lt;/h3&gt;

&lt;p&gt;그렇다면 스레드마다 별도로 할당되는 자원에는 어떤게 있을까? &lt;strong&gt;Stack&lt;/strong&gt;과 &lt;strong&gt;Reigster&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;각 스레드가 독립적인 Stack을 가지는 이유는 함수의 실행과 연관된다. 독립적으로 Stack을 가진다는 말은 곧 독립적인 함수 호출이 가능하다는 뜻이다. 즉 프로세스 내에서 독립적인 실행 흐름을 만들 수 있다는 것이다. 때문에 Stack은 각 스레드마다 별도로 가지고 있어야 한다.&lt;/p&gt;

&lt;p&gt;그리고 스레드는 별도의 Register를 가지는데 여기서 의문이 있을 것이다. Register는 프로세서에 있는 친구아닌가?&lt;/p&gt;

&lt;p&gt;여기서 말하는 Register란 현재 스레드의 실행 정보가 저장된 상태값이다. 시분할 시스템에서는 문맥교환이 발생하게 되는데 문맥교환이 발생하면 스레드의 경우는 Code, Data, Heap은 공유하기 때문에 자신의 Stack 상태와 어디까지 실행했는지에 대한 정보(PC)만 저장하면 된다. 이 때, 현재 상태가 저장되기 때문에 Register 값이 저장되게 되는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 이유로 각 스레드는 Register를 별도로 가진다고 하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;문맥교환-context-switching&quot;&gt;문맥교환 (Context Switching)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;문맥교환이란 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말한다. 한 프로세스의 문맥은 그 프로세스의 PCB에 저장되어 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;발생-상황&quot;&gt;발생 상황&lt;/h4&gt;

&lt;p&gt;문맥교환은 인터럽트 발생, 실행중인 프로세스의 CPU 허용 시간 초과, 입출력 대기시에 발생하게 된다.&lt;/p&gt;

&lt;p&gt;문맥교환을 하는 동안에 CPU는 아무것도 하지 않게 된다. 그럼에도 불구하고 문맥교환을 하는 이유는 I/O와 같은 작업이 발생하여 CPU가 블록되는 시간이 문맥교환 시간보다 길기 때문에 문맥교환을 하여 다른 프로세스를 실행하는 것이 CPU 사용률을 높일 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레드&quot;&gt;멀티 스레드&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 스레드란 하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하며 작업을 수행하는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;멀티 스레드는 하나의 프로세스의 자원을 공유하기 때문에 멀티 프로세스보다 더 적은 메모리를 차지한다.그리고 메모리(Code, Data, Heap)를 공유하기 때문에 문맥교환 속도가 더 빠르다.&lt;/p&gt;

&lt;p&gt;하지만 오류로 인해서 하나의 스레드에 문제가 발생하게 된다면 전체 스레드에 영향을 줄 수도 있다. 그리고 메모리를 공유하기 때문에 동기화에 신경써서 프로그래밍해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레드-vs-멀티-프로세스&quot;&gt;멀티 스레드 vs 멀티 프로세스&lt;/h2&gt;

&lt;p&gt;일반적으로 멀티 스레드 방식을 더 많이 사용한다. 왜 그럴까?&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식의 경우 문맥 교환을 할 때, 스택 영역만 초기화하면 되기 때문에 속도가 빠르다. 그리고 프로세스의 경우 생성할 때 &lt;strong&gt;시스템콜&lt;/strong&gt;을 호출하게 되기 때문에 멀티 스레드 방식에 비해서 비효율적이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템콜 : 사용자나 응용프로그램이 커널에서 제공하는 기능을 사용하기 위한 인터페이스를 의미한다.
    &lt;ul&gt;
      &lt;li&gt;커널이 제공하는 서비스를 시스템콜을 통해서만 접근하게 제한함으로써 컴퓨터 자원을 보호하면서 사용자나 응용프로그램에게 서비스를 제공할 수 있게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;스레드는 프로세스 내의 여러 실행 흐름 단위로서 프로세스의 자원을 사용하게 된다.&lt;/p&gt;

&lt;p&gt;프로세스 내에 여러 스레드가 있을 때, 스레드끼리 메모리(Code, Date, Heap)을 공유하며 Stack, Register는 별도로 가진다.&lt;/p&gt;

&lt;p&gt;일반적으로 멀티 프로세스 방식보다는 멀티 스레드 방식을 많이 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">스레드</summary></entry><entry><title type="html">[운영체제] 좀비 프로세스 vs 고아 프로세스</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57/" rel="alternate" type="text/html" title="[운영체제] 좀비 프로세스 vs 고아 프로세스" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57/">&lt;p&gt;좀비 프로세스와 고아 프로세스를 이해하기 위해서 먼저 프로세스를 생성하는 과정을 좀 더 자세하게 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;프로세스-생성&quot;&gt;프로세스 생성&lt;/h1&gt;

&lt;p&gt;부모 프로세스는 시스템 콜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;를 통해서 자식 프로세스를 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;는 부모 프로세스의 주소 공간을 그대로 복사한다. 이 상태에서 시스템 콜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt;을 호출하게 되면 생성된 자식 프로세스의 메모리 공간을 새로운 프로그램으로 대체할 수 있다. 이러한 과정을 통해 부모와 다른 실행 흐름을 가진 자식 프로세스를 생성할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;자식-프로세스-트리&quot;&gt;자식 프로세스 트리&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/57_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리눅스에서는 커널이 자체적으로 생성한 init 프로세스가 있고 이후에 생성된 모든 프로세스는 init의 자손이 되며 트리구조를 이룬다.&lt;/p&gt;

&lt;p&gt;일단 모든 프로세스의 조상 프로세스는 커널이 생성한 init이라는 것만 기억하고 넘어가자. (아래에 설명하겠다.)&lt;/p&gt;

&lt;h2 id=&quot;실행-흐름&quot;&gt;실행 흐름&lt;/h2&gt;

&lt;p&gt;위에서 자식 프로세스를 생성하는 방법을 설명했다. 그렇다면 이렇게 생성된 자식 프로세스와 부모 프로세스는 어떤 방식으로 실행될 수 있을까?&lt;/p&gt;

&lt;p&gt;결론부터 말하자면 2가지 흐름이 있을 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 프로세스가 자식 프로세스의 종료까지 기다리고 이후에 실행한다.&lt;/li&gt;
  &lt;li&gt;부모 프로세스와 자식 프로세스를 동시에 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1번-케이스&quot;&gt;1번 케이스&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/57_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우는 부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하여 자식 프로세스의 종료를 기다린다. 그리고 자식 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;을 호출하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;의 파라미터로 자식 프로세스의 상태가 들어오게 되는데 이를 통해서 자식 프로세스가 사용하던 자원을 모두 반납한다.&lt;/p&gt;

&lt;p&gt;이 경우는 별다른 문제가 없는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2번-케이스&quot;&gt;2번 케이스&lt;/h3&gt;

&lt;p&gt;이 케이스는 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않는다. 부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않는다면 어떤 일이 생길까?&lt;/p&gt;

&lt;p&gt;이제 좀비 프로세스와 고아 프로세스가 등장한다.&lt;/p&gt;

&lt;h2 id=&quot;좀비-프로세스&quot;&gt;좀비 프로세스&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;좀비 프로세스는 자식 프로세스가 부모 프로세스보다 먼저 종료된 프로세스를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정의만 보면 무슨말인지 잘 이해가 안될 것이다. 자식 프로세스가 종료되면 종료된 것 아닌가?&lt;/p&gt;

&lt;p&gt;여기서 주목해야 하는 점은 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 을 호출하지 않았다는 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않았기 때문에 자식 프로세스가 종료되더라도 종료에 대한 정보가 부모 프로세스에 전달되지 못하고 사용하던 리소스를 반납할 방법이 없어진다.&lt;/p&gt;

&lt;p&gt;종료되도 리소스가 계속 남아있기 때문에 &lt;strong&gt;좀비 프로세스&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;커널은 이런 상황을 대비하여 프로세스에 대한 최소한의 정보를 저장하고 있다. 이후에 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하여 남아있는 리소스를 제거할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;고아-프로세스&quot;&gt;고아 프로세스&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;고아 프로세스는 부모 프로세스가 자식 프로세스보다 먼저 종료된 프로세스를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 경우도 좀비 프로세스 경우와 마찬가지로 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않은 경우에 발생한다.&lt;/p&gt;

&lt;p&gt;부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않고 자신의 로직을 수행하다 자식 프로세스보다 먼저 종료되면 자식 프로세스는 종료됐을 때 리소스를 반납해줄 주체가 없어진다. 이렇게 부모가 없이 남겨진 프로세스를 &lt;strong&gt;고아 프로세스&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;이렇게 부모가 사라진 경우 고아 프로세스는 위에서 설명한 init 프로세스의 자식 프로세스가 된다. init 프로세스는 이 프로세스가 종료되면 리소스를 회수하고 정상적으로 프로세스를 제거한다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;좀비 프로세스 : 부모가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않은 상태에서 자식 프로세스가 종료되어 리소스를 반납하지 못하는 프로세스&lt;/p&gt;

&lt;p&gt;고아 프로세스 : 부모가 먼저 종료되서 남겨진 프로세스&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://itstory1592.tistory.com/89&quot;&gt;https://itstory1592.tistory.com/89&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">좀비 프로세스와 고아 프로세스를 이해하기 위해서 먼저 프로세스를 생성하는 과정을 좀 더 자세하게 알아보자.</summary></entry><entry><title type="html">[운영체제] 프로세스</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56/" rel="alternate" type="text/html" title="[운영체제] 프로세스" /><published>2023-12-27T00:00:00+09:00</published><updated>2023-12-27T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56/">&lt;h1 id=&quot;프로세스&quot;&gt;프로세스&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스는 컴퓨터에서 실행 중인 프로그램을 말한다. 프로그램이 메모리에 올라가면 프로세스가 되고 CPU에 의해서 프로세스가 실행된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;각 프로세스는 서로 완전히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않는다. 때문에 한 프로세스에서 오류가 발생하더라도 다른 프로세스에 영향을 주지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;상태&quot;&gt;상태&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;new&quot;&gt;new&lt;/h3&gt;

&lt;p&gt;프로세스가 생성된 상태&lt;/p&gt;

&lt;h3 id=&quot;ready&quot;&gt;ready&lt;/h3&gt;

&lt;p&gt;프로세스가 CPU 할당을 기다리고 있는 상태&lt;/p&gt;

&lt;p&gt;CPU만 받으면 바로 실행할 수 있는 상태이다.&lt;/p&gt;

&lt;h3 id=&quot;running&quot;&gt;running&lt;/h3&gt;

&lt;p&gt;프로세스가 CPU를 할당 받아서 명령어를 실행하고 있는 상태이다.&lt;/p&gt;

&lt;h3 id=&quot;waiting&quot;&gt;waiting&lt;/h3&gt;

&lt;p&gt;프로세스가 이벤트가 발생할 때까지 대기하고 있는 상태&lt;/p&gt;

&lt;h3 id=&quot;terminated&quot;&gt;terminated&lt;/h3&gt;

&lt;p&gt;프로세스가 종료된 상태&lt;/p&gt;

&lt;p&gt;프로세스가 소유한 모든 자원을 반납하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-구조&quot;&gt;메모리 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드-영역-code&quot;&gt;코드 영역 (code)&lt;/h3&gt;

&lt;p&gt;실행할 프로그램의 코드가 저장되는 영역이다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서(fetch) 실행(execution)한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-영역-data&quot;&gt;데이터 영역 (data)&lt;/h3&gt;

&lt;p&gt;전역변수, 정적변수가 저장되는 영역으로 프로그램이 시작될 때 할당되며 프로그램이 종료할 때 소멸한다.&lt;/p&gt;

&lt;h3 id=&quot;힙-영역-heap&quot;&gt;힙 영역 (heap)&lt;/h3&gt;

&lt;p&gt;메모리 공간이 동적으로 할당되고 헤제되는 영역이다.&lt;/p&gt;

&lt;p&gt;낮은 주소에서 높은 주소로 채워진다.&lt;/p&gt;

&lt;h3 id=&quot;스택-영역-stack&quot;&gt;스택 영역 (stack)&lt;/h3&gt;

&lt;p&gt;함수 호출에 따른 지역변수와 매개변수가 저장되는 영역이다. 함수가 호출될 때마다 호출될 떄의 환경 등 특정 정보가 스택에 계속 저장된다.&lt;/p&gt;

&lt;p&gt;높은 주소에서 낮은 주소로 채워진다.&lt;/p&gt;

&lt;h4 id=&quot;힙과-스택의-차이&quot;&gt;힙과 스택의 차이&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pcb&quot;&gt;PCB&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;PCB는 프로세스 제어 블록으로 프로세스를 관리하기 위한 정보를 포함하는 운영체제 커널의 자료구조이다. 프로세스의 중요한 정보를 저장하고 있기 때문에 보호된 메모리에 저장된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;구조&quot;&gt;구조&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로세스 식별자&lt;/strong&gt; :  프로세스 식별변호&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스 상태&lt;/strong&gt; : new, ready, running, wating, terminated 등의 상태를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그램 카운터 (PC)&lt;/strong&gt; : 프로세스가 다음에 실행할 명령어의 주소를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 레지스터&lt;/strong&gt; : 프로세스를 실행하기 위해 저장해야 할 레지스터 정보&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 스케줄링 정보&lt;/strong&gt; : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;계정 정보&lt;/strong&gt; : 프로세스 실행에 사용된 CPU 사용량, 실행 유저 정보&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메모리 관리 정보&lt;/strong&gt; : 페이지, 세그먼트 테이블 등과 같은 정보를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O 상태 정보&lt;/strong&gt; : 프로세스에 할당된 I/O 디바이스 목록&lt;/p&gt;

&lt;h2 id=&quot;멀티-프로세싱&quot;&gt;멀티 프로세싱&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러 개의 프로세스를 통해서 병렬적으로 작업을 수행하는 것을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;프로세스끼리는 메모리를 공유하지 않기 때문에 하나의 프로세스에 문제가 발생하더라도 다른 프로세스에 영향을 끼치지 않는다.&lt;/p&gt;

&lt;p&gt;하지만 멀티 스레드 방식보다 많은 양의 메모리 공간과 CPU를 차지한다는 단점이 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Operating System Concepts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;면접을 위한 CS 전공지식 노트&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">프로세스</summary></entry><entry><title type="html">[Spring] Spring Security (진행중)</title><link href="http://localhost:4000/spring/55/" rel="alternate" type="text/html" title="[Spring] Spring Security (진행중)" /><published>2023-12-21T00:00:00+09:00</published><updated>2023-12-21T00:00:00+09:00</updated><id>http://localhost:4000/spring/55</id><content type="html" xml:base="http://localhost:4000/spring/55/">&lt;h1 id=&quot;스프링-시큐리티&quot;&gt;스프링 시큐리티&lt;/h1&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;애플리케이션을 개발함에 있어서 보안은 굉장히 중요한 이슈이다. 보안이 뚫리게 되면 단순히 데이터, 돈을 잃는 것을 넘어서 수년간 쌓아온 브랜드 평판과 유저로부터의 신뢰를 한번에 잃을 수 있다. 그렇다고 애플리케이션을 만들때마다 자체 보안 시스템을 만드는 것은 매우 비효율적이다. 기능적으로 문제가 발생할 위험도 있고 많은 시간과 돈이 들어간다. 스프링은 이런 문제를 해결해주기 위해 스프링 시큐리티라는 스프링 하부 프레임워크를 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;흐름&quot;&gt;흐름&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 가장 기본적인 Security의 흐름을 보여준다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;클라이언트로부터 HTTP 요청이 들어오면 Spring Security의 필터가 이를 가로챈다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;요청에 들어있는 유저의 아이디, 패스워드를 추출하여 Authentication을 구현한 UsernamePasswordAuthenticationToken을 생성하고 AuthenticationManager를 구현한 ProviderManager의 authenticate()메서드를 호출하며 이를 넘겨준다.&lt;/li&gt;
  &lt;li&gt;ProviderManager는 모든 AuthenticationProvider를 순차적으로 호출하여 인증을 수행한다.&lt;/li&gt;
  &lt;li&gt;AuthenticationProvider에서는 UserDetailService/UserDetailManager와 PasswordEncoder의 도움을 받아 인증을 수행하며 Authentication 객체를 반환한다.&lt;/li&gt;
  &lt;li&gt;인증에 성공하게 되면 AuthenticationManager는 Authentication 객체를 반환하고 필터에서 이를 받아 SecurityContextHolder 내부의 Context에 인증 객체를 저장하게 된다.&lt;/li&gt;
  &lt;li&gt;만약 실패하게 되면 AuthenticationManager는 또 다른 AuthenticationProvider를 호출하여 위 과정을 계속 반복하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 각각의 역할에 대해서 더 자세하게 알아보자&lt;/p&gt;

&lt;h2 id=&quot;spring-security-filter&quot;&gt;Spring Security Filter&lt;/h2&gt;

&lt;h3 id=&quot;defaultloginpagegeneratorfilter&quot;&gt;DefaultLoginPageGeneratorFilter&lt;/h3&gt;

&lt;p&gt;스프링 시큐리티 의존성을 추가하고 우리의 서비스에 접근하려고 하면 아래와 같은 로그인 페이지로 넘어가지는 경험을 해봤을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 로그인 기능을 구현한 필터가 바로 DefaultLoginPageGeneratorFilter이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요청으로부터 로그인 정보를 확인하여 로그인을 하지 않은 상태라면 위와 같은 로그인 페이지를 만든다. 실질적으로 로그인 페이지를 만드는 로직은 generateLoginPageHtml()메서드 안에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한땀한땀 html 코드가 작성되어 있는 것을 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;usernamepasswordauthenticationfilter&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 UsernamePasswordAuthenticationFilter이다. 코드를 보면 request로부터 유저의 아이디, 패스워드를 추출하고 Authentication을 구현한 UsernamePasswordAuthenticationToken을 생성하는 것을 볼 수 있다. 그리고 AuthenticationManager의 authenticate() 메서드를 호출하며 이를 넘기는 것을 볼 수 있다. 그렇다면 이 UsernamePasswordAuthenToken의 정체는 무엇일까?&lt;/p&gt;

&lt;p&gt;아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/55_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Authentication 객체는 현재 요청하고 있는 주체의 정보가 들어있다. 이 객체는 SecurityContextHolder 안의 ContextHolder에 실질적으로 저장되는 유저의 정보이기도 하다. 뜬금없이 Authentication에 대해서 설명한 이유는 UsernamePasswordAuthenticationToken이 authentication을 구현한 클래스이기 때문이다. (실제로는 AbstractAuthenticationToken을 상속받는데 이 추상 클래스가 Authentication을 구현하고 있다.)&lt;/p&gt;

&lt;h3 id=&quot;usernamepasswordauthenticationtoken&quot;&gt;UsernamePasswordAuthenticationToken&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UsernamePasswordAuthenticationToken을 보면 두 개의 생성자가 있는 것을 볼 수 있다. 위 생성자는 내부에서 setAuthenticated(false)로 인증 실패 상태를 넣는 것을 볼 수 있고 아래는 true를 넣어 성공 상태를 넣는다. 우리가 위에서 설명한 UsernamePasswordAuthenticationFilter 내부에서는 첫번째 생성자를 이용하여 객체를 생성한다.&lt;/p&gt;

&lt;p&gt;그렇다면 두번째 생성자는 언제 사용될까? AuthenticationProvider에서 실질적인 인증을 수행한 후 인증에 성공하면 Authentication 객체를 반환하는데 이 때 두번째 생성자를 사용하게 된다.&lt;/p&gt;

&lt;p&gt;다음으로 AuthenticationManager에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;authenticationmanager&quot;&gt;AuthenticationManager&lt;/h2&gt;

&lt;p&gt;AuthenticationManager는 인터페이스이고 단 하나의 메소드 authenticate()를 정의하고 있다. AuthenticationManager를 구현한 ProviderManager내부의 authenticate() 메서드 내부를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 반복문을 활용하여 가지고 있는 모든 Provider를 활용하여 인증을 시도한다. 모든 Provider에 대해서 인증이 실패하면 실패 Authentication 객체를 반환하고 성공하&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Spring" /><category term="Spring" /><category term="Security" /><summary type="html">스프링 시큐리티</summary></entry><entry><title type="html">[디자인패턴] 커맨드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/" rel="alternate" type="text/html" title="[디자인패턴] 커맨드 패턴" /><published>2023-12-10T00:00:00+09:00</published><updated>2023-12-10T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/">&lt;h1 id=&quot;커맨드-패턴&quot;&gt;커맨드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요구사항(요청, 명령)을 객체로 캡슐화하여 서로 다른 요구사항을 가진 클라이언트를 매개변수화시킬 수 있고 요구사항을 큐에 넣어 로그를 남기거나 작업을 취소할 수 있는 기능을 가능하게 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;invoker&quot;&gt;Invoker&lt;/h3&gt;

&lt;p&gt;요청을 받고 이를 실행시키는 역할을 수행한다. Command 인터페이스만 알고 있으며 실제로 Command가 어떻게 실행되는지는 알지 못한다.&lt;/p&gt;

&lt;h3 id=&quot;command&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt; 메소드를 선언한다.&lt;/p&gt;

&lt;h3 id=&quot;concretecommand&quot;&gt;ConcreteCommand&lt;/h3&gt;

&lt;p&gt;Command 인터페이스를 구현하며 맴버 변수로 Receiver를 가지고 있다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Receiver 메소드를 호출하여 로직이 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;receiver&quot;&gt;Receiver&lt;/h3&gt;

&lt;p&gt;실제 명령이 실행되는 부분이다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;h4 id=&quot;1-실제로-실행하는-객체receiver와-실행을-요청하는-객체invoker를-분리하여-결합도를-낮춘다&quot;&gt;1. 실제로 실행하는 객체(Receiver)와 실행을 요청하는 객체(Invoker)를 분리하여 결합도를 낮춘다.&lt;/h4&gt;

&lt;p&gt;Invoker는 Reciver를 알지 못한 채로 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드를 통해 실행을 하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-기존의-코드를-수정하지-않고도-새로운-명령을-추가할-수-있다-ocp-원칙&quot;&gt;2. 기존의 코드를 수정하지 않고도 새로운 명령을 추가할 수 있다. (OCP 원칙)&lt;/h4&gt;

&lt;p&gt;새로운 명령이 추가되도 Invoker를 수정하지 않고 Revicer와  Command만 구현하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;h4 id=&quot;1-새로운-명령이-생길때마다-클래스가-추가되기-때문에-코드-복잡성이-증가할-수-있다&quot;&gt;1. 새로운 명령이 생길때마다 클래스가 추가되기 때문에 코드 복잡성이 증가할 수 있다.&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 이제 예제를 보면서 이해해보자!&lt;/p&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;다음과 같은 기능을 가진 리모컨을 생각해보자.&lt;/p&gt;

&lt;h3 id=&quot;리모컨-기능&quot;&gt;리모컨 기능&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;전등  ON/OFF&lt;/li&gt;
  &lt;li&gt;TV ON/OFF&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 표현하기 위해서는 리모컨, 전등, TV 클래스가 필요할 것이다. 아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;remote-class&quot;&gt;Remote Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리모컨 클래스이다. 불끄기, 불켜기, Tv켜기, Tv끄기 메소드를 가진다.&lt;/p&gt;

&lt;h3 id=&quot;light--tv-class&quot;&gt;Light &amp;amp; Tv Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 이 상황에서 새로운 요구사항이 생겼다고 가정해보자.&lt;/p&gt;

&lt;h4 id=&quot;추가된-요구사항&quot;&gt;추가된 요구사항&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;리모컨을 통해 프로젝트를 켜고 끄는 기능을 추가해주세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 만족시키기 위해서는 Remote 클래스에 맴버 변수로 Project를 추가하고 Project를 켜고 끄는 메소드를 추가해야 한다. 이는 기존 코드인 Remote를 수정하는 것이기 때문에 OCP를 위반하게 된다. 커맨드 패턴을 적용하면 요청을 호출하는 Remote 클래스와 실제 실행이 되는 Tv, Light 클래스 사이의 결합도를 낮추고 새로운 요구사항(프로젝트 Up/Down)이 생겼을 때 기존 코드(Remote 클래스)를 손보지 않고 기능을 추가할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;코드를 통해서 확인해보자!&lt;/p&gt;

&lt;h3 id=&quot;커맨드-패턴을-적용한-코드&quot;&gt;커맨드 패턴을 적용한 코드&lt;/h3&gt;

&lt;h3 id=&quot;command-1&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령을 추상화한 Command 인터페이스이다.&lt;/p&gt;

&lt;h3 id=&quot;project-receiver&quot;&gt;Project (Receiver)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 추가된 명령을 수행하는 Project 클래스이다. 위의 클래스 다이어그램에서 설명했던 Receiver 역할을 수행하는 클래스이다.&lt;/p&gt;

&lt;p&gt;앞서 봤던 Light, Tv도 모두 Receiver이다. (Light, Tv는 코드가 동일하니 위의 코드를 참고하자.)&lt;/p&gt;

&lt;h3 id=&quot;lightoncommandlightoffcommand-concrete-command&quot;&gt;LightOnCommand/LightOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Command 인터페이스를 구현하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Light(Receiver)의 메소드를 호출한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Remote 클래스(Invoker)와 Light 클래스(Receiver) 사이의 결합도를 낮추게 된다.&lt;/p&gt;

&lt;h3 id=&quot;tvoncommandtvoffcommand-concrete-command&quot;&gt;TvOnCommand/TvOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 설명한 Light의 경우와 완전히 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;projectoncommandprojectoffcommand-concrete-command&quot;&gt;ProjectOnCommand/ProjectOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 Light, Tv와 완전히 동일하니 설명은 생략한다.&lt;/p&gt;

&lt;h3 id=&quot;remote-invoker&quot;&gt;Remote (Invoker)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remote 클래스는 Command 인터페이스에만 의존한다. 때문에 실제로 각 ConcreteCommand가 어떤 Recevier를 호출하는지 알지 못한다.&lt;/p&gt;

&lt;p&gt;커맨드를 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setCommand()&lt;/code&gt;, On/Off 버튼을 누르는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onButtonPush()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offButtonPush()&lt;/code&gt;메소드를 가지고 있다.&lt;/p&gt;

&lt;p&gt;이 함수 내부에서는 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 새로운 기능을 추가함에 있어서 기존 코드를 수정할 필요가 없다 (OCP원칙). 그저 새로운 Receiver (여기서는 Project)와 ConcreteCommand(ProjectOnCommand, ProjectOffComand)만 새로 만들면 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;커맨드 패턴을 사용하면 실행을 요청하는 객체와 실제 실행하는 객체 사이의 결합도를 낮출 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 새로운 요구사항이 발생해도 유연하게 대처할 수 있다. 하지만 관리해야 하는 객체의 수가 늘어나기 때문에 무분별한 사용은 코드의 복잡도를 증가시킬 수 있다.&lt;/p&gt;

&lt;p&gt;무작정 적용하기보다는 꼭 필요한 곳에만 사용하도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">커맨드 패턴</summary></entry><entry><title type="html">[디자인패턴] 어댑터 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51/" rel="alternate" type="text/html" title="[디자인패턴] 어댑터 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51/">&lt;h1 id=&quot;어댑터-패턴&quot;&gt;어댑터 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Convert the interface of a class into another interface clients expect. 
Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어댑터 패턴(Adapter Pattern)은 클래스의 인터페이스를 클라이언트가 원하는 형태의 또 다른 인터페이스로 변환해준다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;클라이언트 입장에서는 새로운 기능을 사용하기 위해 Adaptee의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specificRequest()&lt;/code&gt; 써야 되는데 기존에 사용하던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request()&lt;/code&gt;로 접근하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;target&quot;&gt;Target&lt;/h3&gt;

&lt;p&gt;기존에 사용하던 인터페이스라고 생각하면 된다. 새로운 인터페이스(Adaptee)를 어댑터를 사용해서 Target인터페이스를 사용하듯이 하는 것이 목표이다.&lt;/p&gt;

&lt;h3 id=&quot;adapter&quot;&gt;Adapter&lt;/h3&gt;

&lt;p&gt;새로운 인터페이스인 Adaptee를 기존에 사용하던 Target인터페이스처럼 사용할 수 있도록 변환해주는 역할을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;adaptee&quot;&gt;Adaptee&lt;/h3&gt;

&lt;p&gt;새로운 인터페이스로 기존에 사용하던 Target인터페이스와 다르다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;어댑터 패턴을 사용함으로써 기존 클래스를 수정하지 않고도 클라이언트에서 새로운 인터페이스를 사용할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;어댑터 클래스를 새로 작성해야 하기 때문에 소스 코드가 늘어나고 코드의 복잡도가 늘어난다.&lt;/p&gt;

&lt;p&gt;어댑터가 중간에 데이터를 변환하는 과정에서 추가적인 처리 시간과 오버헤드가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 회사의 시스템이 있다고 해보자. 그런데 새로운 기능을 구현하기 위해 다른 업체에서 제공하는 클래스 라이브러리를 사용해야 하는 상황이 생겼다.&lt;/p&gt;

&lt;p&gt;이 상황에서 만약 기존 시스템의 인터페이스와 새로운 업체에서 사용하는 인터페이스가 다르면 호환성 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;이때 어댑터 패턴을 사용하면 이를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;우리는 핸드폰을 사용하고 있다. 이 핸드폰은 두 가지 기능이 있는데 화면을 보여주는 기능과 전원을 종료하는 기능이다.&lt;/p&gt;

&lt;p&gt;이를 코드로 나타내보면 아래와 같다.&lt;/p&gt;

&lt;h4 id=&quot;phone-class-target&quot;&gt;Phone Class (Target)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_3.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;galaxy-phone의-구현-객체&quot;&gt;Galaxy (Phone의 구현 객체)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_4.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;화면 보여주는 기능 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;전원을 종료하는 기능 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutDown()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 상황에서 태블릿 기기를 선물 받았다고 해보자.&lt;/p&gt;

&lt;p&gt;태블릿 클래스 코드는 아래와 같다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tablet-adaptee&quot;&gt;Tablet (Adaptee)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_5.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 우리는 태블릿 기기를 사용하려면 여러가지 기능을 새로 배워야 한다.&lt;/p&gt;

&lt;p&gt;그래서 우리는 태블릿을 기존에 사용하던 핸드폰과 동일한 인터페이스로 사용할 수 있도록 어댑터를 장착하기로 결정했다!&lt;/p&gt;

&lt;h3 id=&quot;phoneadapter-adapter&quot;&gt;PhoneAdapter (Adapter)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_6.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PhoneAdapter클래스는 Phone을 구현하고 내부적으로 Tablet을 맴버 변수로 가지고 있다.&lt;/p&gt;

&lt;p&gt;기존에 사용하던 Phone인터페이스를 구현하는 것은 같은데 내부적으로는 Tablet의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;메소드를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 우리(Client)는 Tablet클래스를 사용할 때 기존에 사용하던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutDown()&lt;/code&gt;을 통하여 접근할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;어댑터 패턴은 인터페이스 사이에 유연성이 필요한 상황에 효율적으로 사용될 수 있는 디자인 패턴이다.&lt;/p&gt;

&lt;p&gt;하지만 코드의 복잡도가 발생할 수 있고 추가적인 오버헤드가 생길 수 있기 때문에 적절한 상황에만 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://yozm.wishket.com/magazine/detail/2077/&quot;&gt;요즘IT&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">어댑터 패턴</summary></entry><entry><title type="html">[디자인패턴] 상태 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53/" rel="alternate" type="text/html" title="[디자인패턴] 상태 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53/">&lt;h1 id=&quot;상태-패턴&quot;&gt;상태 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;객체 내부의 상태가 바뀔 때, 객체의 동작을 변경할 수 있도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;context&quot;&gt;Context&lt;/h3&gt;

&lt;p&gt;여러 상태가 존재하는 시스템을 말한다. 시스템은 상태를 나타내는 State를 가지고 있으며 클라이언`로부터 요청을 받으면  State에 실행을 위임한다.&lt;/p&gt;

&lt;h3 id=&quot;state&quot;&gt;State&lt;/h3&gt;

&lt;p&gt;상태를 추상화한 인터페이스이다.&lt;/p&gt;

&lt;p&gt;ConcreteStatus는 이를 구현하여 구체적인 상태를 나타내게 된다.&lt;/p&gt;

&lt;h3 id=&quot;concretestatus&quot;&gt;ConcreteStatus&lt;/h3&gt;

&lt;p&gt;구체적인 상태를 나타내는 클래스이다.&lt;/p&gt;

&lt;p&gt;맴버 변수로 Context를 가지고 있으며 연산에 따라 Context의 상태를 변경한다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;아래와 같은 상태가 존재하는 &lt;strong&gt;뽑기 기계&lt;/strong&gt;를 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뽑기 기계는 상태( 동전 투입 여부, 알맹이 개수)에 따라 동작 방식이 달라진다.&lt;/p&gt;

&lt;p&gt;이를 구현하기 위해서는 &lt;strong&gt;분기 처리&lt;/strong&gt;를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;만약 여기서 새로운 요구사항이 생기면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;예를 들어서 5번에 한 번마다 알맹이가 2개가 나오게 변경한다고 생각해보자.&lt;/p&gt;

&lt;p&gt;그러면 우리는 5번째인지 확인하기 위해 조건문을 모든 메소드에 추가해야 한다.&lt;/p&gt;

&lt;p&gt;매번 요구사항이 추가될 때마다 기존 코드를 변경해야 하는 것은 유지보수 측면에서 좋지 않다. 이를 해결하는 방법 중 하나가 &lt;strong&gt;상태 패턴&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;상태 패턴을 사용하게 되면 상태에 따른 동작을 클래스로 관리할 수 있게 되고 코드의 복잡도도 줄일 수 있게 된다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 상태 패턴의 필요성에 대해서 봤으니 이제 상태 패턴의 장단점에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;상태에 따른 객체의 동작을 클래스로 관리할 수 있게 된다.&lt;/li&gt;
  &lt;li&gt;상태에 관련된 동작을 각 클래스로 분산시켜 코드의 복잡도를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;새로운 요구사항이 생겨서 변경이 발생하더라도 기존의 코드를 그대로 유지할 수 있다. (OCP원칙)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;상태별로 클래스로 관리해야 하기 때문에 클래스의 수가 증가한다.&lt;/li&gt;
  &lt;li&gt;객체의 상태가 몇 개 없거나 상태가 거의 변경되지 않는 경우에 상태 패턴을 적용하는 것은 &lt;strong&gt;오버엔지니어링&lt;/strong&gt;일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;위에 필요성에서 설명했던 예제인 &lt;strong&gt;뽑기 기계&lt;/strong&gt;를 가지고 상태 패턴을 이해해보자.&lt;/p&gt;

&lt;p&gt;먼저 뽑기 기계의 상태에 대해서 생각해보자. 아래와 같이 4가지 상태가 존재할 것이다.&lt;/p&gt;

&lt;h4 id=&quot;sold_out&quot;&gt;SOLD_OUT&lt;/h4&gt;

&lt;p&gt;머신의 알맹이가 다 떨어진 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;no_coin&quot;&gt;NO_COIN&lt;/h4&gt;

&lt;p&gt;동전이 투입되지 않은 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;has_coin&quot;&gt;HAS_COIN&lt;/h4&gt;

&lt;p&gt;동전이 투입된 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;sold&quot;&gt;SOLD&lt;/h4&gt;

&lt;p&gt;손잡이를 돌려서 알맹이가 나오고 있는 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;그리고 이런 상태에 4가지 행위가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;뽑기 기계에 코인을 넣는 행위&lt;/li&gt;
  &lt;li&gt;뽑기 기계에서 알맹이를 뽑는 행위&lt;/li&gt;
  &lt;li&gt;뽑기 기계에서 동전을 반환하는 행위&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;-&amp;gt; 이제 이를 상태 패턴 없이 코드로 작성해보겠다.&lt;/p&gt;

&lt;h3 id=&quot;machine-class&quot;&gt;Machine Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상태에 따른 동작을 &lt;strong&gt;분기 처리&lt;/strong&gt;를 통해서 구현했다.&lt;/p&gt;

&lt;p&gt;그리고 각 상태(SOLD_OUT, SOLD, HAS_COIN, NO_COIN)를 상태 변수로 처리했다.&lt;/p&gt;

&lt;p&gt;하지만 이 코드에는 여러 단점이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상태 전환을 하기 위해 조건 분기를 해야 한다. 이는 가독성에 좋지 않다.&lt;/li&gt;
  &lt;li&gt;상태에 따른 추가 요구사항이 생기면 메소드를 다 수정해야 한다. &lt;strong&gt;OCP&lt;/strong&gt;를 위반하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그렇다면 이제 상태 패턴을 적용하여 이러한 단점을 보안해보자.&lt;/p&gt;

&lt;p&gt;여기서는 상태 패턴 + 싱글톤 패턴을 같이 적용한 코드를 볼 것이다.&lt;/p&gt;

&lt;p&gt;싱글톤 패턴을 적용한 이유는 상태를 변경할 때마다 새로운 객체를 생성하게 되면 &lt;strong&gt;메모리 낭비&lt;/strong&gt;가 발생하기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;상태-패턴--싱글톤-패턴-적용&quot;&gt;상태 패턴 + 싱글톤 패턴 적용&lt;/h3&gt;

&lt;h4 id=&quot;machine-context&quot;&gt;Machine (Context)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Machine 클래스는 맴버 변수로 상태를 가지고 있다. 그리고 동전 넣기, 동전 반환, 손잡이 돌리기, 뽑기라는 4가지 행위를 가진다.&lt;/p&gt;

&lt;p&gt;각각의 행위는 State에 위임되며 현재 Machine의 상태에 따라 다르게 동작하게 된다.&lt;/p&gt;

&lt;p&gt;그리고 동작이 일어나고 상황에 맞게 State가 변경될 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;state-state&quot;&gt;State (State)&lt;/h4&gt;

&lt;h4&gt;&lt;img src=&quot;/assets/images/53_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/h4&gt;

&lt;p&gt;상태를 추상화한 인터페이스이다.&lt;/p&gt;

&lt;h4 id=&quot;nocoinstate-concretestate&quot;&gt;NoCoinState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동전이 없는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;p&gt;싱글톤 패턴을 적용하였는데 만약 싱글톤 패턴을 적용하지 않았다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertCoin(Machine machine)&lt;/code&gt; 에서 머신의 상태를 변경할 때, 새로운 객체를 생성해서 넘겼어야 했을 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 상태가 변할때마다 객체가 생성되기 때문에 효율적이지 않다.&lt;/p&gt;

&lt;p&gt;물론  &lt;strong&gt;GC&lt;/strong&gt;가 주기적으로 정리해주긴 하지만 이러한 쓰레기가 늘어나게 되면 제거 과정에서 &lt;strong&gt;Stop-the-world&lt;/strong&gt;가 발생하여 프로그램이 느려질 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;hascoinstate-concretestate&quot;&gt;HasCoinState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_11.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_12.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동전이 들어있는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;p&gt;동전이 들어있을 때는 동전 반환, 손잡이 돌리기를 수행하면 상태가 변하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;soldoutstate-concretestate&quot;&gt;SoldOutState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_13.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_14.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;알맹이가 떨어진 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;h4 id=&quot;soldstate-concretestate&quot;&gt;SoldState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_15.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_16.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;알맹이가 나가고 있는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;상태 패턴은 상태를 객체화하여 객체의 행동을 상태에 특화된 행위들로 분리할 수 있다.&lt;/p&gt;

&lt;p&gt;상태에 따라 행위가 달라진다면 상태 패턴을 고려해보면 좋을 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%83%81%ED%83%9CState-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">상태 패턴</summary></entry><entry><title type="html">[디자인패턴] 퍼사드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52/" rel="alternate" type="text/html" title="[디자인패턴] 퍼사드 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52/">&lt;h1 id=&quot;퍼사드-패턴&quot;&gt;퍼사드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.&lt;/p&gt;

  &lt;p&gt;Wrap a complicated subsystem with a simpler interface.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;퍼사드 패턴은 서브 시스템에 있는 여러 개의 인터페이스를 통합하여 하나의 인터페이스를 제공한다.&lt;/p&gt;

&lt;p&gt;복잡한 서브 시스템을 사용하기 쉽게 고수준의 인터페이스를 정의하는 패턴이다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;클라이언트는 서브 시스템에 바로 접근할 수도 있고 Facade를 통해서 서브 시스템의 기능을 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;facade&quot;&gt;Facade&lt;/h3&gt;

&lt;p&gt;서브 시스템 기능을 묶은 고수준의 인터페이스이다. 이를 통해서 클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;additional-facade&quot;&gt;Additional Facade&lt;/h3&gt;

&lt;p&gt;Facade가 하나라는 규칙은 존재하지 않는다. 다양한 서브 시스템을 묶어서 새로운 Facade를 만들수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 묶인 Facade는 다른 Facade에 포함될 수도 있고 클라이언트에서 바로 사용될 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;subsystem&quot;&gt;SubSystem&lt;/h3&gt;

&lt;p&gt;여러개의 서브 클래스를 나타낸다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;그렇다면 퍼사드 패턴은 언제 사용하면 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;1-시스템이-복잡할-때&quot;&gt;1. 시스템이 복잡할 때&lt;/h4&gt;

&lt;p&gt;시스템이 굉장히 복잡한 경우를 생각해보자. 이런 경우 서브 시스템의 인터페이스를 하나씩 사용하여 로직을 구성해야 하는데 굉장히 복잡할 수 있다.&lt;/p&gt;

&lt;p&gt;이때 퍼사드 패턴을 사용하면 복잡한 서브 시스템 호출을 내부에 감추면서 고수준의 인터페이스 하나로 사용할 수 있게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-의존성을-낮추고-싶을-때&quot;&gt;2. 의존성을 낮추고 싶을 때&lt;/h4&gt;

&lt;p&gt;시스템을 사용하는 클라이언트와 서브 시스템간의 의존성이 높을 때 퍼사드 패턴이 유용하다.&lt;/p&gt;

&lt;p&gt;퍼사드 패턴을 통해 서브 시스템의 기능을 사용하게 되면 &lt;strong&gt;클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;그렇다면 퍼사드 패턴을 사용하는 것이 무조건 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;1-퍼사드-패턴과-서브-시스템-사이의-의존성&quot;&gt;1. 퍼사드 패턴과 서브 시스템 사이의 의존성&lt;/h4&gt;

&lt;p&gt;퍼사드 패턴을 사용하게 되더라도 퍼사드 객체와 서브 시스템 사이의 의존성은 피할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;2-추가적인-코드&quot;&gt;2. 추가적인 코드&lt;/h4&gt;

&lt;p&gt;퍼사드 패턴을 사용하기 위해서는 퍼사드 객체를 만들어야 한다. 이는 코드의 증가를 유발하고 유지보수 관점에서 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;퍼사드 패턴을 사용하면서 얻을 수 있는 이점과 추가적인 유지보수 비용을 잘 비교하여 사용 여부를 결정하는 것이 중요하다!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;집에서 스크린을 통해서 영화를 보는 상황을 생각해보자.&lt;/p&gt;

&lt;p&gt;방에서 스크린으로 영화를 보기 위해서는 스크린을 내리고 화면도 나오게 세팅해야 한다. 그리고 음향도 적절하게 조절하고 방의 불도 꺼야 한다.&lt;/p&gt;

&lt;p&gt;리모컨 버튼 하나로 이 모든 것이 된다면 얼마나 좋을까??&lt;/p&gt;

&lt;p&gt;이를 실현해주는 것이 퍼사드 패턴이다!&lt;/p&gt;

&lt;p&gt;아래 코드를 보며 이해해보자.&lt;/p&gt;

&lt;h3 id=&quot;screen-speaker-lighter-projector-subsystem&quot;&gt;Screen, Speaker, Lighter, Projector (SubSystem)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크린, 스피커, 라이터, 프로젝터는 위에서 말한 서브 시스템이다. 퍼사드 패턴을 사용하지 않고 영화를 보는 환경을 세팅하기 위해서는 아래와 같이 클라이언트에서 서브 시스템 각각을 호출해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;main-client&quot;&gt;Main (Client)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_3.png&quot; alt=&quot;img3&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트(Main)과 서브 시스템의 의존성이 강한 것을 확인할 수 있다. 그리고 각각의 서브 시스템을 클라이언트에서 호출해야 한다.&lt;/p&gt;

&lt;p&gt;퍼사드 패턴을 사용하면 좀 더 간단한 인터페이스를 사용하여 서브 클래스의 동작을 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;moviefacade-facade&quot;&gt;MovieFacade (Facade)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러 서브 시스템을 묶어서 하나의 인터페이스(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMovieEnv()&lt;/code&gt;)를 제공하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이제 MovieFacade를 통해서 클라이언트에서 서브 시스템에 접근하는 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;main-client-1&quot;&gt;Main (Client)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_5.png&quot; alt=&quot;img5&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트에서 MovieFacade의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMovieEnv()&lt;/code&gt;를 통해서 서브 시스템에 접근하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;물론 여전히 클라이언트는 각 서브 시스템에도 직접 접근할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;지금까지 퍼사드 패턴에 대해서 알아봤다. 퍼사드 패턴은 복잡한 서브 시스템을 묶어서 클라이언트와 서브 시스템의 의존성을 낮추고 좀 더 간단한 인터페이스로 접근할 수 있게 도와준다.&lt;/p&gt;

&lt;p&gt;이렇게 좋은 점도 있지만 추가적인 유지보수 비용도 있기 때문에 득실을 잘 따져서 적절하게 사용하는 것이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">퍼사드 패턴</summary></entry><entry><title type="html">[디자인패턴] 템플릿 메소드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49/" rel="alternate" type="text/html" title="[디자인패턴] 템플릿 메소드 패턴" /><published>2023-12-04T00:00:00+09:00</published><updated>2023-12-04T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;템플릿-메소드-패턴&quot;&gt;템플릿 메소드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;템플릿 메소드 패턴은 알고리즘의 뼈대를 정의하고 서브 클래스마다 세부 동작 사항을 다르게 구현하는 패턴을 말한다.
변하지 않는 템플릿은 상위 클래스에 만들어두고 자주 변경되거나 확장되는 기능은 하위 클래스에서 만들도록 하여, 템플릿 메소드의 동작 순서는 고정하고 세부 실행 내용을 다양화할 때 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;abstract-class&quot;&gt;Abstract Class&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;템플릿 메소드&lt;/code&gt;를 구현하고, 템플릿 메소드에 사용되는 추상 메소드를 선언한다.
이 추상 메소드는 하위 클래스인 Concreate Class에서 구현된다.&lt;/p&gt;

&lt;h3 id=&quot;concreate-class&quot;&gt;Concreate Class&lt;/h3&gt;
&lt;p&gt;Abstract Class를 상속하고 추상 메소드를 구현한다. Concreate Class에서 구현한 메소드는 Abstract Class의 템플릿 메소드에서 호출된다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;공통되는 부분을  묶어서 관리하기 때문에 코드의 중복을 줄일 수 있고 관리하기도 편하다.&lt;/li&gt;
  &lt;li&gt;알고리즘의 특정 부분만 재정의하여 변경 사항에 대한 영향을 줄일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;템플릿 메소드에 정의한 골격은 고정돼있기 때문에 유연성이 제한될 수 있다.&lt;/li&gt;
  &lt;li&gt;알고리즘이 복잡하다면 템플릿 메소드를 만들거나 유지하기 어려울 수 있다.&lt;/li&gt;
  &lt;li&gt;추상 메소드가 많아지면 새로운 서브 클래스를 추가하거나 관리하기가 어려울 수 있다.&lt;/li&gt;
  &lt;li&gt;템플릿 메소드의 실행 흐름을 이해해야지만 서브 클래스에서 추상 메소드를 재정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;만약 템플릿 메소드의 알고리즘이 변경된다면 서브 클래스에서 재정의한 추상 메소드를 수정해야 할 수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금까지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;템플릿 메소드 패턴&lt;/code&gt;의 구조와 특징에 대해서 알아봤다.
이제 실제로 어떤식으로 활용될 수 있는지 코드를 통해서 확인하자!&lt;/p&gt;

&lt;h2 id=&quot;예제-코드&quot;&gt;예제 코드&lt;/h2&gt;

&lt;h3 id=&quot;beverage-클래스-abstract-class&quot;&gt;Beverage 클래스 (Abstract Class)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt;메소드는 템플릿 메소드이다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boilWater()&lt;/code&gt;,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pour()&lt;/code&gt;는 모든 음료가 공통으로 처리해야 하는 로직이라고 생각하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;는 각 음료마다 재료가 다르기 때문에 달라져야 하는 부분이라고 생각해보자.
그러면 공통되는 부분은 나두고 각 음료마다 바뀌는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;를 추상 메소드로 선언하여 서브 클래스에서 구현하게 하면 변경을 최소화하면서 각 서브 클래스로 구현을 미루면서 유연한 확장을 할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;americano-chocolatelatee-클래스-concreate-class&quot;&gt;Americano, ChocolateLatee 클래스 (Concreate Class)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_3.png&quot; alt=&quot;img3&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Americano와  ChocolateLatte는 Beverage를 상속받아서 각자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;메소드를 구현하게 된다. 그리고 템플릿 메소드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt;를 호출하게 되면 전체적인 알고리즘 흐름은 동일하지만 세부 실행 내용을 변경할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;hook-메소드&quot;&gt;hook 메소드&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;hook 메소드&lt;/strong&gt;는 서브 클래스에서 좀 더 유연하게 템플릿 메소드의 알고리즘 로직을 다양화할 수 있게 도와주는 역할을 수행한다.
일반적으로 추상 메소드가 아닌 일반 메소드로 구현을 하게 된다.
그냥 나두게 되면 원래 설정한 기본 흐름대로 실행되고 서브 클래스에서 오버라이딩하게 되면 상황에 맞게 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;간단한 예시 코드를 보면서 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;템플릿 메소드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt; 안에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCustomerWantsTopping()&lt;/code&gt;가 앞에서 말한 hook 메서드이다.
기본적인 요구사항이 토핑을 추가하여 음료를 제공한다고 생각하고 로직을 작성한 것이다. 그런데 어떤 음료에는 토핑이 들어가지 않아야 할 수 있다. 이런 경우에는 서브 클래스에서 hook 메서드를 선택적으로 오버라이딩하여 템플릿 메소드의 흐름을 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_5.png&quot; alt=&quot;img5&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Americano에 기본적으로 토핑이 들어가면 안된다고 할 때, hook 메서드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCustomerWantsTopping()&lt;/code&gt;을 제정의하여 템플릿 메소드 안에있는 로직의 실행 흐름을 제어할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://url.kr/tw2s8o&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html"></summary></entry></feed>