<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-29T15:39:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[SQLD] 데이터 모델링</title><link href="http://localhost:4000/sqld/34/" rel="alternate" type="text/html" title="[SQLD] 데이터 모델링" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-29T00:00:00+09:00</updated><id>http://localhost:4000/sqld/34</id><content type="html" xml:base="http://localhost:4000/sqld/34/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;데이터-모델링&quot;&gt;&lt;em&gt;데이터 모델링&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;데이터-모델링의-단계&quot;&gt;데이터 모델링의 단계&lt;/h2&gt;

&lt;p&gt;개념적 모델링 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;고객의 비지니스 프로세스를 분석하고 업무 전체에 대해서 데이터 모델링을 수행&lt;/li&gt;
  &lt;li&gt;복잡하게 표현하지 않고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중요한 부분을 위주&lt;/code&gt;로 모델링하는 단계&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;업무적 관점&lt;/code&gt;에서 모델링하며, 기술적 용어는 가급적 사용 X&lt;/li&gt;
  &lt;li&gt;엔티티와 속성을 도출하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개념적 ERD&lt;/code&gt;를 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;논리적 모델링 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개념적 모델링을 논리적 모델링으로 변환하는 과정&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;식별자를 도출&lt;/code&gt;하고 필요한 모든 릴레이션을 정의한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정규화를 수행&lt;/code&gt;해서 데이터 모델의 독립성을 확보한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;물리적 모델링 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스를 실제 구축한다.
    &lt;ul&gt;
      &lt;li&gt;테이블, 인덱스, 함수 등을 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능, 보안, 가용성을 고려하여 구축한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_1.png&quot; alt=&quot;img1&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;erd-entity-relationship-diagram&quot;&gt;ERD (Entity Relationship Diagram)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;1976년 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;피터첸&lt;/code&gt;이 ERD 표기법을 만들었고, &lt;strong&gt;사실상 데이터 모델링의 표준&lt;/strong&gt;으로 사용되고 있음.&lt;/li&gt;
  &lt;li&gt;엔티티 간의 관계를 정의하는 모델링 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;작성 절차&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;엔티티를 도출하고 그린다.&lt;/li&gt;
  &lt;li&gt;엔티티를 배치한다.
    &lt;ul&gt;
      &lt;li&gt;엔티티를 도출한 후 엔티티를 베치한다.&lt;/li&gt;
      &lt;li&gt;중요한 엔티티를 왼쪽 상단에 배치 (가시성)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;엔티티 간의 관계를 설정한다.&lt;/li&gt;
  &lt;li&gt;관계명을 서술한다.
    &lt;ul&gt;
      &lt;li&gt;엔티티 간의 어떤 행위나 존재가 있는지 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관계 참여도를 표현한다.
    &lt;ul&gt;
      &lt;li&gt;관계 참여도 : 1개의 엔티티와 다른 엔티티 간의 참여하는 관계 수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관계의 필수 여부를 표현한다.
    &lt;ul&gt;
      &lt;li&gt;필수 : 반드시 존재해야 하는 것.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ERD 작성 시 고려사항&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중요한 엔티티를 가급적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;왼쪽 상단에 배치&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ERD는 이해하기 쉽고 복잡하지 않아야 함.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3중-스키마3-level-schema&quot;&gt;3중 스키마(3-Level Schema)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_2.png&quot; alt=&quot;img2&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;외부 스키마&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자 관점, 업무상 관련이 있는 데이터 접근&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;응용 프로그램이 접근하는 데이터베이스&lt;/strong&gt;를 정의한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개념 스키마&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;설계자 관점, 사용자 전체 집단의 데이터베이스 구조&lt;/li&gt;
  &lt;li&gt;전체 데이터베이스 내의 규칙과 구조를 표현한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;통합 데이터베이스 구조&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내부 스키마&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개발자 관점, &lt;strong&gt;데이터베이스의 물리적 저장 구조&lt;/strong&gt;이다.&lt;/li&gt;
  &lt;li&gt;데이터 저장 구조, 레코드 구조, 필드 정의, 인덱스 등을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;엔티티entity&quot;&gt;엔티티(Entity)&lt;/h2&gt;

&lt;p&gt;엔티티 특징&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;식별자
    &lt;ul&gt;
      &lt;li&gt;엔티티는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유일한 식별자&lt;/code&gt;가 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인스턴스 집합
    &lt;ul&gt;
      &lt;li&gt;2개 이상의 인스턴스를 가져야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속성
    &lt;ul&gt;
      &lt;li&gt;엔티티는 &lt;strong&gt;반드시 속성&lt;/strong&gt;을 가지고 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관계
    &lt;ul&gt;
      &lt;li&gt;엔티티는 &lt;strong&gt;다른 엔티티와 최소 1개 이상의 관계&lt;/strong&gt;가 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;업무
    &lt;ul&gt;
      &lt;li&gt;엔티티는 &lt;strong&gt;업무에서 관리되어야 하는 집합&lt;/strong&gt;이어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;엔티티의 종류&lt;br /&gt;
엔티티의 종류에 대해서는 아래 그림을 참고하자. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;물리적 형태의 존재 여부에 따른 분류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_3.png&quot; alt=&quot;img3&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;발생 시점에 따른 분류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_4.png&quot; alt=&quot;img4&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;속성attribute&quot;&gt;속성(Attribute)&lt;/h2&gt;

&lt;p&gt;속성이란?&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;업무에서 필요한 정보인 엔티티가 가지는 항목&lt;/li&gt;
  &lt;li&gt;더 이상 분리되지 않는 단위로, 업무에 필요한 데이터를 저장할 수 있다.&lt;/li&gt;
  &lt;li&gt;인스턴스의 구성요소이고 의미적으로 더 이상 분해되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특징&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;속성은 &lt;strong&gt;하나의 값&lt;/strong&gt;만 가진다.&lt;/li&gt;
  &lt;li&gt;주식별자에게 함수적으로 종속된다.
    &lt;ul&gt;
      &lt;li&gt;기본키가 변경되면, 속성의 값도 변경된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;분류&lt;br /&gt;
속성의 분류는 아래 표를 참고하자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;분해 여부에 따른 속성의 분류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_5.png&quot; alt=&quot;img5&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;특성에 따른 속성의 분류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_6.png&quot; alt=&quot;img6&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;도메인이란?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;속성이 가질 수 있는 &lt;strong&gt;값의 범위&lt;/strong&gt;를 의미한다.&lt;/li&gt;
  &lt;li&gt;예를 들어 성별이라는 속성의 도메인은 ‘남자’, ‘여자’ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관계relationship&quot;&gt;관계(Relationship)&lt;/h2&gt;

&lt;p&gt;관계란?&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;엔티티 간의 관련성을 의미를 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관계의 종류&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;존재 관계
    &lt;ul&gt;
      &lt;li&gt;엔티티 간의 상태를 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;행위 관계
    &lt;ul&gt;
      &lt;li&gt;엔티티 간의 어떤 행위가 있는 것.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관계 차수&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;두 개의 엔티티 간에 &lt;strong&gt;관계의 참여하는 수&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_7.png&quot; alt=&quot;img7&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;필수적 관계와 선택적 관계&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;필수적 관계는 ‘l’로 표현되고, 선택적 관계는 ‘O’로 표현된다.&lt;/li&gt;
  &lt;li&gt;필수적 관계
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;반드시 하나가 있어야&lt;/strong&gt; 하는 관계&lt;/li&gt;
      &lt;li&gt;고객이 반드시 있어야 계좌를 개설할 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선택적 관계
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;없을 수도 있는&lt;/strong&gt; 관계&lt;/li&gt;
      &lt;li&gt;고객은 있지만, 계좌가 없을 수도 있다면 선택적 관계가 됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;식별 관계와 비식별 관계&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;식별 관계
    &lt;ul&gt;
      &lt;li&gt;강한 개체의 기본키를 다른 엔티티의 기본키로 가지는 관계&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실선&lt;/code&gt;으로 표현한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비식별 관계
    &lt;ul&gt;
      &lt;li&gt;강한 개체의 기본키를 다른 엔티티의 기본키가 아닌 일반 컬럼으로 관계를 가지는 것.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;점선&lt;/code&gt;으로 표현한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;엔티티-식별자entity-identifier&quot;&gt;엔티티 식별자(Entity Identifier)&lt;/h2&gt;

&lt;p&gt;식별자란?&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;엔티티를 대표할 수 있는 &lt;strong&gt;유일성&lt;/strong&gt;을 만족하는 속성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주식별자 속성&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최소성
    &lt;ul&gt;
      &lt;li&gt;주식별자는 최소성을 만족하는 키이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대표성
    &lt;ul&gt;
      &lt;li&gt;주식별자는 엔티티를 대표할 수 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유일성
    &lt;ul&gt;
      &lt;li&gt;주식별자는 엔티티의 인스턴스를 유일하게 식별한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;불변성
    &lt;ul&gt;
      &lt;li&gt;주식별자는 자주 변경되지 않아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;키의 종류&lt;br /&gt;
아래 표를 참고하자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/33_8.png&quot; alt=&quot;img8&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;식별자의 종류&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대표성 여부에 따라 주식별자, 보조 식별자로 나뉜다.
    &lt;ul&gt;
      &lt;li&gt;주식별자
        &lt;ul&gt;
          &lt;li&gt;유일성과 최소성을 만족하면서, &lt;strong&gt;엔티티를 대표하는 식별자&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;다른 엔티티의 &lt;strong&gt;참조 관계로 연결&lt;/strong&gt;될 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;보조 식별자
        &lt;ul&gt;
          &lt;li&gt;유일성과 최소성을 만족하지만, &lt;strong&gt;대표성을 만족하지 못하는 식별자&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;생성 여부에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;내부 식별자
        &lt;ul&gt;
          &lt;li&gt;엔티티 &lt;strong&gt;내부에서 스스로 생성&lt;/strong&gt;되는 식별자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;외부 식별자
        &lt;ul&gt;
          &lt;li&gt;다른 엔티티와의 관계로 인하여 만들어지는 식별자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속성의 수에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;단일 식별자
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;하나의 속성&lt;/strong&gt;으로 구성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;복합 식별자
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;2개 이상&lt;/strong&gt;의 속성으로 구성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대체 여부
    &lt;ul&gt;
      &lt;li&gt;본질 식별자
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;비지니스 프로세스&lt;/strong&gt;에서 만들어지는 식별자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인조 식별자
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;인위적&lt;/strong&gt;으로 만들어지는 식별자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;&lt;em&gt;참고 사이트 출처&lt;/em&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://starrykss.tistory.com/1612&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="SQLD" /><category term="데이터베이스" /><category term="SQLD" /><summary type="html"></summary></entry><entry><title type="html">[알고리즘] 비트 마스킹</title><link href="http://localhost:4000/algorithm/33/" rel="alternate" type="text/html" title="[알고리즘] 비트 마스킹" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/33</id><content type="html" xml:base="http://localhost:4000/algorithm/33/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;비트-마스크란&quot;&gt;&lt;em&gt;비트 마스크란?&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;컴퓨터는 내부적으로 모든 연산을 이진수로 표현하고 처리한다. 이런 특성을 이용해서 정수의 이진수 표현을 자료구조로 쓰는 기법을 &lt;strong&gt;비트 마스크&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;비트-연산자&quot;&gt;&lt;em&gt;비트 연산자&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;파이썬의 기본 비트 연산자를 먼저 살펴보자.&lt;/p&gt;

&lt;h2 id=&quot;and-or-xor&quot;&gt;AND, OR, XOR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND 연산&lt;/code&gt; (&amp;amp;) : 두 비트가 모두 1일 때, 1을 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR 연산&lt;/code&gt; (l) : 두 비트가 하나라도 1이면, 1을 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XOR 연산&lt;/code&gt; (^) : 대응하는 두 비트가 서로 다르면 1을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1011&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1010&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1111&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1111&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1010&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1111&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0101&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;not&quot;&gt;NOT&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT 연산&lt;/code&gt; (~) : 비트의 값을 뒤집어서 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1010&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0101&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;shift-연산&quot;&gt;Shift 연산&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;left shift&lt;/code&gt; («) : 왼쪽으로 비트 이동 (X * 2^Y)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;right shift&lt;/code&gt; (») : 오른쪽으로 비트 이동 (X / 2^B)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;00001010&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;101000&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;00001010&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;000010&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;집합과-비트마스크&quot;&gt;&lt;em&gt;집합과 비트마스크&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;비트 마스크를 사용하면 집합을 굉장히 효율적으로 표현할 수 있다. 예를 들어 10개의 방문 체크를 해야 하는 상황이라고 가정하자. &lt;br /&gt; 그러면  check = [False] * 10 와 같이 리스트로 표현하는 것이 일반적일 것이다.&lt;br /&gt;
그런데 비트 마스크를 사용하면 check = 0b0000000000 와 같이 표현할 수 있다. 메로리를 훨씬 적게 사용하고 연산도 모두 O(1) 이기 때문에 굉장히 효율적이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;집합의-연산과-비트-마스크&quot;&gt;집합의 연산과 비트 마스크&lt;/h2&gt;

&lt;p&gt;이제 비트 마스크를 활용한 집합의 연산에 대해서 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원소 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;집합 S에 x를 추가하려고 할 때, S의 x번 비트만 1로 만들어주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원소 삭제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;집합 S에서 x를 삭제할 때, S의 x번 비트를 0으로 만들어주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원소 토글&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;집합 S에 x가 있다면 삭제하는 연산이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원소 체크&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;집합 S에 원소가 있으면 1을 반환, 없으면 0을 반환해주는 연산이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원소 비우기, 채우기&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 비우기
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#채우기
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;원소를 비우기 위해서 S의 모든 비트를 0으로 만들어주면 된다. 채울때는 모든 비트를 1로 만들어주면 된다. 1 « 21 을 통해서 집합 수보다 1만큼 큰 비트 sequence를 만들어주고 1을 빼면 집합길이(20) 만큼의 1로 채워진 집합이 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;집합-연산&quot;&gt;&lt;em&gt;집합 연산&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;당연히 집합간의 연산도 가능하다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 합집합
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 교집합
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 차집합 (A - B)
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# A와 B중 하나만 속한 원소
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://velog.io/@1998yuki0331/Python-%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%82%B9-%EC%A0%95%EB%A6%AC
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="Algorithm" /><category term="비트 마스킹" /><category term="알고리즘" /><category term="자료구조" /><summary type="html"></summary></entry><entry><title type="html">[JAVA] Concurrency Issue &amp;amp; Thread Local</title><link href="http://localhost:4000/java/spring/java3/" rel="alternate" type="text/html" title="[JAVA] Concurrency Issue &amp;amp; Thread Local" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/java/spring/java3</id><content type="html" xml:base="http://localhost:4000/java/spring/java3/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;concurrency-issue&quot;&gt;&lt;em&gt;Concurrency Issue&lt;/em&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;동시성 문제란 동일한 자원에 대해서 여러 스레드가 동시에 접근해서 값을 바꾸면서 발생하는 문제를 뜻한다. 단순히 읽기를 할때는 문제가 발생하지 않지만 값을 바꾸게 되면 문제가 발생할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예시를 보고 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/30_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FieldService&lt;/code&gt;는 Spring bean으로 등록되어 있어서 싱글톤으로 관리되는 상태이다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt; 가 FieldService의 맴버 변수 nameStore에 접근해서 값을 바꾼 후 조회하는 로직을 실행하였다. 이 로직을 실행하고 있는 시점에 동시에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-B&lt;/code&gt;가 동일한 로직을 실행했다고 생각해보자. 그러면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;가 값을 조회하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-B&lt;/code&gt;가 값을 바꾸면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;에서 조회한 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-B&lt;/code&gt;가 바꾼 값으로 조회될 수 있다. 원래 기대한 결과와는 다른 결과가 도출된 것이다. 이런 문제를 &lt;strong&gt;동시성 문제&lt;/strong&gt;라고 한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이러한 문제를 어떻게 해결할 수 있을까? Java에서 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;을 사용하면 된다 ^-^ &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;threadlocal&quot;&gt;&lt;em&gt;ThreadLocal&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;TheadLocal은 해당하는 Thread만 접근할 수 있는 특별한 저장소라고 생각하면 된다. 다른 Thread에서 접근할 수 없다. 그림을 보고 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/30_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;가 ThreadLocal에 값을 넣으면 ThreadLocal은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;의 전용 저장소에 값을 저장한다. 그러면 다른 Thread에서는 이 저장소에 접근해서 값을 읽거나 쓸 수 없다. 오직 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;만 접근할 수 있는 것이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용-방법-및-주의점&quot;&gt;사용 방법 및 주의점&lt;/h2&gt;
&lt;p&gt;ThreadLocal에서 값을 넣을땐 set()을 사용하고 꺼낼때는 get()을 사용하면 된다. &lt;br /&gt;
한 가지 주의점이 있는데 &lt;strong&gt;ThreadLocal을 다 사용하고 나면 반드시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal.remove()&lt;/code&gt;를 호출해서 ThreadLocal에 저장된 값을 지워줘야 한다.&lt;/strong&gt; &lt;br /&gt;
이유는 그림을 통해서 설명하겠다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/30_3.png&quot; alt=&quot;img3&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Tomcat 같은 WAS는 일반적으로 Thread pool 방식을 사용한다. Thread를 생성하는 비용이 비싸기 때문에 미리 Thread들을 생성해두고 요청이 오면 해당 쓰레드를 할당해주는 방식이다. 그리고 요청이 끝나면 해당 Thread를 Thread pool에 반납한다. 때문에 Thread는 애플리케이션이 종료될 때까지 사라지지 않는다. &lt;br /&gt;
이런 상황속에서 사용자A가 HTTP 요청을 했다고 가정해보자. 요청에 대해서 WAS가 Thread pool에서 놀고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;를 할당해줬다고 가정하자. 그리고 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;에서 ThreadLocal에 값을 저장했다고 해보자. 그러면 사용자A 요청에 의한 어떤 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt; 전용 저장소에 저장될 것이다. 그리고 요청이 끝나서 나갔다. &lt;br /&gt;&lt;br /&gt;
이제 다른 사용자B 가 HTTP 요청을 했다. 그런데 하필이면 WAS가 또 Thread pool에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt;를 할당했다고 해보자. 이렇게 되면 사용자A 와 전혀 관련없는 사용자B가 ThreadLocal을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-A&lt;/code&gt; 저장소에 저장된 사용자A의 정보를 확인할 수 있게 된다. 나와 전혀 상관없는 제3자가 내 정보를 조회하는 것이다. 이런 문제를 방지하기 위해서 반드시 ThreadLocal을 다 사용하고 나면 ThreadLocal에 저장된 값을 날려줘야 한다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
더 자세한 내용은 김영한님 강의를 참고하자!&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Java" /><category term="Spring" /><category term="Java" /><category term="Spring" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 데이터 JPA(2)</title><link href="http://localhost:4000/jpa/sj2/" rel="alternate" type="text/html" title="[JPA] 데이터 JPA(2)" /><published>2023-08-18T00:00:00+09:00</published><updated>2023-08-18T00:00:00+09:00</updated><id>http://localhost:4000/jpa/sj2</id><content type="html" xml:base="http://localhost:4000/jpa/sj2/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;paging-이슈&quot;&gt;&lt;em&gt;Paging 이슈&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;JPA가 없던 시절에 Paging 처리를 하는 것은 굉장히 귀찮은 일이었다. JPA가 등장하면서 Paging을 쉽게 처리할 수 있게 되었다. Spring data JPA를 사용하면 페이지 계산과 같이 반복적이고 실수하기 쉬운 것을 추상화해서 사용하기 쉽게 제공해준다. &lt;br /&gt;
먼저 순수 JPA를 사용한 Paging 처리를 보고 다음으로 Spring data JPA를 사용해서 처리하는 코드를 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;순수-jpa-paging&quot;&gt;순수 JPA Paging&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByPage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;select m from Member m where m.age = :age order by m.username desc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setFirstResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setMaxResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResultList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;totalCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;select count(m) from Member m where m.age = :age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSingleResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;offset과 limit을 받아서 JPQL을 짜면 된다. 결과값의 개수를 알아야 하기 때문에 별도의 CountQuery 도 날려줘야 한다.&lt;br /&gt;
그럼 이제 Spring data JPA를 사용할 때의 Paging을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pageable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pageable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pageable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pageable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pageable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pageable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Sort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 반환타입에 따른 동작방식을 이해해보자.&lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page&lt;/code&gt;객체를 반환하는 경우 Spring data JPA 가 별도로 CountQuery를 생성해서 날려준다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slice&lt;/code&gt;객체를 반환하는 경우에는 별도의 CountQuery가 날라가지 않는다. 대신에 Pageable에서 받은 개수보다 1개 더 많이 가져와서 뒤에 페이지가 더 존재하는지 확인한다. 이제 Page 객체와 Slice 객체의 내부를 살펴보자 :) &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-interface&quot;&gt;Page Interface&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getTotalPages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getTotalElements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Fuction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;supter&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;converter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;slice-interface&quot;&gt;Slice Interface&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Streamable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNumberOfElements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getContent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasContent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Sort&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isFirst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isLast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasPrevious&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Pageable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getPageable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Pageable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nextPageable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Pageable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;previousPageable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;converter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 기능들을 예전에는 한땀한땀 열심히 구현해서 사용해야 했었다. 그런데 JPA에서 이미 다 제공해주기 때문에 그냥 가져다 사용하면 된다.&lt;br /&gt;
여기서 두가지 주의해야 할 점이있다. &lt;strong&gt;JPA의 페이지는 1부터가 아니라 0부터 시작한다는 것이다.&lt;/strong&gt; 두번째는 CountQuery는 무거운 연산이라는 것이다. 때문에 복잡한 쿼리에서는 CountQuery를 분리하고 left join같은 경우는 CountQuery를 할 필요가 없다. 이를 주의하자!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
더 자세한 내용은 김영한님 강의를 참고하자!&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="Data JPA" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 데이터 JPA(1)</title><link href="http://localhost:4000/jpa/sj1/" rel="alternate" type="text/html" title="[JPA] 데이터 JPA(1)" /><published>2023-08-18T00:00:00+09:00</published><updated>2023-08-18T00:00:00+09:00</updated><id>http://localhost:4000/jpa/sj1</id><content type="html" xml:base="http://localhost:4000/jpa/sj1/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;repository-기능&quot;&gt;&lt;em&gt;@Repository 기능&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;@Repository는 2가지 기능을 제공한다. 첫번째는 이 Annotation이 붙은 클래스를 스프링 빈으로 등록한다. 두번째는 JPA 예외를 스프링 예외로 변환해준다. 데이터를 직접 접근하는 Repository 계층 구현 기술에 Service 계층이 직접 의존하는 것은 좋은 설계라고 할 수 없다. 이는 예외 처리에도 동일하게 적용된다. @Repository를 붙이면 데이터 접근 계층의 예외를 추상화해서 Service 계층에 넘김으로써 데이터 접근 계층의 예외가 바뀌더라도 코드를 변경하지 않고 동일하게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;공통-인터페이스&quot;&gt;&lt;em&gt;공통 인터페이스&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring data JPA&lt;/code&gt;를 제대로 이해하기 위해서는 공통 인터페이스에 대해서 알 필요가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/29_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;공통 인터페이스는 위와 같은 구조로 이루어져 있다. 이 인터페이스를 개발자가 직접 구현할 필요가 없다. Spring data JPA 가 구현 클래스를 우리 대신 생성해서 넣어준다. 때문에 우리는 그냥 가져다 쓰면 된다. ^.^&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;메소드-이름으로-쿼리-자동생성&quot;&gt;&lt;em&gt;메소드 이름으로 쿼리 자동생성&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;Spring data JPA는 repository에 작성한 메소드 이름을 분석해서 JPQL 쿼리를 실행해준다. 순수한 JPA를 사용했을 때의 쿼리와 Spring data JPA 를 사용했을 때 코드를 비교해보자.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래 코드는 순수 JPA를 사용했을 때 코드이다.
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByUsernameAndAgeGreaterThan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;select m from Member m where m.username = :username and m.age &amp;gt; :age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResultList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래 코드는 Spring Data JPA를 사용했을 때의 코드이다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findByUsernameAndAgeGreaterThan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;힘의 차이가 확실히 느껴진다.&lt;/strong&gt; &lt;br /&gt;
 위와 같이 단순한 쿼리에 대해서 Spring Data JPA를 사용하면 생산성이 대폭 증가한다.
하지만 장점만 존재하지는 않는다. 쿼리 조건이 많아질수록 메서드 이름도 같이 늘어난다. 때문에 복잡한 조건의 쿼리는 다른 방법으로 해결해야 한다.
이 방법도 뒤에서 소개하겠다. 메서드 이름 규칙은 Spring 공식 페이지에 잘 나와있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;spring-data-jpa의-namedquery&quot;&gt;&lt;em&gt;Spring Data JPA의 NamedQuery&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;순수 JPA에서 namedQuery를 작성하려면 Entity에 직접 작성해야 하거나, XML 파일을 통해서 작성해야 했다. 첫번째는 Entity가 굉장히 지저분해진고 XML은 따로 관리해야 했기 때문에 불편했었다. Spring Data JPA는 @Query를 통해서 Repository에 직접 작성할 수 있다.
아래 예제 코드를 보자. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nd&quot;&gt;@Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;select m from Member m where m.username = :username and m.age = :age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 작성하면 된다. namedQuery의 장점은 컴파일 시점에 쿼리를 파싱해서 체크하기 때문에 문법 오류를 발견할 수 있는 것인데 @Query로 작성한 쿼리도 namedQuery로 간주되기 때문에 굉장히 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;반환-타입-지정&quot;&gt;&lt;em&gt;반환 타입 지정&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;Spring Data JPA는 유연하게 반환 타입을 지원한다. 그렇기 때문에 어떻게 작동하는지 잘 이해할 필요가 있다. &lt;br /&gt;
조회 결과가 여러개 이거나, 없다면 어떻게 될까? 컬렉션의 경우 결과가 없으면 빈 컬렉션을 반환한다. 하지만 Entity와 같이 타입을 단건으로 찝은 경우에는 결과가 없으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;이 반환된다. 이 차이를 인지하고 있어야 한다. &lt;br /&gt;
그리고 단건 반환 타입을 설정한 경우 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getSingleResult()&lt;/code&gt; 를 호출하기 때문에 2개 이상의 값이 나오면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NoResultException&lt;/code&gt; 이 발생하는데 Spring Data JPA에서 예외를 catch해서 null로 반환한다. 동작방식을 잘 이해하도록 하자!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
더 자세한 내용은 김영한님 강의를 참고하자!&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="Data JPA" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 연관관계 매핑(2)</title><link href="http://localhost:4000/jpa/JPA5/" rel="alternate" type="text/html" title="[JPA] 연관관계 매핑(2)" /><published>2023-07-27T00:00:00+09:00</published><updated>2023-07-27T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA5</id><content type="html" xml:base="http://localhost:4000/jpa/JPA5/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;오늘은 JPA에서 상속관계를 매핑하는 방법에 대해서 알아보자!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;상속관계-매핑&quot;&gt;&lt;em&gt;상속관계 매핑&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;관계형 데이터베이스는 상속 관계에 대한 매핑을 따로 지원하지 않는다. 슈퍼타입, 서브타입 관계라는 모델링 기법을 통해서 상속관계를 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;슈퍼타입, 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 크게 3가지가 있다. 이 중에서 구현 클래스마다 테이블을 만드는 전략은 실제로 사용되지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조인 전략&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일 테이블 전략&lt;/code&gt;에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;조인-전략&quot;&gt;&lt;em&gt;조인 전략&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/28_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조인 전략은 상속관계를 매핑하는데 가장 많이 사용되는 전략이다. 공통되는 속성들을 하나의 테이블(여기서는 Item)에 넣고 공통되지 않는 고유의 속성들은 각각의 테이블(Album, Movie, Book)에 넣는다. 그리고 조인을 통해서 데이터를 가져온다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;테이블이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정규화&lt;/code&gt;된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외래키 참조 무결성 제약조건&lt;/code&gt;을 활용가능하다.&lt;/li&gt;
  &lt;li&gt;저장공간을 효율적으로 사용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;정규화되서 관리되기 때문에 중복되지 않고 잘 관리된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;조회할 때 조인을 많이 사용하기 때문에 약간의 성능 저하가 있다.&lt;/li&gt;
  &lt;li&gt;조인으로 쿼리가 나가기 때문에 복잡하다.&lt;/li&gt;
  &lt;li&gt;각각의 테이블이 있기 때문에 하나를 저장할 때 INSERT SQL이 2번 호출된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;적용&quot;&gt;적용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inheritance(strategy = inheritanceType.JOINED) &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;이 에노테이션을 부모 엔티티에 붙여주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DiscriminatorColumn(name=&quot;DTYPE&quot;)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;이 에노테이션을 넣으면 슈퍼타입 테이블에 서브타입 테이블의 종류를 표현하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTYPE&lt;/code&gt;이라는 컬럼이 생긴다.&lt;/li&gt;
      &lt;li&gt;JOIN 전략에서는 안넣어줘도 동작하기는 하지만 운영을 편하게 하기 위해서 넣어주는 것이 좋다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DiscriminatorValue(&quot;xxx&quot;)&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;DTYPE에 저장되는 타입의 이름을 지정할 수 있는 에노테이션이다.&lt;/li&gt;
          &lt;li&gt;자식 엔티티에 붙여줄 수 있다. 기본값은 클래스 이름이고 기본값을 사용하면 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;단일-테이블-전략&quot;&gt;단일 테이블 전략&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/28_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단일 테이블 전략은 한 테이블에 자식 엔티티 컬럼까지 다 때려박고 운영하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;조인이 필요 없어서 일반적으로 조회 성능이 좋다.&lt;/li&gt;
  &lt;li&gt;조회 쿼리가 단순하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;자식 엔티티가 매핑한 칼럼은 모두 null 허용을 해야한다.&lt;/li&gt;
  &lt;li&gt;한 테이블에 모든 속성을 때려박기 때문에 테이블이 커져서 상황에 따라서 조회가 느려질 수 있다.
    &lt;ul&gt;
      &lt;li&gt;임계점을 넘겨야 느려지는데 이런 경우는 잘 발생하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;

&lt;p&gt;그래서 어떤것을 사용하면 좋을까?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본적으로 조인 전략을 사용하고 진짜 단순한 경우에 단일 테이블 전략을 사용하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 연관관계 매핑(1)</title><link href="http://localhost:4000/jpa/JPA4/" rel="alternate" type="text/html" title="[JPA] 연관관계 매핑(1)" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA4</id><content type="html" xml:base="http://localhost:4000/jpa/JPA4/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;객체와-테이블의-패러다임-불일치&quot;&gt;&lt;em&gt;객체와 테이블의 패러다임 불일치&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;먼저 객체와 테이블 사이의 간극을 이해할 필요가 있다. 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조&lt;/code&gt; 를 사용해서 연관된 객체를 찾는다. 그런데 테이블은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외래키 조인&lt;/code&gt;을 통해서 연관된 테이블을 찾는다. 때문에 객체를 테이블에 맞춰서 설계를 하면 객체간의 협력 관계를 만들 수 없다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 사이의 관계를 통해 이해해보자.&lt;/p&gt;

&lt;p&gt;여기서 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 는 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 에만 속할 수 있다고 가정하자. (1:N)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;테이블에-맞춘-객체-설계&quot;&gt;테이블에 맞춘 객체 설계&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;//Team team 과 같이 참조를 가지는 것이 아니라 식별자를 가진다.&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;TEAM_ID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teamId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clas&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Team 조회&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//member.getTeam()과 같이 바로 조회할 수 없고 id를 구한 후 이를 통해 한번 더 조회해야 한다.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeamId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTeamId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;team&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeamId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 경우가 테이블에 맞춰서 객체를 설계한 케이스이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 을 참조로 가지고 있는 것이 아니라 외래키를 그대로 들고 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 Member에서 Team을 조회할 때, 참조로 바로 Team을 조회할 수 없고 ID를 통해서 다시 조회해야 한다. 이는 객체 지향적인 방법이 아니다.&lt;/p&gt;

&lt;p&gt;ORM을 통해서 이러한 패러다임의 불일치를 해결할 수 있다. 객체는 객체대로 모델링하면 가운데서 ORM이 알맞게 매핑해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;객체지향-모델링&quot;&gt;객체지향 모델링&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  
	&lt;span class=&quot;nd&quot;&gt;@ManyToOne&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@JoinColumn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;TEAM_ID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;team&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 코드를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 객체를 참조로 가지고 있다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 테이블에서는 외래키로 TEAM_ID를 가지고 있을 것이다. 이런 차이를 매핑해주는 것이 바로 &lt;strong&gt;ORM&lt;/strong&gt; 이다. 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/27_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member 객체&lt;/code&gt;에 있는 Team 참조를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member Table&lt;/code&gt; 에 TEAM_ID 라는 외래키로 매핑해준다. 이 때 외래키 이름을 지정해줘야 하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@JoinColumn&lt;/code&gt; 을 통해 지정해줄 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;양방향-매핑&quot;&gt;양방향 매핑&lt;/h1&gt;

&lt;p&gt;이제 양방향 매핑에 대해서 탐구해보자. 양방향 매핑일 때는 고려해야 할 점이 좀 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt;는 양방향 매핑을 하려면 양쪽에 참조를 가져야 한다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;테이블&lt;/code&gt;은 외래키 하나로 조인을 통해서 양쪽을 이동할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/27_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림을 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member 객체&lt;/code&gt;에 있는 Team, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team 객체&lt;/code&gt;에 있는 Member 참조값을 통해서 양쪽을 왔다갔다 할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 테이블은 MEMBER 테이블에 있는 TEAM_ID라는 외래키를 통해서 양쪽을 이동한다.&lt;/p&gt;

&lt;p&gt;사실 객체는 양방향을 구현하려면 단방향 두개가 있어야 하는 것이고 테이블은 외래키 하나만 있으면 되는 것이다. 때문에 &lt;strong&gt;두 객체 중 한쪽에서 외래키를 관리해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;연관관계의-주인&quot;&gt;연관관계의 주인&lt;/h1&gt;

&lt;p&gt;객체의 두 관계중 하나를 연관관계의 주인으로 설정하고 주인쪽에서 외래키를 관리해야 한다. 반대쪽(거울)에서는 오직 읽기만 가능하다.&lt;/p&gt;

&lt;p&gt;규칙은 간단하다. &lt;strong&gt;외래키를 가지고 있는 곳을 주인으로 설정하면 된다.&lt;/strong&gt; 1:N관계라면 무조건 N쪽에 외래키가 존재하기 때문에 N쪽을 주인으로 설정하면 된다. 거울쪽에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mappedBy&lt;/code&gt; 설정을 해주면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주의점 : 거울쪽에서 수정을 하더라도 udpate query가 날아가지 않는다. (단순 조회만 가능)
    &lt;ul&gt;
      &lt;li&gt;객체 관점에서 보면 양쪽 다 변경되는 것이 맞기 때문에 다 변경해주자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 기본키 매핑 전략</title><link href="http://localhost:4000/jpa/JPA3/" rel="alternate" type="text/html" title="[JPA] 기본키 매핑 전략" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA3</id><content type="html" xml:base="http://localhost:4000/jpa/JPA3/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;기본-키-매핑-전략&quot;&gt;기본 키 매핑 전략&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDENTITY&lt;/code&gt; : 데이터베이스에 위임하는 전략
    &lt;ul&gt;
      &lt;li&gt;MYSQL에서 사용됨.&lt;/li&gt;
      &lt;li&gt;AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID값을 알 수 있기 때문에 em.persist() 시점에 바로 INSERT SQL을 실행하고 ID를 가져온다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strategy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GenerationType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;IDENTITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQUENCE&lt;/code&gt; : 데이터베이스 시퀀스 오브젝트 사용
    &lt;ul&gt;
      &lt;li&gt;오라클에서 사용&lt;/li&gt;
      &lt;li&gt;데이터베이스 시퀀스란 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트를 뜻한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@SequenceGenerator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ITEM_SEQ_GENERATOR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;,
sequenceName = “ITEM_SEQ&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;initialValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocationSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strategy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GenerationType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SEQUENCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Table&lt;/code&gt; : 키 생성용 테이블 사용, 모든 DB에 적용 가능
    &lt;ul&gt;
      &lt;li&gt;키 생성 전용 테이블을 하나 만들고 데이터베이스 시퀀스를 흉내내는 전략&lt;/li&gt;
      &lt;li&gt;모든 데이터베이스에 적용이 가능하지만 성능이 좋지 않다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Object&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@TableGenerator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ITEM_SEQ_GENERATOR&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;MY_SEQUENCES&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pkColumnValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ITEM_SEQ&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;, allocationSize = 1)
public class Item {
@Id
@GeneratedValue(strategy = GenerationType.TABLE,
generator = &quot;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ITEM_SEQ_GENERATOR&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;create table MY_SEQUENCES (
sequence_name varchar(255) not null,
next_val bigint,
primary key ( sequence_name )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTO&lt;/code&gt; : 방언에 따라 자동 지정, 기본 값&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실무-사용-가이드&quot;&gt;실무 사용 가이드&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;기본키는 Long Type + 대체키 + 키 생성전략을 활용하자&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 영속성 컨텍스트</title><link href="http://localhost:4000/jpa/JPA2/" rel="alternate" type="text/html" title="[JPA] 영속성 컨텍스트" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA2</id><content type="html" xml:base="http://localhost:4000/jpa/JPA2/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;영속성-컨텍스트&quot;&gt;&lt;em&gt;영속성 컨텍스트&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;영속성 컨텍스트란 &lt;strong&gt;엔티티를 영구 저장하는 환경&lt;/strong&gt;이라는 뜻이다. 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB역할을 수행한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EntityManager&lt;/code&gt;를 통해서 엔티티를 저장하거나 조회를 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EntityManager&lt;/code&gt;는 영속성 컨텍스트에 엔티티를 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;엔티티의-생명주기&quot;&gt;&lt;em&gt;엔티티의 생명주기&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/25_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;엔티티의 생명주기는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비영속&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;영속&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준영속&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt;가 있다. 하나씩 알아보자&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비영속(new/transient)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트와 전혀 관계가 없는 상태이다. 영속성 컨텍스트가 관리하지 않는 상태를 의미한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//비영속 상태&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuantity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;영속(managed)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에 저장, 관리되는 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//영속 상태&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuantity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;EntityManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createEntityManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTransaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//영속성 컨텍스트에 집어넣는다. 이때 DB에 query가 날아가지는 않는다. transaction commit 시점에 query가 날아감.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준영속(detached)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에 저장되었다가 분리된 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//아이템 엔티티를 영속성 컨텍스트에서 분리 -&amp;gt; 준영속 상태&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;detach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제(removed)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;삭제된 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//객체를 삭제한 상태&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;영속성-컨텍스트의-장점&quot;&gt;영속성 컨텍스트의 장점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1차 캐시&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에 데이터가 있으면 DB를 거치지 않고 바로 영속성 컨텍스트에서 데이터를 조회할 수 있다. 이를 1차 캐시라고 한다.&lt;/li&gt;
      &lt;li&gt;애플리케이션 차원에서 1차 캐시를 통해서 반복 가능한 읽기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPEATABLE READ&lt;/code&gt;) 등급의 트랜잭션 격리 수준을 제공한다.&lt;/li&gt;
      &lt;li&gt;em.find(), em.persist()를 하면 해당 트랜잭션 안에서 영속성 컨텍스트로 관리된다. 예시를 보자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제코드 1)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//예시를 보자&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuantity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//persist를 하면 영속성 컨텍스트에서 저장, 관리된다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제코드 2)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;em.find()를 호출하면 영속성 컨텍스트에서 먼저 해당하는 엔티티 있는지 찾는다. 만약 없으면 DB에 query를 날려서 가져오고 이를 영속성 컨텍스트에 저장, 관리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쓰기지연&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;em.persist() 를 호출하는 시점에 DB로 query를 날리는 것이 아니라 해당 객체를 영속성 컨텍스트에서 관리하기 시작하고 쓰기 지연 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL 저장소&lt;/code&gt; 에 SQL을 쌓아두었다가 트랜잭션 커밋시점에 한번에 DB에 query를 날린다.&lt;/li&gt;
      &lt;li&gt;아래 그림을 보면 이해하기 쉬울 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/25_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변경감지(Dirty checking)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에서 관리되는 객체들은 변경감지가 적용된다.&lt;/li&gt;
      &lt;li&gt;JPA는 영속성 컨텍스트에 엔티티를 보관할 때 최초의 상태를 저장한다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스냅샷&lt;/code&gt;이라고 한다.&lt;/li&gt;
      &lt;li&gt;영속성 컨텍스트가 Flush 되는 시점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스냅샷&lt;/code&gt; 과 엔티티의 현재 상태를 비교하고 달라진 엔티티를 찾고 변경된 필드들에 대해서 쓰기 지연 SQL에 Update query를 쌓는다.&lt;/li&gt;
      &lt;li&gt;트랜잭션 커밋시점에 쌓여있던 Update query들이 한번에 DB에 날아간다.&lt;/li&gt;
      &lt;li&gt;개발자가 일일이 변경이 발생할 때 이에 해당하는 코드를 넣어주지 않아도 되기 때문에 굉장히 편리하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;플러시&quot;&gt;&lt;em&gt;플러시&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;플러시는 영속성 컨텍스트를 DB와 동기화하는 작업이다. 플러시가 발생하면 변경 감지가 일어나고 수정된 엔티티의 update 내용이 쓰기 지연 SQL에 등록된다. 그리고 쓰기 지연 SQL 저장소의 query를 데이터베이스에 전송한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;플러시가-호출되는-상황&quot;&gt;플러시가 호출되는 상황&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;em.flush()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트랜젝션 커밋&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JPQL 쿼리 실행&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;영속성 컨텍스트를 비우지 않는다.&lt;/li&gt;
  &lt;li&gt;영속성 컨텍스트의 변경내용을 데이터베이스에 동기화한다.&lt;/li&gt;
  &lt;li&gt;트랜잭션 커밋 직전까지만 동기화가 되면 OK&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-commit과-flush의-차이는-무엇일까&quot;&gt;그렇다면 Commit과 flush의 차이는 무엇일까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;플러시는 DB에 query를 전송한느 역할을 수행하고 커밋은 내부적으로 플러시를 호출한 후 트랜잭션을 끝내는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;플러시로 전송된 query는 rollback이 가능하지만 commit을 호출하면 트랜잭션이 끝나기 때문에 rollback이 불가능하다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://code-lab1.tistory.com/290&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://small-stap.tistory.com/74&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://velog.io/@tomato2532/JPA-JPA-Entity-2-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8Persistence-Context&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] Intro</title><link href="http://localhost:4000/jpa/JPA1/" rel="alternate" type="text/html" title="[JPA] Intro" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA1</id><content type="html" xml:base="http://localhost:4000/jpa/JPA1/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA에 대해서 한번 정리해보자!&lt;/p&gt;

&lt;p&gt;본 포스팅은 Inflearn &lt;strong&gt;김영한님&lt;/strong&gt;의 강의를 바탕으로 작성했다.&lt;/p&gt;

&lt;p&gt;(Spring 관련 포스팅은 전부 김영한님 강의를 바탕으로 작성됨.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;orm&quot;&gt;&lt;em&gt;ORM&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORM&lt;/code&gt; (Object-relational mapping)은 객체와 DB 테이블이 매핑을 이루는 것을 말한다. 즉 &lt;strong&gt;객체가 테이블이 되도록 매핑 시켜주는 것&lt;/strong&gt; 을 의미한다.&lt;/p&gt;

&lt;p&gt;객체와 관계형 데이터베이스 사이의 패러다임의 불일치를 해소해주고 객체는 객체대로 설계하고 관계형 데이터베이스는 관계형 데이터베이스대로 설계할 수 있게 도와준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa&quot;&gt;&lt;em&gt;JPA&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;정의와-역할&quot;&gt;정의와 역할&lt;/h2&gt;

&lt;p&gt;그렇다면 JPA는 무엇인가? &lt;strong&gt;JPA란 자바 ORM 기술에 대한 API 표준 명세&lt;/strong&gt;이다. JPA는 ORM을 사용하기 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터페이스&lt;/code&gt; 를 모아둔 것이고, JPA를 사용하기 위해서 구현한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hibernate&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataNucleus&lt;/code&gt; 같은 ORM 프레임워크를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Item&lt;/code&gt;이라는 테이블의 데이터를 얻어오기 위해서는 &lt;strong&gt;SELECT * FROM Item&lt;/strong&gt; 이라는 query를 실행해야 하지만 ORM을 사용하면 &lt;strong&gt;Item.findAll()&lt;/strong&gt; 이라는 메서드를 통해서 데이터를 가져올 수 있다.&lt;/p&gt;

&lt;p&gt;query를 직접 작성하지 않아도 돼서 생산성이 높아진다. 대신 복잡한 query를 ORM으로 표현하기는 한계가 있고 성능도 raw query에 비해서 떨어지는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa는-어디서-동작할까&quot;&gt;JPA는 어디서 동작할까?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24_3.png&quot; alt=&quot;img3&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션에서 CRUD를 수행하면 JPA가 해당하는 SQL을 생성해주고 JDBC API를 사용해서 객체와 DB사이의 패러다임의 불일치를 해결해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa의-장점&quot;&gt;JPA의 장점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체 중심으로 개발&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;기존에는 SQL에 종속적인 개발을 했어야 했다. 그런데 JPA를 사용하면 객체 중심으로 개발을 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지보수&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;객체의 필드를 변경하면 개발자가 하나하나 해당 SQL을 수정했어야 했다. 그런데 이런 매핑과정을 JPA가 대신 해줌으로써 유지보수가 편리해졌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패러다임의 불일치 해결&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;기존에는 상속관계가 있는 객체를 DB에 넣을 때 굉장히 귀찮은 작업이 많았다. 그런데 JPA를 사용하면 알아서 필요한 SQL을 다 만들어서 넣어준다&lt;/li&gt;
      &lt;li&gt;자유로운 객체 그래프 탐색이 가능해졌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;성능&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;같은 트랜젝션 안에서 같은 엔티티를 반환한다. 이것이 가능한 이유는 조회를 한 후에 영속성 컨텍스트에 캐싱해두기 때문이다. DB에 query를 추가로 날리지 않기 때문에 약간의 성능 향상이 있다.&lt;/li&gt;
      &lt;li&gt;persist를 할때마다 DB에 쿼리를 날리지 않고 트랜젝션 커밋시점에 한번에 SQL을 날린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연로딩&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;객체가 실제로 사용되는 시점에 로딩을 한다.&lt;/li&gt;
      &lt;li&gt;사용되지 않는 것들은 프록시로 들고 있는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;즉시로딩&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Join을 통해서 연관된 객체를 한번에 가져온다.&lt;/li&gt;
      &lt;li&gt;항상 같이 사용되는 객체같은 경우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch join&lt;/code&gt;을 통해서 한번에 조회하는 것이 성능상으로 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;다음-포스팅부터는-jpa의-작동-원리와-사용-방법에-대해서-알아보겠다-&quot;&gt;다음 포스팅부터는 JPA의 작동 원리와 사용 방법에 대해서 알아보겠다. :)&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;p&gt;https://victorydntmd.tistory.com/195&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry></feed>