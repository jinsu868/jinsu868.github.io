<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-01T21:56:07+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[DevOps] CI/CD &amp;amp; 무중단 배포</title><link href="http://localhost:4000/devops/48/" rel="alternate" type="text/html" title="[DevOps] CI/CD &amp;amp; 무중단 배포" /><published>2023-11-25T00:00:00+09:00</published><updated>2023-11-25T00:00:00+09:00</updated><id>http://localhost:4000/devops/48</id><content type="html" xml:base="http://localhost:4000/devops/48/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;devops&quot;&gt;&lt;em&gt;DevOps&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_8.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Development&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;개발과 운영을 결합시켜 만든 개발 방법론을 의미한다.&lt;/p&gt;

&lt;p&gt;소프트웨어 개발과 운영을 통합하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;효율성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;협력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속도&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정성&lt;/code&gt;을 개선하는 개발 및 운영 방법론이다.&lt;/p&gt;

&lt;h2 id=&quot;장점&quot;&gt;&lt;em&gt;장점&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;속도&lt;/strong&gt;&lt;br /&gt;
애플리케이션 개발 단계를 자동화하여 애플리케이션을 더 짧은 주기로 고객에게 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;신속한 제공&lt;/strong&gt;&lt;br /&gt;
릴리스 빈도와 속도를 개선하여 제품을 더 빠르게 개선할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안정성&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;와 같은 방식을 사용하여 각 변경 사항이 제대로 작동하고 안전한지 테스트를 할 수 있다.&lt;br /&gt;
모니터링과 로깅을 통해 실시간으로 성능에 대한 정보를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확장&lt;/strong&gt;&lt;br /&gt;
자동화와 일관성이 지원되기 때문에 위험을 줄이면서 복합한 시스템을 효율적으로 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;협업 강화&lt;/strong&gt;&lt;br /&gt;
개발자와 운영팀이 긴밀하게 협력하고 많은 책임을 공유한다.&lt;br /&gt;
이를 통해서 비효율성을 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;br /&gt;
자동화된 규정 준수 정책, 세분화된 제어 및 구성 관리 기술을 사용하여 보안을 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;→ 애플리케이션 개발, 배포 단계를 자동화하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD (Continuous Integration/Continuous Delivery)&lt;/code&gt;라고 하는데 이에 대해서 자세히 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cicd&quot;&gt;&lt;em&gt;CI/CD&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI&lt;/code&gt; 는 개발자를 위한 자동화 프로세스인 지속적인 통합을 의미하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt;는 지속적인 서비스 제공(Continuous Delivery) 및 지속적인 배포(Continuous Deployment)를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 각각에 대해서 알아보자.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;ci-continuous-integration&quot;&gt;CI (Continuous Integration)&lt;/h2&gt;

&lt;p&gt;CI는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 통합&lt;/code&gt;을 의미하는데 간단하게 &lt;strong&gt;빌드와 테스트를 자동화&lt;/strong&gt;하는 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;필요성&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;CI가 없을 때는 여러 개발자가 수정한 변경 사항을 한번에 모아서 Merge를 했었는데 이때 만약 에러가 발생하면 어느 곳에서 에러가 발생한지 디버깅 하는 것이 굉장히 어려웠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ CI를 성공적으로 구축하게 되면 코드를 변경할 때마다 바로 빌드 및 테스트가 진행되기 때문에 위와 같은 문제가 발생하지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;과정&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;개발자가 코드를 수정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI tool&lt;/code&gt;에 병합을 요청한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI tool&lt;/code&gt;에서 변경된 코드를 빌드하고 테스트를 수행한다.&lt;/li&gt;
  &lt;li&gt;문제가 없다면 코드를 병합한다.&lt;/li&gt;
  &lt;li&gt;만약 테스트가 실패하면 바로 개발자에게 피드백을 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cd-continuous-deliverydeployment&quot;&gt;CD (Continuous Delivery/Deployment)&lt;/h2&gt;

&lt;p&gt;CD는 &lt;strong&gt;배포를 자동화하는 과정&lt;/strong&gt;이라고 생각하면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 제공(Continuous Delivery)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 배포(Continuous Deployment)&lt;/code&gt;를 의미하며 이 두 용어는 상호 교환적으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;이 두가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 의미하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;필요성-1&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;하나의 서버만 운영한다면 직접 이 서버에 들어가서 배포를 진행하면 된다.&lt;/p&gt;

&lt;p&gt;그런데 서버가 여러대가 있다면?&lt;/p&gt;

&lt;p&gt;하나 하나 서버에 들어가서 수동으로 스크립트를 실행하여 배포해야 한다. 이는 굉장히 비효율적이다.&lt;/p&gt;

&lt;p&gt;→ CD를 구축하게 되면 모든 서버에 자동으로 배포할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-delivery&quot;&gt;Continuous Delivery&lt;/h3&gt;

&lt;p&gt;애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드되는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;리포지토리에 올라온 것을 개발자나 운영팀에서 직접 검증하고 애플리케이션을 실시간으로 프로덕션 환경에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수동&lt;/code&gt; 배포한다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-deployment&quot;&gt;Continuous Deployment&lt;/h3&gt;

&lt;p&gt;개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자동&lt;/code&gt;으로 릴리스하는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 제공(Continuous Delivery)&lt;/code&gt;과의 차이점은 개발자, 운영팀에서 리포지토리에 올라온 릴리스를 확인하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자동&lt;/code&gt;으로 배포까지 수행한다는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;cicd를-위한-대표적인-도구&quot;&gt;CI/CD를 위한 대표적인 도구&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gihub Actions&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circleci&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GitLab CI/CD&lt;/code&gt;등이 있다.&lt;br /&gt;
이 중에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;를 가장 많이 사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;무중단-배포&quot;&gt;&lt;em&gt;무중단 배포&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;다운타임-downtime&quot;&gt;다운타임 (DownTime)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;한대의 서버를 사용하여 서비스를 운영한다고 생각해보자. V1이 실행되고 있는 상황에서 새로운 기능이 추가된 V2가 개발이 완료됐다. 사용자에게 새로운 기능을 제공하기 위해서는 V2를 배포해야 한다.&lt;/p&gt;

&lt;p&gt;하지만 서버를 한대로 운영하고 있기 때문에 V2를 실행하기 위해서는 V1을 종료하고 V2를 실행해야 한다.&lt;/p&gt;

&lt;p&gt;V1을 종료하고 V2를 실행하는 동안에 사용자는 서비스를 이용할 수 없다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다운타임(downTime)&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다운타임&lt;/code&gt; 없이 새로운 기능을 추가하기 위한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무중단 배포&lt;/code&gt;라고 한다. 이를 위해서는 최소한 2대의 서버가 있어야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리버스-프록시-reverse-proxy&quot;&gt;리버스 프록시 (Reverse Proxy)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무중단 배포&lt;/code&gt;를 이해하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리버스 프록시&lt;/code&gt;에 대해서 알아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리버스 프록시&lt;/code&gt;란 클라이언트와 웹 서버 간의 중개자 역할을 하는 서버이다.&lt;/p&gt;

&lt;p&gt;서버 대신에 클라이언트의 요청을 대신 받아서 웹 서버로 전달하고, 웹 서버의 응답을 클라이언트에게 전달하는 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;이를 통해서 &lt;strong&gt;웹 서버의 부하를 분산&lt;/strong&gt;시키고, &lt;strong&gt;보안을 강화&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;로드 밸런싱&lt;/strong&gt;&lt;br /&gt;
웹 서버에 동시에 많은 트래픽이 몰릴 때, 서버에 부하가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;리버스 프록시를 사용하면 클라이언트의 요청을 여러 대의 서버로 분산시켜 각 서버의 부하를 줄이고, 서버의 가용성을 높여 안정적으로 서비스를 운영할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;&lt;br /&gt;
리버스 프록시를 사용하면 외부에서 서버로 바로 접근하지 못하게 된다.&lt;/p&gt;

&lt;p&gt;서버와 클라이언트 사이에서 악성 요청을 필터링하거나, 접근 제한과 같은 역할을 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;캐싱 및 가속화&lt;/strong&gt;&lt;br /&gt;
자주 사용되는 정적 파일(CSS, JS)를 캐시에 저장하여 빠르게 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;이로 인해 서버의 부하를 줄이고 응답 시간을 단축시킬 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추가적인 서버 설정 비용&lt;/strong&gt;&lt;br /&gt;
리버스 프록시를 사용하기 위해서는 추가적인 서버 설정과 관리가 요구된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;네트워크 지연&lt;/strong&gt;&lt;br /&gt;
중간 다리(리버스 프록시)를 거치기 때문에 약간의 네트워크 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;복잡성 증가&lt;/strong&gt;&lt;br /&gt;
아키텍처가 복잡해질 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ 리버스 프록시의 장단점은 사실 프록시 패턴의 장단점과 동일하다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;로드-밸런싱&quot;&gt;&lt;em&gt;로드 밸런싱&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;정의-1&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;컴퓨터 네트워크 기술의 일종으로 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 &lt;strong&gt;컴퓨터 자원들에게 작업, 즉 부하를 나누는 것&lt;/strong&gt;을 의미한다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;필요성-2&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;서비스 런칭 단계에서는 고객이 거의 없기 때문에 서버 한대로도 모든 요청을 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 점점 고객의 수가 늘어나고 서비스가 확장되면 서버 한대로는 모든 요청을 처리할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;증가하는 트래픽을 대처하기 위해서 사용할 수 있는 방법은 크게 2가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scale-up&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scale-out&lt;/code&gt; 이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Scale up&lt;/strong&gt; : 서버 자체의 성능을 향상하는 방법으로 비용이 상대적으로 많이 든다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Scale out&lt;/strong&gt; : 서버를 증설하는 방법이다. 이 방법을 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;로드밸런싱&lt;/code&gt;이 필수로 요구된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;L4 로드밸런싱&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송 계층&lt;/code&gt;에서 로드(트래픽)을 분산시킨다.&lt;br /&gt;
IP주소나 포트번호, MAC주소 등에 따라 트래픽을 나누고 분선처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L7 로드밸런싱&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션 계층&lt;/code&gt;에서 로드를 분산시킨다.&lt;br /&gt;
HTTP, SMTP, FTP 등을 바탕으로 로드를 분산 처리할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;로드밸런싱-알고리즘&quot;&gt;로드밸런싱 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;라운드로빈-방식&quot;&gt;라운드로빈 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;단순히 서버로 요청이 들어온 순서를 바탕으로 처리하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트의 요청 순서에 따라 처리되기 때문에 여러 대의 서버가 동일한 스펙을 가지고 있고, 서버와의 연결이 오래 지속되지 않을 때 사용하면 좋다.&lt;/p&gt;

&lt;h3 id=&quot;가중-라운드로빈-방식&quot;&gt;가중 라운드로빈 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버마다 가중치를 설정하고 가중치가 높은 서버에 클라이언트의 요청을 우선적으로 배분하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 서버의 트래픽 처리 능력이 다를 때 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;ip-해시-방식&quot;&gt;IP 해시 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트의  IP 주소를 바탕으로 해시함수를 돌려서 항상 동일한 서버에 도달하게 만드는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트는 항상 동일한 서버로부터 서비스를 받을 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;최소-연결-방식&quot;&gt;최소 연결 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트 요청이 들어올 때를 기준으로 가장 트래픽이 적은 서버로 연결하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서버에 분산된 트래픽이 일정하지 않을 때 적합하다.&lt;/p&gt;

&lt;h3 id=&quot;최소-리스폰타임&quot;&gt;최소 리스폰타임&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버의 연결 상태와 응답 시간을 모두 고려하여 트래픽을 분산하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;무중단-배포-방식&quot;&gt;&lt;em&gt;무중단 배포 방식&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;롤링rolling-배포&quot;&gt;롤링(Rolling) 배포&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ 여기서의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nginx&lt;/code&gt;는 로드밸런서 역할을 하는 리버스 프록시라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;롤링 배포 방식은 사용중인 인스턴스 내에서 새로운 버전을 점진적으로 교체해 나가는 방식으로 무중단 배포의 가장 기본적인 방법이다.&lt;/p&gt;

&lt;p&gt;위에서부터 차례대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버3&lt;/code&gt;이라고 해보자.&lt;/p&gt;

&lt;h3 id=&quot;과정-1&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;로드밸런서(Nginx)에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;로 라우팅되지 않게 설정한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;에 새로운 버전을 배포한다.&lt;/li&gt;
  &lt;li&gt;로드밸런서에서 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;로 라우팅될 수 있도록 변경한다.&lt;/li&gt;
  &lt;li&gt;이 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버3&lt;/code&gt;에 점진적으로 적용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;장점-2&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;차례대로 배포를 진행하기 때문에 상황에 따라서 롤백이 어렵지 않다.&lt;/p&gt;

&lt;p&gt;추가적인 인스턴스를 늘리지 않아도 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;새로운 버전을 배포할 때마다 처리할 수 있는 서버가 줄어들기 때문에 트래픽이 몰릴 수 있다.&lt;/p&gt;

&lt;p&gt;배포가 진행될 때 구버전과 신버전이 동시에 존재하기 때문에 &lt;strong&gt;호환성 문제&lt;/strong&gt;가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;blue-green-배포-방식&quot;&gt;Blue Green 배포 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블루&lt;/code&gt;는 구버전을, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그린&lt;/code&gt;은 신버전을 의미한다.&lt;/p&gt;

&lt;p&gt;운영중인 구버전과 동일하게 신버전 인스턴스를 구성하고 로드밸런서를 사용하여 모든 트래픽을 한번에 신버전으로 전환하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;장점-3&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;구버전의 인스턴스가 그대로 남아있기 때문에 롤백이 쉽다.&lt;/p&gt;

&lt;p&gt;한번에 라우팅을 변경하기 때문에 배포하는 속도가 빠르다.&lt;/p&gt;

&lt;p&gt;구버전 환경을 다음 배포에 재사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점-2&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;구버전과 신버전을 가지고 있어야 하기 때문에 시스템 자원이 2배로 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;카나리-배포-방식&quot;&gt;카나리 배포 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;과정-2&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;신버전을 소수의 유저들에게 배포하고 문제가 없는지 확인한다.&lt;/li&gt;
  &lt;li&gt;만약 문제가 없다면 점차 많은 유저에게 배포한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블루 그린 방식&lt;/code&gt;과 유사하지만 트래픽을 한번에 바꾸는 것이 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단계적으로 바꾸는 것&lt;/code&gt;이 차이점이다.&lt;/p&gt;

&lt;h3 id=&quot;장점-4&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;성능 모니터링에 유용하다.&lt;/p&gt;

&lt;p&gt;A/B 테스트로 활용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A/B 테스트란?
    &lt;blockquote&gt;
      &lt;p&gt;A/B 테스팅이란 웹 사이트 방문자를 임의로 두 집단으로 나누고, 한 집단에게는 기존 사이트를 보여주고 다른 집단에게는 새로운 사이트를 보여준 다음, 두 집단 중 어떤 집단이 더 높은 성과를 보이는지 측정하여, 새 사이트가 기존 사이트에 비해 좋은지를 정량적으로 평가하는 방식을 말한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점-3&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;네트워크 트래픽을 제어하는 부담이 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://aws.amazon.com/ko/devops/what-is-devops/&lt;/li&gt;
  &lt;li&gt;https://www.redhat.com/ko/topics/devops&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@lee2302/Deploy-CICD%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%B0%ED%8F%AC&quot;&gt;https://velog.io/@lee2302/Deploy-CICD자동화-배포&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;https://seosh817.tistory.com/104&lt;/li&gt;
  &lt;li&gt;https://hudi.blog/zero-downtime-deployment/&lt;/li&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=sIPU_VkrguI&lt;/li&gt;
  &lt;li&gt;https://narup.tistory.com/238&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aday7.tistory.com/entry/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9CReverse-Proxy-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%ED%95%84%EC%9A%94%EC%84%B1-%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EC%86%94%EB%A3%A8%EC%85%98%EA%B9%8C%EC%A7%80&quot;&gt;https://aday7.tistory.com/entry/리버스-프록시Reverse-Proxy-쉽게-이해하기-개념부터-필요성-오픈-소스-솔루션까지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@yanghl98/OS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-Load-Balancing-%EC%A0%95%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98&quot;&gt;https://velog.io/@yanghl98/OS운영체제-로드밸런싱-Load-Balancing-정의-종류-알고리즘&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;https://bruno-jang.tistory.com/34&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="DevOps" /><category term="DevOps" /><category term="CI/CD" /><category term="리버스 프록시" /><category term="무중단 배포" /><summary type="html"></summary></entry><entry><title type="html">[DB] 트랜잭션</title><link href="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/47/" rel="alternate" type="text/html" title="[DB] 트랜잭션" /><published>2023-11-20T00:00:00+09:00</published><updated>2023-11-20T00:00:00+09:00</updated><id>http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/47</id><content type="html" xml:base="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/47/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 의미한다.&lt;/p&gt;

&lt;p&gt;여러 쿼리를 하나로 묶는 단위를 말한다.&lt;/p&gt;

&lt;h2 id=&quot;속성&quot;&gt;속성&lt;/h2&gt;

&lt;h3 id=&quot;원자성atomicity&quot;&gt;원자성(Atomicity)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;원자성은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;All or Nothing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;중간에 취소된 경우에 완전히 처음 상태로 돌아가는 것을 보장한다.&lt;/p&gt;

&lt;h4 id=&quot;commit-rollback&quot;&gt;Commit, Rollback&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Commit&lt;/code&gt; : 트랜잭션 단위로 수행되며 변경된 모든 내용이 영구적으로 저장되는 것을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rollback&lt;/code&gt; : 트랜젝션으로 처리한 하나의 과정을 일어나기 전의 상태로 돌리는 것을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일관성consistency&quot;&gt;일관성(Consistency)&lt;/h3&gt;

&lt;p&gt;허용된 방식으로만 데이터를 변경할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;내가 500원이 있는데 1000원을 전송할 수 있으면 X&lt;/p&gt;

&lt;h3 id=&quot;격리성isolation&quot;&gt;격리성(Isolation)&lt;/h3&gt;

&lt;p&gt;격리성이란 트랜잭션 수행 시에 서로 끼어들지 못하는 정도를 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/47_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;격리-수준-isolation-level&quot;&gt;격리 수준 (Isolation Level)&lt;/h4&gt;

&lt;h5 id=&quot;read-uncommited&quot;&gt;READ UNCOMMITED&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션에서 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;가장 낮은 수준의 격리성을 보장하지만 성능이 좋다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반복 가능하지 않은 조회&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;더티 리드&lt;/code&gt;가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터베이스의 일관성을 유지할 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;read_commited&quot;&gt;READ_COMMITED&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;커밋이 완료된 데이터에 대해서만 조회가 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반복 가능하지 않은 조회&lt;/code&gt;가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;대부분의 SQL 서버가 기본으로 사용하는 Isolation Level 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;repeatable_read&quot;&gt;REPEATABLE_READ&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정하지 못하도록 한다.&lt;/li&gt;
  &lt;li&gt;새로운 행을 추가하는 것은 막지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션을 순차적으로 진행시키는 것을 말한다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;교착상태가 발생할 확률이 높고 가장 성능이 떨어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가장 높은 수준의 격리성을 보장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;격리성으로-인해-발생할-수-있는-문제&quot;&gt;격리성으로 인해 발생할 수 있는 문제&lt;/h4&gt;

&lt;h5 id=&quot;팬텀-리드-phantom-read&quot;&gt;팬텀 리드 (Phantom Read)&lt;/h5&gt;

&lt;p&gt;한 트랜잭션 내에서 동일한 쿼리를 했을 때, 해당 조회 결과가 다른 경우&lt;/p&gt;

&lt;h5 id=&quot;반복-가능하지-않은-조회-non-repeatable-read&quot;&gt;반복 가능하지 않은 조회 (Non-Repeatable Read)&lt;/h5&gt;

&lt;p&gt;한 트랜잭션 내의 같은 행에 대해서 두 번 이상의 조회가 발생할 때, 그 값이 다른 경우&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;의 경우 조회 결과 다른 행이 선택될 수 있는 것이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반복 가능하지 않은 조회&lt;/code&gt;는 동일한 행을 조회할 때 다른 값으로 조회될 수 있는 것을 말한다.&lt;/p&gt;

&lt;h5 id=&quot;더티-리드-dirty-read&quot;&gt;더티 리드 (Dirty Read)&lt;/h5&gt;

&lt;p&gt;한 트랜잭션이 실행중일 때 다른 트랜잭션에 의해 값이 수정됐는데 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;영구성durability&quot;&gt;영구성(Durability)&lt;/h3&gt;

&lt;p&gt;성공적으로 수행된 트랜잭션은 영원히 반영돼야 한다.&lt;br /&gt;
데이터베이스 시스템에 장애가 발생해도 원래 상태로 복구가 가능해야 함을 뜻하며 체크섬, 저널링, 롤백 등의 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;https://velog.io/@yu-jin-song/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80Transaction-Isolation-Level&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="데이터베이스" /><category term="트랜잭션" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[DB] 이상현상과 정규화</title><link href="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/46/" rel="alternate" type="text/html" title="[DB] 이상현상과 정규화" /><published>2023-11-19T00:00:00+09:00</published><updated>2023-11-19T00:00:00+09:00</updated><id>http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/46</id><content type="html" xml:base="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/46/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;이상현상-anomaly&quot;&gt;이상현상 (Anomaly)&lt;/h1&gt;

&lt;h2 id=&quot;삽입이상&quot;&gt;삽입이상&lt;/h2&gt;

&lt;p&gt;불필요한 데이터를 추가해야지만 삽입이 가능한 상황&lt;/p&gt;

&lt;h2 id=&quot;갱신이상&quot;&gt;갱신이상&lt;/h2&gt;

&lt;p&gt;같아야 하는 정보가 복수 개의 행에 표현될 경우, 데이터를 수정할 때 일부 정보만 갱신되고 일부는 변하지 않아 데이터 오류가 발생하는 현상&lt;/p&gt;

&lt;h2 id=&quot;삭제이상&quot;&gt;삭제이상&lt;/h2&gt;

&lt;p&gt;의도하지 않은 데이터까지 삭제해야만 지우고자 하는 데이터를 지울 수 있는 현상&lt;/p&gt;

&lt;p&gt;→ &lt;strong&gt;이러한 이상 현상들을 없애기 위해서 정규화를 수행한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;정규화&quot;&gt;정규화&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터의 일관성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소한의 중복&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최대한의 데이터 유연성&lt;/code&gt;을 위한 방법으로, 데이터를 분해하는 과정을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 1~5 정규화가 있으며, 제3정규화까지만 수행한다.&lt;/p&gt;

&lt;h2 id=&quot;함수-종속성&quot;&gt;함수 종속성&lt;/h2&gt;

&lt;p&gt;X, Y가 있고 X가 변할 때, Y도 같이 변한다면 Y는 X에 함수적으로 종속된다고 표현한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;X→Y이면 Y는 X에 함수적으로 종속&lt;/li&gt;
  &lt;li&gt;X : 결정자, Y : 종속자&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;h4 id=&quot;완전-함수-종속&quot;&gt;완전 함수 종속&lt;/h4&gt;

&lt;p&gt;종속자가 기본키에만 종속되고, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에  종속된 경우&lt;/p&gt;

&lt;h4 id=&quot;부분-함수적-종속&quot;&gt;부분 함수적 종속&lt;/h4&gt;

&lt;p&gt;릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부에만 종속된 경우&lt;/p&gt;

&lt;h4 id=&quot;이행적-함수-종속&quot;&gt;이행적 함수 종속&lt;/h4&gt;

&lt;p&gt;릴레이션에서 X, Y, Z라는 3개의 속성이 있을 때, X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때 이행적 함수 종속이라고 한다.&lt;/p&gt;

&lt;p&gt;X를 알면 Y를 알고, Y를 알면 Z를 알 수 있는 경우&lt;/p&gt;

&lt;h3 id=&quot;정규화-종류&quot;&gt;정규화 종류&lt;/h3&gt;

&lt;h4 id=&quot;제1-정규화&quot;&gt;제1 정규화&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속성의 원자성&lt;/code&gt;을 만족시키도록 비정규형 테이블을 제1 정규형 테이블로 구조화하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;릴레이션의 속성 값 중에서 한 개의 기본키에 대해서 두 개 이상의 값을 가지는 반복집합을 제거한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 테이블를 보면 A가 좋아하는 음식이 2개이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ 위 테이블과 같이 반복집합이 제거된 테이블을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제1 정규형&lt;/code&gt;이라고 한다. 그리고 이러한 정규화 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제1 정규화&lt;/code&gt; 라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;제2-정규화&quot;&gt;제2 정규화&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 함수 종속성&lt;/code&gt;을 제거하는 과정을 말한다.&lt;/li&gt;
  &lt;li&gt;부분 함수 종속성은 기본키가 2개 이상의 Column 으로 구성되는 경우에만 발생한다.
    &lt;ul&gt;
      &lt;li&gt;기본키가 1개의 Column 으로 구성된다면 제2 정규화는 건너뛴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 테이블의 기본키가 회원ID와 은행이라고 가정하자.&lt;/p&gt;

&lt;p&gt;계좌번호는 회원ID와 은행에 종속된다. 하지만 회원 이름은 은행에 상관없이 회원ID에만 종속된다.&lt;/p&gt;

&lt;p&gt;이렇게 기본키가 2개 이상의 Column (회원ID, 은행)으로 구성될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 함수 종속성&lt;/code&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;테이블 분리를 통해서 이를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;회원ID, 이름을 속성으로 가지는 새로운 테이블을 도출했다. 이렇게 테이블 분리를 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제2 정규형&lt;/code&gt;을 구성하는 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제2 정규화&lt;/code&gt;라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;제3-정규화&quot;&gt;제3 정규화&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행적 함수 종속&lt;/code&gt;을 제거하는 과정을 말한다.&lt;/li&gt;
  &lt;li&gt;기본키가 아닌 Column 이 다른 Column을 결정하는 결정할 수 없도록 한다.&lt;/li&gt;
  &lt;li&gt;제3 정규화는 제1, 2 정규화를 마친 제2 정규형에 대해서 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 테이블에서 회원ID와 계좌번호가 기본키라고 가정하자. 그런데 관리점 Column 을 보면 기본키에 종속되는 것이 아니라 관리점 코드에 종속되는 것을 볼 수 있다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행 함수 종속&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;관리점 코드를 기본키로 하는 새로운 테이블을 도출하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행 함수 종속성&lt;/code&gt;을 제거할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 2개의 테이블로 분리하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행 함수 종속&lt;/code&gt;을 제거하였다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;반정규화&quot;&gt;반정규화&lt;/h1&gt;

&lt;p&gt;성능 향상을 위해서 데이터의 중복을 허용하고, 조인 연산을 줄여 데이터베이스 성능 향상을 하는 방법&lt;/p&gt;

&lt;h2 id=&quot;정규화의-단점&quot;&gt;정규화의 단점&lt;/h2&gt;

&lt;p&gt;정규화된 데이터를 조회할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join&lt;/code&gt;이 많이 발생하기 때문에 CPU와 메모리를 많이 사용하고 성능도 떨어진다. 이러한 성능 문제를 해결하기 위해서 반정규화를 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;정규화↔반정규화 사이에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trade off&lt;/code&gt;가 있다.&lt;/p&gt;

&lt;p&gt;정규화를 수행하면 데이터의 중복이 줄고 데이터 모델의 유연성이 높아지지만 반대로 성능이 내려간다.&lt;/p&gt;

&lt;p&gt;반정규화를 수행하면 성능은 좋아지지만 유연성이 떨어지고 데이터의 중복이 많아져서 관리하기 어렵다.&lt;/p&gt;

&lt;h2 id=&quot;반정규화를-수행하는-경우&quot;&gt;반정규화를 수행하는 경우&lt;/h2&gt;

&lt;p&gt;특정 범위의 데이터만 자주 조회하는 경우&lt;/p&gt;

&lt;p&gt;요약/집계 정보가 자주 요구되는 경우&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="데이터베이스" /><category term="정규화" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[테스트] 다양한 테스트 방법</title><link href="http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/45/" rel="alternate" type="text/html" title="[테스트] 다양한 테스트 방법" /><published>2023-11-07T00:00:00+09:00</published><updated>2023-11-07T00:00:00+09:00</updated><id>http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/45</id><content type="html" xml:base="http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/45/">&lt;h2 id=&quot;동기&quot;&gt;동기&lt;/h2&gt;

&lt;p&gt;2주차 미션 피드백을 읽으면서 유용한 테스트 방법이 있어서 소개하고자 한다. &lt;br /&gt;
바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;이다. 바로 사용 방법을 알아보자! 
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;parameterizedtest&quot;&gt;ParameterizedTest&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ParameterizedTest&lt;/code&gt;를 사용하면 여러 개의 파라미터에 대한 테스트를 하나에 테스트 메소드로 처리할 수 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Test&lt;/code&gt;만을 사용했을 때와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ParameterizedTest&lt;/code&gt;를 사용했을 때의 차이점을 코드로 확인해보자! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;기존의-테스트&quot;&gt;기존의 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;를 사용하지 않으면 테스트하고 싶은 매개변수가 있을 때마다 테스트 메소드를 작성해야 한다. &lt;br /&gt;
코드를 보면 알 수 있다싶이 중복되는 부분이 많고 테스트 케이스마다 메소드를 작성해야 하기 때문에 관리하기 어렵다. &lt;br /&gt;
그렇다면 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;를 사용한 코드를 보자 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;parameterizedtest를-사용한-테스트&quot;&gt;ParameterizedTest를 사용한 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 코드를 실행하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test3&lt;/code&gt;가 총 5번 호출되며 실행할 때, 5, 4, 3, 2, 1이 순서대로 들어간다. &lt;br /&gt;
여러 경우에 대한 테스트를 단 하나의 메소드로 처리할 수 있는 것이다! &lt;br /&gt;
아마 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ValueSoource&lt;/code&gt;가 무엇인지 궁금할 것이다! 이는 파라미터에 값을 넣는 에노테이션으로 이제부터 설명하겠다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;argument-sources&quot;&gt;Argument sources&lt;/h2&gt;

&lt;p&gt;앞서 봤듯이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;는 서로 다른 인수를 사용하여 동일한 테스트를 여러 번 실행시킨다. &lt;br /&gt;
그런데 단순한 인수만 넣을 수 있다면 조금만 복잡한 값이 들어오더라도 테스트할 수 없을 것이다.&lt;br /&gt;
이제부터 여러가지 인수를 넣는 방법에 대해서 살펴보자!&lt;/p&gt;

&lt;h3 id=&quot;valuesource&quot;&gt;@ValueSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ValueSource&lt;/code&gt;를 사용하면 단순한 리터럴 값 배열을 테스트 메서드에 전달할 수 있게된다.&lt;br /&gt; 
사용법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ValueSource&lt;/code&gt;안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shorts&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strings&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ints&lt;/code&gt;와 같이 타입을 적어주고 뒤에 값을 넣어주면 된다.&lt;br /&gt;
코드 예시를 보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_4.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;test3은 총 3번 실행되며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;에 순서대로 “aaa”, “bbb”, “ccc” 값이 들어간다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Test&lt;/code&gt;만 사용한다면 총 3번개의 테스트 메소드를 작성해야 하는데 하나의 메소드로 처리한 것을 볼 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;넘겨줄-수-있는-자료형은-다음과-같다&quot;&gt;넘겨줄 수 있는 자료형은 다음과 같다!&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/45_3.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nullsource&quot;&gt;@NullSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@NullSource&lt;/code&gt;는 파라미터 값으로 null을 넣어준다. &lt;br /&gt;
바로 예시를 보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_5.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_6.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과를 보면 알 수 있듯이 data에 null이 들어간 것을 확인할 수 있다 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;emptysource&quot;&gt;@EmptySource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EmptySource&lt;/code&gt;도 이름 그대로 빈 값을 파라미터에 주입해준다. &lt;br /&gt;
코드로 바로 확인해보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_7.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_8.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;data에 empty값이 들어간 것을 확인할 수 있다! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;enumsource&quot;&gt;@EnumSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnumSource&lt;/code&gt;도 느낌이 오지 않는가? 그냥 Enum을 넣어준다 ㅎㅎ.. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_9.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_10.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 잘 통과하는 것을 확인할 수 있다 &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;methodsource&quot;&gt;@MethodSource&lt;/h3&gt;

&lt;p&gt;지금까지 살펴본 테스트들은 단순하고 하나의 파라미터밖에 넘기지 못한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;는 좀 더 복잡한 인수를 가지고 테스트를 제공한다. &lt;br /&gt;
바로 예시를 보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_11.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;차례대로 input, expected에 `provideStringForBlank에서 생성한 값들이 들어가는 것을 확인할 수 있다.&lt;br /&gt;
이렇게 여러 복잡한 인자를 넘겨서 테스트가 가능하다! &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;이-방식을-사용하려면-몇-가지-규칙이-있다&quot;&gt;이 방식을 사용하려면 몇 가지 규칙이 있다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;로 지정한 메소드는 반드시 &lt;strong&gt;static&lt;/strong&gt;이어야 한다.&lt;/li&gt;
  &lt;li&gt;그리고 메소드 이름과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;에 들어가는 메서드 이름이 일치해야 한다.
    &lt;ul&gt;
      &lt;li&gt;단, TestInstance를 사용하여 클래스 단위의 생성주기를 가지는 경우에 인스턴스 메소드가 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;에 메소드 이름을 작성하지 않으면 JUnit이 테스트 메소드 네임과 같은 메소드를 찾아서 인수로 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 방식을 사용하면 복잡한 인수를 자동으로 주입해서 테스트할 수 있다!! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;csvsource&quot;&gt;@CsvSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@CsvSource&lt;/code&gt;를 사용하면 인자와 테스트 값을 동시에 주입할 수 있다 &lt;br /&gt;
바로 코드로 확인해보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_12.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_13.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@CsvSource&lt;/code&gt;에 값을 넣을때는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉼표(,)&lt;/code&gt;로 구분된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delimeter&lt;/code&gt;를 따로 설정할 수도 있다! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 다양한 테스트 방법에 대해서 알아봤다.&lt;br /&gt;
테스트 코드를 작성하는 것도 서비스 로직을 작성하는 것만큼 중요하다. &lt;br /&gt;
다양한 테스트 방법에 대해서 숙지해두자! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;https://ebabby.tistory.com/21&lt;/li&gt;
  &lt;li&gt;https://www.baeldung.com/parameterized-tests-junit-5&lt;/li&gt;
  &lt;li&gt;https://velog.io/@ohzzi/junit5-parameterizedtest&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="테스트" /><category term="Junit5" /><category term="우테코" /><summary type="html">동기</summary></entry><entry><title type="html">[Network] 보안</title><link href="http://localhost:4000/network/44/" rel="alternate" type="text/html" title="[Network] 보안" /><published>2023-11-05T00:00:00+09:00</published><updated>2023-11-05T00:00:00+09:00</updated><id>http://localhost:4000/network/44</id><content type="html" xml:base="http://localhost:4000/network/44/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_15.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 지난 시간에 이어서 네트워크 보안에 대해서 정리하겠다. 본 게시글은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴퓨터 네트워킹 하향식 접근 (제8판)&lt;/code&gt;을 토대로 작성됐다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;안전한-통신&quot;&gt;안전한 통신&lt;/h1&gt;

&lt;h2 id=&quot;기밀성&quot;&gt;기밀성&lt;/h2&gt;

&lt;p&gt;송신자와 지정된 수신자만이 전송되는 메시지의 내용을 이해할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;메시지를 어떠한 방식으로든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;암호화&lt;/code&gt;해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;메시지-무결성&quot;&gt;메시지 무결성&lt;/h2&gt;

&lt;p&gt;전송중에 메시지의 내용이 변하지 않아야 한다.&lt;/p&gt;

&lt;h2 id=&quot;종단점-인증&quot;&gt;종단점 인증&lt;/h2&gt;

&lt;p&gt;송신자와 수신자는 상대방이 실제로 누구인지 신원을 확인할 수 있어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;운영-보안&quot;&gt;운영 보안&lt;/h2&gt;

&lt;p&gt;대부분의 기관은 공용 네트워크에 연결되어있기 때문에 공격에 노출될 수 있다.&lt;/p&gt;

&lt;p&gt;이를 막기 위해 기관 네트워크와 공공 네트워크 사이에 방화벽을 설치하고 드나드는 패킷을 제어할 수 있어야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;암호학&quot;&gt;암호학&lt;/h1&gt;

&lt;h2 id=&quot;암호화-구성요소&quot;&gt;암호화 구성요소&lt;/h2&gt;

&lt;h3 id=&quot;평문&quot;&gt;평문&lt;/h3&gt;

&lt;p&gt;송신자가 보내려는 원래 형태의 메시지를 &lt;strong&gt;평문&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;암호문&quot;&gt;암호문&lt;/h3&gt;

&lt;p&gt;그리고 이를 암호화 알고리즘을 사용하여 만든 메시지를 &lt;strong&gt;암호문&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;키&quot;&gt;키&lt;/h3&gt;

&lt;p&gt;이 암호화 알고리즘은 누구에게나 다 알려져 있다.&lt;/p&gt;

&lt;p&gt;때문에 전송한 데이터를 중간에서 가로채서 복원할 수 없도록 해주는 장치가 필요한데 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;키&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ 평문을 암호문으로 바꿈으로서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;을 실현한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;대칭키-시스템&quot;&gt;대칭키 시스템&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Alice가 키(A)를 이용해서 평문을 암호화해서 밥에게 보낸다.&lt;/li&gt;
  &lt;li&gt;Bob은 키(B)를 사용해서 암호문을 복호화하여 평문으로 복원한다.&lt;/li&gt;
  &lt;li&gt;키는 Alice와 Bob만 가지고 있고 있기 때문에 Trudy가 중간에서 메시지를 가로채도 평문으로 복원할 방법이 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 시나리오에서 Alice와 Bob이 동일한 키(A)를 가지고 암호화, 복호화를 한다면 이것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대칭키&lt;/code&gt;를 이용하는 방식이다.&lt;br /&gt;
여기서 키(A)는 통신하고 있는 송수신자 이외에는 알 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;공개키-시스템&quot;&gt;공개키 시스템&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;방식&quot;&gt;방식&lt;/h3&gt;

&lt;p&gt;모두에게 공개하는 키(공개키, K+)와 자기 자신만 가지는 키(개인키, K-)를 사용하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;흐름&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;송신자는 수신자의 공개키(K+)로 암호문을 생성해서 송신한다.&lt;/li&gt;
  &lt;li&gt;수신자는 자신의 개인키(K-)로 암호문을 복호화한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;/h2&gt;

&lt;p&gt;모듈러 연산의 성질을 이용한 알고리즘인데 자세한 내용은 생략한다.&lt;/p&gt;

&lt;p&gt;공개키 암호화와 거의 동의어로 사용된다.&lt;/p&gt;

&lt;p&gt;RSA는 종종 대칭키 암호화와 같이 사용되는데 이때 사용되는 키가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;세션키&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;세션키&lt;/code&gt;는 대칭키 암호화에 사용되는 키이다.&lt;/p&gt;

&lt;h3 id=&quot;흐름-1&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;송신자가 세션키를 수신자의 공개키로 암호화하고 전송한다.&lt;/li&gt;
  &lt;li&gt;수신자는 자신의 개인키로 암호문을 복호화하여 세션키를 얻는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 이를 통해 안전하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;세션키&lt;/code&gt;를 상대방에게 배포할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;블록-암호화&quot;&gt;블록 암호화&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;블록 암호화&lt;/strong&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PGP&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IPsec&lt;/code&gt; 에 자주 사용되는 방식으로서 메시지를 K비트의 블록 단위로 쪼개서 암호화한다.&lt;/p&gt;

&lt;h3 id=&quot;문제점&quot;&gt;문제점&lt;/h3&gt;

&lt;p&gt;이 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^k&lt;/code&gt; 만큼의 테이블을 유지해야 하기 때문에 K가 크다면 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;블록 암호화는 평문 블록이 동일하다면 동일한 암호문을 생성한다. 때문에 공격자가 이를 해독할 여지가 있다.&lt;/p&gt;

&lt;h3 id=&quot;cbc-cipher-block-chaning&quot;&gt;CBC (Cipher Block Chaning)&lt;/h3&gt;

&lt;p&gt;블록 암호화의 문제를 해결하기 위한 방법 중 하나로 송신자가 처음에 초기화 백터라 불리는 임의의 비트열을 생성해서 수신자에게 보낸다.&lt;/p&gt;

&lt;p&gt;수신자는 이를 이용해서 블록 C1~Cn까지 암호화를 수행한다.&lt;/p&gt;

&lt;p&gt;여기서 Cn을 암호화할 때, Cn-1의 값과 초기화 백터값이 사용된다.&lt;/p&gt;

&lt;p&gt;CBC를 사용하면 송신할때마다 초기화 백터가 다르기 때문에 같은 평문에 대해서 다른 암호문이 도출된다.&lt;/p&gt;

&lt;h2 id=&quot;메시지-무결성-1&quot;&gt;메시지 무결성&lt;/h2&gt;

&lt;h3 id=&quot;메시지-인증&quot;&gt;메시지 인증&lt;/h3&gt;

&lt;p&gt;메시지가 정말 해당 송신자로부터 온 것인가?&lt;/p&gt;

&lt;p&gt;메시지가 나한테 전달되는 과정에서 변경되지 않았는가?&lt;/p&gt;

&lt;p&gt;→ 이 두가지를 만족시켜야 한다.&lt;/p&gt;

&lt;h3 id=&quot;해시-함수&quot;&gt;해시 함수&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;해시 함수는 메시지 m을 입력값으로 받아서 고정된 크기의 문자열 H(m)을 도출한다.&lt;/li&gt;
  &lt;li&gt;메시지 m을 해시값으로 넣었을 때 생성되는 해시값 H(m)과 같은 해시값을 만들어내는 H(m`)을 찾는 것이 산술적으로 불가능(시간상)해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메시지-인증-코드-mac&quot;&gt;메시지 인증 코드 (MAC)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;단순히 해시 함수를 통해서 (m, H(m))을 생성해서 보내는 것은 누구나 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;도 보낼 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trudy&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;인척 보낼 수도 있다.
MAC 에서는 송수신자가 비밀키(s)를 공유하여 해시값을 계산할 때, 메시지에 s를 붙인다.&lt;/li&gt;
  &lt;li&gt;(m, H(m+s)) ← 송신할 때 이렇게 보낸다.&lt;/li&gt;
  &lt;li&gt;비밀키 s는 송수신자만 공유하기 때문에 중간에 공격가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trudy&lt;/code&gt;가 메시지(m)을 갈아껴서 (m’, H(m’))을 보내도 수신자는 H(m’) ≠ H(m’+s)이기 때문에 이상을 감지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;전자-서명&quot;&gt;전자 서명&lt;/h2&gt;

&lt;p&gt;문서의 소유자 또는 작성자를 명시하거나 어떤 사람이 문서 내용에 동의했다는 것을 표시할 때 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서명자를 입증&lt;/strong&gt;할 수 있어야 하고 &lt;strong&gt;위조할 수 없어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;공개키 암호화 방법이 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;흐름-2&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;자신의 개인키로 문서나 메시지 m을 암호화한다. → K-(m)&lt;/li&gt;
  &lt;li&gt;네트워크상에서 K-(m)을 받은 사람들은 송신자의 공개키 K+를 사용해서 복호화한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;송신자의 개인키(K-)를 통해서만 서명할 수 있기 때문에 위조가 불가능하다. 때문에 내가 나임을 증명할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공격자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trudy&lt;/code&gt;가 메시지를 조작해서 m`을 만들어도 수신자는 바로 이상을 감지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메시지 m은 길어질 수 있고 m에 바로 복호화, 암호화를 하게 되면 계산량이 늘어난다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;해시 함수를 사용해서 m의 길이를 &lt;strong&gt;고정길이 해시값&lt;/strong&gt;으로 변환해서 암호화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;해시-함수-사용-흐름&quot;&gt;해시 함수 사용 흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;메시지를 해시 함수에 넣어서 해시값 H(m)을 생성한다.&lt;/li&gt;
  &lt;li&gt;H(m)을 개인키 K-로 암호화해서 보낸다. → (m, K-(H(m)))
    &lt;ul&gt;
      &lt;li&gt;수신자에게는 (m, h)로 보인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수신자는 h값을 k+로 복호화하고 H(m)값과 비교한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;공개키-인증&quot;&gt;공개키 인증&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trudy&lt;/code&gt;가 자신의 개인키(K-)를 사용해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;이 피자를 주문한다는 메시지를 암호화한 후 (m’, K-(H(m’)))을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice(피자집)&lt;/code&gt;에 보낸 경우를 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trudy&lt;/code&gt;의 공개키를 통해서 메시지를 복호화할 것이고 메시지의 내용이 위조가 없음을 판단할 것이다.&lt;/p&gt;

&lt;p&gt;그리고 주문하지 않은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;에게 피자를 보낼 것이다.(ㅜㅜ)&lt;/p&gt;

&lt;p&gt;→ 이를 막기 위해서는 서명자의 공개키라고 생각되는 것이 정말 서명자의 것인지 알 수 있어야 하고 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;가 해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;공개키가 누구의 것인지 보증하는 일을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;에서 담당한다.&lt;/p&gt;

&lt;h3 id=&quot;흐름-3&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;이 자신의 공개키를 들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;에게 인증을 요구한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;가 적절하게 검증을 해준다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob은&lt;/code&gt; 전적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;의 검증을 신뢰해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;는 공개키와 신분 확인서를 결합한 인증서를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;에게 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 다음 통신부터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인증서&lt;/code&gt;와 메시지를 같이 암호화하여 보냄으로서 신원을 보증할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;종단점-인증-1&quot;&gt;종단점 인증&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_7.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대칭키와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;넌스&lt;/code&gt;를 동시에 사용하면 종단점 인증을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;흐름-4&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;는 메시지를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;에게 보낸다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;은 넌스 R을 생성하고 이것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;에게 보낸다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;과 공유하는 대칭키를 사용하여 넌스 R을 암호화하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;에게 다시 보낸다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;은 이 값을 복호화하고 지금 통신하는 주체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;임을 확인할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;layer5-에서-제공하는-보안-서비스&quot;&gt;Layer5 에서 제공하는 보안 서비스&lt;/h2&gt;

&lt;h3 id=&quot;전자메일&quot;&gt;전자메일&lt;/h3&gt;

&lt;h4 id=&quot;기밀성-1&quot;&gt;기밀성&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;흐름-5&quot;&gt;흐름&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;는 대칭 세션키(Ks)를 선택한다.&lt;/li&gt;
  &lt;li&gt;Ks로 m을 암호화하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;의 공개키 (K+B)로 Ks를 암호화한 쌍을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;에게 전송한다.
    &lt;ul&gt;
      &lt;li&gt;(K+B(Ks), Ks(m))&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;은 자신의 개인키로 세션키(Ks)를 얻고 Ks로 메시지를 복호화한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 이를 통해서 메시지의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;을 충족시킬 수 있다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;만이 메시지를 열람할 수 있음.)&lt;/p&gt;

&lt;h5 id=&quot;송신자-인증--메시지-무결성&quot;&gt;송신자 인증 &amp;amp; 메시지 무결성&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;는 m를 해시 함수에 넣어서 해시값 H(m)을 얻는다.&lt;/li&gt;
  &lt;li&gt;H(m)을 자신의 개인키로 암호화한다. (전자서명)&lt;/li&gt;
  &lt;li&gt;이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;에게 전송하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bob&lt;/code&gt;은 이를 수신하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;의 공개키로 복호화한다.&lt;/li&gt;
  &lt;li&gt;복호화한 결과가 메시지m과 동일하면 메시지의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;이 확인된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 전자서명을 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신자를 인증&lt;/code&gt;할 수 있다.&lt;/p&gt;

&lt;p&gt;위의 두 가지를 합치면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신자 인증&lt;/code&gt;을 만족시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;흐름-6&quot;&gt;흐름&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;는 m과 m을 자신의 개인키로 암호화한 쌍을 하나의 값으로 묶는다.&lt;/li&gt;
  &lt;li&gt;이 값을 세션키(Ks)로 한번 더 암호화한다.&lt;/li&gt;
  &lt;li&gt;그리고 세션키(Ks)는 수신자의 공개키로 암호화한다.&lt;/li&gt;
  &lt;li&gt;이 두 쌍을 묶어서 전송한다.
    &lt;ul&gt;
      &lt;li&gt;(Ks(K-A(H(m), m), K+b(K(s))&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 수신자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;의 공개키를 알아야 하는데 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA&lt;/code&gt;를 통해서 인증을 받는다.&lt;/p&gt;

&lt;h2 id=&quot;layer4-에서-제공하는-보안-서비스&quot;&gt;Layer4 에서 제공하는 보안 서비스&lt;/h2&gt;

&lt;h3 id=&quot;tls-transport-layer-security&quot;&gt;TLS (Transport Layer Security)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버인증&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클라이언트 인증&lt;/code&gt;을 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;핸드셰이크&quot;&gt;핸드셰이크&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_11.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 흐름은 약식 TLS 핸드셰이크 과정이다.&lt;/p&gt;

&lt;h3 id=&quot;흐름-7&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클라이언트(Bob)&lt;/code&gt;은 넌스와 함께 자신이 지원하는 암호화 알고리즘을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버(Alice)&lt;/code&gt;에 보낸다.
    &lt;ul&gt;
      &lt;li&gt;넌스를 사용하는 이유는 메시지에 유일성이 생기기 때문에 동일한 메시지를 공격자가 서버에 보내도 구분할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버(Alice)&lt;/code&gt;는 대칭키, 공개키, HMAC 알고리즘과 HMAC 키를 선택하고 이를 서버 넌스와 인증서와 함께 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클라이언트(Bob)&lt;/code&gt;에게 보낸다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클라이언트(Bob)&lt;/code&gt;은 서버의 공개키를 알아내고 PMS를 생성한다. 그리고 PMS를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버(Alice)&lt;/code&gt;의 공개키로 암호화하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버(Alice)&lt;/code&gt;로 보낸다.&lt;/li&gt;
  &lt;li&gt;클라이언트, 서버는 동일한 키 유도 함수를 사용하여 PMS와 넌스로부터 MS를 계산한다.&lt;/li&gt;
  &lt;li&gt;MS는 2개의 암호화 키와 2개의 HMAC 키를 생성하기 위해 분할된다.&lt;/li&gt;
  &lt;li&gt;이후부터 모든 메시지는 암호화되고 인증된다. (HMAC에 의해)
    &lt;ul&gt;
      &lt;li&gt;클라이언트, 서버의 모든 핸드셰이크 메시지의 HMAC을 전송한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;연결-종료&quot;&gt;연결 종료&lt;/h3&gt;

&lt;p&gt;레코드의 타입 필드에 TLS 세션을 종료할 것인지 표시해야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이렇게 하지 않으면 공격자로부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;절단 공격&lt;/code&gt;을 받을 수 있다.&lt;/li&gt;
  &lt;li&gt;공격자가 중간에서 TCP FIN을 보내는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;절단 공격&lt;/code&gt;이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;layer3-에서-제공하는-보안-서비스&quot;&gt;Layer3 에서 제공하는 보안 서비스&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메시지 무결성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신자 인증&lt;/code&gt;을 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;ipsec&quot;&gt;IPsec&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_12.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;특징-1&quot;&gt;특징&lt;/h4&gt;

&lt;p&gt;호스트간 안전하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;이 보장된 통신을 제공한다.&lt;/p&gt;

&lt;p&gt;기존에는 사설 네트워크를 설치해서 이를 실현했는데 비용이 많이들기 때문에 요즘에는 공공 네트워크 상에 VPN을 설치한다.&lt;/p&gt;

&lt;p&gt;공공 인터넷에 접근하기 직전에 IPsec으로 데이터그램을 바꾸고 진입한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IPsec도 IPv4의 헤더를 가지기 때문에 라우터는 이 둘을 구분하지 못한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;esp-프로토콜&quot;&gt;ESP 프로토콜&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 무결성&lt;/code&gt;을 제공한다.&lt;/p&gt;

&lt;p&gt;AH프로토콜도 있는데 기밀성을 제공하지 못하기 때문에 ESP가 주로 사용된다.&lt;/p&gt;

&lt;h4 id=&quot;sa&quot;&gt;SA&lt;/h4&gt;

&lt;p&gt;송신지와 수신지는 IPsec 데이터그램을 전송하기 전에 둘 사이에 논리적 연결을 설립한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SA(security association)&lt;/code&gt;라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SA&lt;/code&gt;는 단방향이라서 양방향으로 데이터를 전송하기 위해서는 2개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SA&lt;/code&gt;를 설립해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;ipsec-데이터그램&quot;&gt;IPsec 데이터그램&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_13.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;방화벽&quot;&gt;방화벽&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/44_14.png&quot; alt=&quot;img1&quot; width=&quot;80%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;전체 인터넷으로부터 기관의 내부 네트워크를 분리시킨 하드웨어와 소프트웨어의 조합으로, 어떤 패킷은 통과가 허용되나 어떤 패킷은 차단된다.&lt;/p&gt;

&lt;p&gt;쉽게 말하면 공공 네트워크와 기관 내부 네트워크 사이에서 패킷을 필터링하는 역할을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;역할&quot;&gt;역할&lt;/h3&gt;

&lt;p&gt;공공 네트워크와 기관 네트워크를 지나는 모든 트래픽은 방화벽을 거친다.&lt;/p&gt;

&lt;p&gt;기관 네트워크의 정책에 허용된 트래픽만 방화벽을 통과할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 네트워킹 하향식 접근 (제8판)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="Network" /><category term="Netowrk" /><summary type="html"></summary></entry><entry><title type="html">[테스트] 단위 테스트</title><link href="http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/43/" rel="alternate" type="text/html" title="[테스트] 단위 테스트" /><published>2023-11-01T00:00:00+09:00</published><updated>2023-11-01T00:00:00+09:00</updated><id>http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/43</id><content type="html" xml:base="http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/43/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동기&quot;&gt;동기&lt;/h2&gt;

&lt;p&gt;이번 우테코 2주차 미션부터 메서드를 테스트하는 요구사항이 추가됐다. &lt;br /&gt;
그래서 이번에 테스트에 대해서 공부하고 정리하고자 이 글을 작성하게 됐다. &lt;br /&gt;
테스트에는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단위 테스트&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;통합 테스트&lt;/code&gt;가 있는데 오늘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단위 테스트&lt;/code&gt;가 무엇인지, 그리고 어떻게 사용하는지에 중점을 맞추겠다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;단위-테스트&quot;&gt;단위 테스트&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 작은 단위의 테스트로 일반적으로 클래스 또는 메서드 수준으로 테스트를 진행한다. Java에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JUnit&lt;/code&gt;을 통해 테스트가 진행되며, 특히 &lt;em&gt;TDD&lt;/em&gt;와 함께 할 때 강력함을 발휘한다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러면 바로 사용 방법에 대해서 알아보자. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용되는-에노테이션&quot;&gt;사용되는 에노테이션&lt;/h2&gt;

&lt;h3 id=&quot;test&quot;&gt;@Test&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Test&lt;/code&gt;를 붙이면 메서드를 테스트 메서드로 인식하게 되고, 단일 실행할 수 있게 설정된다.&lt;br /&gt;
아래 코드를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;메소드를 단독으로 실행할 수 있게 왼쪽에 녹색 커서가 생긴것을 확인할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 단독으로 테스트 메서드가 실행된 것을 확인할 수 있다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;displayname&quot;&gt;@DisplayName&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DisplayName&lt;/code&gt;는 테스트 결과에 뜨는 이름을 설정할 수 있게 해준다. 테스트 결과에 같이 출력하고 싶은 내용을 추가할 수 있게 해준다. &lt;br /&gt;
바로 예시를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_3.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 해주면 아래와 같이 결과와 함께 미시지를 출력할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_4.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;before-시리즈&quot;&gt;@Before~ 시리즈&lt;/h3&gt;

&lt;h2 id=&quot;beforeall&quot;&gt;BeforeAll&lt;/h2&gt;

&lt;p&gt;이름부터 참 직관적이다. 모든 테스트 실행되기 전에 실행되는 것이라고 생각하면 된다.&lt;br /&gt;
&lt;strong&gt;단 한번만 실행되면 반드시 static으로 선언해야 한다.&lt;/strong&gt; &lt;br /&gt;
바로 예시를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_5.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_6.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;결과를 보면 알 수 있듯이 먼저 실행이 출력되고 test1, test2의 내용이 출력되는 것을 확인할 수 있다. 이 때 주의할 점은 test1, test2의 순서는 보장되지 않는다. 내부적으로 실행 순서가 있긴 하지만 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JUnit&lt;/code&gt;의 내부 구조에 따라 바뀔 수 있다.&lt;br /&gt;
만약 순서를 지정하고 싶다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@TestMethodOrder&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Order&lt;/code&gt;를 사용해서 지정할 수 있다. &lt;br /&gt;
&lt;strong&gt;일반적으로 단위 테스트는 서로 의존적이지 않기 때문에 순서가 상관이 없다.&lt;/strong&gt; 하지만 경우에 따라 순서가 필요한 경우가 있을 수 있기 때문에 알아만 두자! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;beforeeach&quot;&gt;@BeforeEach&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt;는 각각의 테스트 메서드가 실행되기 전에 실행되는 메서드다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeAll&lt;/code&gt;은 처음에 한 번 실행되지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt;는 각 테스트마다 실행되는 차이점이 있다. &lt;br /&gt;
마찬가지로 예시를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_7.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_8.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;결과를 보면 알 수 있듯이 먼저 실행이 test1, test2 실행 이전에 출력되는 것을 확인할 수 있다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;after-시리즈&quot;&gt;@After~ 시리즈&lt;/h2&gt;

&lt;h3 id=&quot;afterall&quot;&gt;@AfterAll&lt;/h3&gt;

&lt;p&gt;모든 테스트 메서드가 실행되고 단 한번만 실행된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeAll&lt;/code&gt;과 정 반대라고 생각하면 된다.&lt;br /&gt;
마찬가지로 static 메서드로 선언해야 한다.&lt;br /&gt;
예시를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_9.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_10.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;나중 실행&lt;/strong&gt;이 모든 테스트 메서드가 실행되고 난 후 출력된 것을 확인할 수 있다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;aftereach&quot;&gt;@AfterEach&lt;/h3&gt;

&lt;p&gt;위에 설명한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt;의 정 반대라고 생각하면 된다. 테스트 메서드가 끝날때마다 호출된다. &lt;br /&gt;
마찬가지로 예시를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_11.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_12.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 실제로 단위 테스트에 사용되는 메서드들을 살펴보자. &lt;br /&gt;
일반적으로 단정(assert) 메서드를 많이 사용하는데 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;junit&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertj&lt;/code&gt; 두 종류가 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertj&lt;/code&gt;가 등장하기 전까지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;junit&lt;/code&gt;을 주로 사용했지만 이제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertj&lt;/code&gt;를 많이 사용한다. 기능은 동일하지만 가독성이 더 좋기 때문이다. &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertj&lt;/code&gt;는 메서드 체인을 지원하기 때문에 가독성이 더 좋다. &lt;br /&gt; 때문에 오늘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertj&lt;/code&gt;에 대해서 정리하고자 한다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;assertj&quot;&gt;assertj&lt;/h1&gt;

&lt;h2 id=&quot;assertionsassertthat&quot;&gt;Assertions.assertThat()&lt;/h2&gt;

&lt;h3 id=&quot;isequalto-isnotequalto&quot;&gt;isEqualTo(), isNotEqualTo()&lt;/h3&gt;

&lt;p&gt;이 메서드는 &lt;strong&gt;assertThat(a).isEqualTo(b)&lt;/strong&gt;와 같이 사용된다. 대상a 와 기댓값 b의 값이 같은지 확인하는 메서드이다. &lt;br /&gt;
isNotEqualTo()는 정확히 반대라고 생각하면 된다.&lt;br /&gt;
예시를 보자&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_13.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;isEqualTo(), isNotEqualTo()는 값을 통해 검증하는 단정 메서드이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;issameas-isnotsameas&quot;&gt;isSameAs(), isNotSameAs()&lt;/h3&gt;

&lt;p&gt;이 메서드는 &lt;strong&gt;assertThat(a).isSameAs(b)&lt;/strong&gt; 와 같이 사용된다. 대상 a가 기댓값 b와 같은 대상인지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소값&lt;/code&gt;을 통해 확인한다. &lt;br /&gt;
사용법은 사실 isEqualTo()와 완전히 동일하기 때문에 생략하겠다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 가장 중요한 부분은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isEqualTo()&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isSameAs()&lt;/code&gt;의 차이점을 명확하게 아는 것이다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;isequalto-vs-issameas&quot;&gt;isEqualTo() VS isSameAs()&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;isEqualTo()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;isEqualTo()는 단순히 값이 동일한지 확인한다. 객체가 비교 대상이 될 때는 Java의 equals() 메서드의 기능을 한다. &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;isSameAs()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;isSameAs()는 단순 값이 아니라 참조값이 같은지를 비교한다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래 코드를 보고 어떤 결과가 나올지 생각해보면 더 잘 이해할 수 있을 것이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_14.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;case 1, 2, 3, 4의 결과를 생각해보자. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case1&lt;/code&gt; 의 경우는 에러가 발생할 것이다. memberA, memberB는 다른 객체를 가리키고 있기 때문이다. &lt;br /&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case2&lt;/code&gt; 의 경우는 어떨까? 마찬가지로 에러가 발생할 것이다. 이름도 같고 id도 같은데 왜 에러가 발생할까? 그 이유는앞에서 말한 것처럼 isEqualTo()는 Java문법의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equals()&lt;/code&gt;와 동일한 기능을 제공하기 때문이다. 우리는 Member를 정의할 때, Object 클래스의 equals()메서드를 오버라이딩하지 않았기 때문에 단순 객체의 참조값을 비교하게 된다. 때문에 에러가 발생하는 것이다. &lt;br /&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case3&lt;/code&gt; 의 경우는 성공할 것이다. 맴버변수 name은 String 타입이다. String은 equals() 함수를 오버라이딩 해서 실제 값을 비교하도록 구현돼있다. memberA, memberB는 동일한 member라는 이름을 가지기 때문에 성공한다. &lt;br /&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case4&lt;/code&gt; 의 경우도 String 타입이기 때문에 실제 값을 비교하여 성공하게 될 것이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;isinstanceof&quot;&gt;isInstanceOf()&lt;/h2&gt;

&lt;p&gt;이 메서드는 대상이 특정 클래스의 인스턴스인지 검증할 때 사용한다. 사용법은 &lt;strong&gt;assertThat(a).isInstanceOf(b.class)&lt;/strong&gt;와 같이 사용하면 된다. &lt;br /&gt; 아래 예시 코드를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_15.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;isnull-isnotnull&quot;&gt;isNull(), isNotNull()&lt;/h2&gt;

&lt;p&gt;이름 그대로 대상이 null인지 아닌지 확인하는 메서드이다. &lt;br /&gt;
바로 예시를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_16.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;contains-containsexactly&quot;&gt;contains(), containsExactly()&lt;/h2&gt;

&lt;p&gt;contains()는 리스트에 특정 원소가 포함됐는지 확인할 때 사용한다. 순서를 따지지 않고 값만 존재한다면 통과한다. &lt;br /&gt;
사용방법은 &lt;strong&gt;Assertions.assertThat(list).contains(1, 2)&lt;/strong&gt;와 같다. &lt;br /&gt;&lt;br /&gt;
containsExactly()는 contains()와 달리 원소의 순서, 개수까지 정확하게 동일해야 통과를 한다. &lt;br /&gt;
아래 코드를 보고 어떤 결과가 나올지 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/43_17.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case1&lt;/code&gt;의 경우는 실패할 것이다. containsExactly()는 정확하게 값이 일치하고 순서도 같아야 하기 때문이다. &lt;br /&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case2&lt;/code&gt;는 성공할 것이다. 순서와 값이 일치한다. &lt;br /&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case3&lt;/code&gt;은 성공할 것이다. contains는 값의 일부만 일치해도 통과가 된다. 그리고 순서도 신경쓰지 않기 때문이다. &lt;br /&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case4&lt;/code&gt;는 실패할 것이다. 값은 모두 일치하지만 순서가 다르기 때문이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 기본적인 단위 테스트에 대해서 정리해봤다. 혹시 잘못된 부분이 있다면 알려주세요~ &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://m42-orion.tistory.com/97?category=1085496&lt;/li&gt;
  &lt;li&gt;https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/&lt;/li&gt;
  &lt;li&gt;https://velog.io/@chori/JUnit-5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4&lt;/li&gt;
  &lt;li&gt;https://inkyu-yoon.github.io/docs/Language/Spring/IsEqualIsSame&lt;/li&gt;
  &lt;li&gt;https://bcp0109.tistory.com/317&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="테스트" /><category term="우테코" /><category term="프리코스" /><category term="테스트" /><category term="Junit5" /><summary type="html"></summary></entry><entry><title type="html">[프리코스] 숫자 야구 리뷰</title><link href="http://localhost:4000/%EC%9A%B0%ED%85%8C%EC%BD%94/42/" rel="alternate" type="text/html" title="[프리코스] 숫자 야구 리뷰" /><published>2023-10-30T00:00:00+09:00</published><updated>2023-10-30T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B0%ED%85%8C%EC%BD%94/42</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B0%ED%85%8C%EC%BD%94/42/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/42_2.png&quot; alt=&quot;img1&quot; width=&quot;40%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;조금 늦었지만 지난주에 수행했던 숫자 야구 미션에 대해서 리뷰해보고자 한다. &lt;br /&gt;
숫자 야구 게임이란 1~9까지의 서로 다른 수로 이루어진 3자리의 수를 맞추는 게임이다. 컴퓨터가 생성한 3자리 숫자와 사용자가 입력한 3자리 수의 각 자리수를 비교한다. 만약 자리수, 숫자가 모두 같으면 스트라이크이고 자리수는 다르지만 숫자가 같으면 볼이다. 자리수, 숫자 같은게 아무것도 없으면 낫싱이다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이를 토대로 다음과 같은 기능 명세서를 먼저 만들었다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기능-명세서&quot;&gt;기능 명세서&lt;/h2&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;컴퓨터 난수 생성하기
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;수의 유효성을 검사한다. (길이가 3인지, 숫자인지, 중복된 수인지)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;사용자로부터 숫자를 입력 받기
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;입력 숫자의 유효성을 검사한다. (null검사, 길이 3인지, 숫자인지, 중복된 수 존재하는지)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;컴퓨터 수와 사용자로부터 입력받은 수를 비교한다.
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;볼 개수 세기&lt;/li&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;스트라이크 개수 세기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;게임 성공 여부를 판단한다.
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;스트라이크의 수가 3인지 체크한다.&lt;/li&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;성공 시 게임 재시작 숫자를 입력한다.&lt;/li&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;실패 시 게임 숫자를 입력한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;결과 출력
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;성공시 성공 메시지와 재시작 안내 메시지를 출력한다.&lt;/li&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;실패시 게임 결과를 출력하고 게임 숫자 입력 안내 메시지를 출력한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;종료 숫자를 입력받는다.
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;종료 입력 수의 유효성을 검사한다. (null검사, 길이 1인지, (1, 2)에 속하는지)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 이를 토대로 구현한 코드를 살펴볼건데 먼저 리팩토링하기 전의 단순히 테스트만 통과하는 코드를 먼저 보자 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;리팩토링-전-코드&quot;&gt;리팩토링 전 코드&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;숫자 야구 게임을 시작합니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Randoms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pickNumberInRange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;숫자를 입력해주세요 : &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

                    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;1&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;9&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strike&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;0&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;strike&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strike&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3스트라이크&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;개의 숫자를 모두 맞히셨습니다! 게임 종료&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strike&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;낫싱&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;볼&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strike&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;스트라이크&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;볼 &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strike&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;스트라이크&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isExit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isExit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isExit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;1&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isExit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;2&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isExit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;0&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
진짜 말그대로 테스트만 통과하게 작성한 코드이다. 코테 문제푸는 느낌? 으로 구현했던 것 같다..&lt;br /&gt;
하지만 단순히 p/f로 나뉘는 코테와 달리 실제로 다른 사람과 협업하고 유지보수적인 관점까지 고려한다면, 위 코드에는 다음과 같이 여러 문제가 있다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제점&quot;&gt;문제점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;하나의 클래스에서 모든 작업이 이루어진다. -&amp;gt; 너무 많은 책임의 부여&lt;/li&gt;
  &lt;li&gt;가독성이 매우 떨어진다. -&amp;gt; 코드만 보고 어떤 일을 하고 있는지 파악이 어렵다.&lt;/li&gt;
  &lt;li&gt;하드코딩 했기 때문에 유지보수가 어렵다.&lt;/li&gt;
  &lt;li&gt;하나의 메서드에서 모든 일이 수행되기 때문에 단위 테스트가 불가능하다.&lt;/li&gt;
  &lt;li&gt;에러 메시지가 없기 때문에 정확히 어디서 예외가 발생한지 확인하기 어렵다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;문제해결&quot;&gt;문제해결&lt;/h2&gt;

&lt;p&gt;이런 문제를 해결하기 위해서 필자는 우선 메서드를 나눠보기로 했다. &lt;br /&gt;
위 코드를 토대로 메서드를 추출하려고 노력했는데 스파게티 코드라서 나누는 기준을 잡는것이 쉽지 않았다..&lt;br /&gt;
(주말에 숫자 야구 피드백 강의영상을 보고 반성을 많이했다. 기능 명세서의 중요성과 설계의 중요성을 다시금 느꼈다…) &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;필자는 결과를 출력하는 부분, 게임 숫자를 입력받는 부분, 숫자를 검증하는 부분, 종료 숫자를 입력받는 부분, 난수 생성 부분, 게임 실행 부분을 추출하였다.&lt;br /&gt;
그리고나서 각각의 메서드 기능을 테스트하기 위해서 테스트 코드를 작성하고자 했다. 그런데 여기서 문제가 발생했다. &lt;br /&gt;
private 메서드를 test할 수 없었다.. 그래서 어떻게 하면 테스트 할 수 있을지 찾아봤다. 그리고 private 메서드는 강제로 테스트할 수는 있지만 &lt;strong&gt;private 메서드의 기능이 테스트가 필요한 기능이면 클래스 분리를 생각해봐야 한다는 답을 얻었다.&lt;/strong&gt; &lt;br /&gt;&lt;br /&gt;
그래서 필자는 앞서 분리한 메서드들이 테스트가 필요한지, 어떤 기준으로 나누면 더 코드가 명확해지는지 고민했다. 그리고 필요한 부분에 대해서 클래스 승격을 진행했다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;승격된-클래스들&quot;&gt;승격된 클래스들&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/42_1.png&quot; alt=&quot;img1&quot; width=&quot;40%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;우테코-커뮤니티&quot;&gt;우테코 커뮤니티&lt;/h2&gt;

&lt;p&gt;그리고 이 과정에서 우테코 커뮤니티의 글들이 도움이 많이 됐다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;함께 나누기&lt;/code&gt;에 여러 유익한 글들이 많이 올라왔는데 이중에 &lt;strong&gt;일급 컬렉션&lt;/strong&gt;이라는 주제가 올라왔었다. 처음 보는 키워드였기 때문에 바로 공부를 해서 블로그에 정리하였다 .&lt;br /&gt; 
&lt;br /&gt; 일급 컬렉션 정리 : https://jinsu868.github.io/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/40/ &lt;br /&gt;&lt;br /&gt;
그리고 공부를 해보니 일급 컬렉션이 딱 난수 생성 클래스에 적용하면 좋겠다는 생각이 들었다. 그래서 다시 코드를 리팩토링하여 적용시켰다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;computernumber-class-일급-컬렉션&quot;&gt;ComputerNumber class (일급 컬렉션)&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ComputerNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComputerNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;createComputerNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createComputerNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Randoms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pickNumberInRange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;매직넘버---상수&quot;&gt;매직넘버 -&amp;gt; 상수&lt;/h2&gt;

&lt;p&gt;그리고 나서 가독성 및 유지보수를 위해 매직넘버를 상수로 빼고, ENUM을 사용하여 리팩토링을 진행했다. 메서드 이름, 변수 명도 역할을 명확하게 표현하기 위해 수정했다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//상수 사용&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Notification&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;STRIKE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;스트라이크&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;BALL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;볼&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NOTHING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;낫싱&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;END_MESSAGE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;3스트라이크\n3개의 숫자를 모두 맞히셨습니다! 게임 종료&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;RESTART_MESSAGE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;START_MESSAGE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;숫자 야구 게임을 시작합니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notifySuccessResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;END_MESSAGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RESTART_MESSAGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;~~&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;enum-사용&quot;&gt;ENUM 사용&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//ENUM 사용&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ErrorCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;INVALID_PLAY_NUMBER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;유효하지 않은 게임 수를 입력하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;INVALID_TERMINATE_NUMBER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;유요하지 않은 종료 수를 입력하였습니다&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ErrorCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getErrorMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번 미션에서는 기능 명세서를 제대로 활용하지 못한 것 같다. 다음 미션부터는 기능 명세서를 확실하게 먼저 작성하고 설계를 제대로 한 다음에 코드를 작성하도록 노력하겠다:)&lt;/p&gt;

&lt;p&gt;전체 코드는 아래 링크에서 확인할 수 있다. &lt;br /&gt;
https://github.com/woowacourse-precourse/java-baseball-6/pull/408/files#diff-c71c95b782b88469a2947a817aa6945baf76f4e52c732f226e056fbfae0dcd52&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="우테코" /><category term="우테코" /><category term="프리코스" /><summary type="html"></summary></entry><entry><title type="html">[git] Merge, Rebase, Cheery-pick</title><link href="http://localhost:4000/git/41/" rel="alternate" type="text/html" title="[git] Merge, Rebase, Cheery-pick" /><published>2023-10-29T00:00:00+09:00</published><updated>2023-10-29T00:00:00+09:00</updated><id>http://localhost:4000/git/41</id><content type="html" xml:base="http://localhost:4000/git/41/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이전까지 프로젝트를 하면서 git을 계속 사용했지만 내부 동작 방식을 제대로 이해하지 못한채로 사용했었다.&lt;br /&gt;
내부 동작 방식을 몰랐기 때문에 예측할 수 없는 상황이 많이 발생했었다. 예를들어 merge를 했는데 언제는 commit이 생기고 언제는 안생기는 등…&lt;br /&gt;
이번 기회에 git에 대해서 정리하고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;merge&quot;&gt;merge&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;란 두 브랜치를 합치는 기능을 의미한다. 일반적으로 많이 사용되는 병합 방식으로, 커밋 이력을 모두 남길 때 사용한다.&lt;br /&gt;
 merge 방식에는 &lt;strong&gt;Fast-forward, 3-way-merge&lt;/strong&gt; 가 있다. &lt;br /&gt;
하나씩 살펴보자 &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fast-forward-방식&quot;&gt;Fast-forward 방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 브랜치를 merge한다고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkout&lt;/code&gt; 명령어를 사용해서 master 브랜치로 이동한다&lt;/li&gt;
  &lt;li&gt;그리고 hotfix 브랜치를 merge한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결과를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fast-forward&lt;/code&gt; 라는 문구가 보인다. 이게 무엇일까? &lt;br /&gt;&lt;br /&gt;
hotfix가 가리키는 C4 커밋은 C2 커밋을 base로 하는 브랜치이다. 때문에 merge를 진행함에 있어서 새로운 커밋을 생성할 필요가 없다. 그저 단순히 브랜치 포인터만 이동시켜서 master가 c4를 가리키게 하면된다. 이 경우와 같이 두 브랜치의 base가 같을 때 단순히 브랜치 포인터를 이동시키는 merge 방식을 &lt;strong&gt;fast-forward&lt;/strong&gt; 라고 한다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-way-merge-방식&quot;&gt;3-way-merge 방식&lt;/h3&gt;

&lt;p&gt;이번에는 협업할 때 가장 많이 사용하는 merge 방식인 3-way-merge에 대해서 알아보겠다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_3.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;my-branch가 main 브랜치의 B 커밋으로부터 분기됐다. 그리고나서 main에 새로운 커밋(C, D, E)이 생성된 경우를 생각해보자.&lt;br /&gt;
이 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fast-forward&lt;/code&gt;같이 단순히 브랜치 포인터를 이동시키는 방식으로는 merge를 제대로 수행할 수 없다. &lt;br /&gt;
때문에 my-branch와 main을 공통 부모로 하는 새로운 커밋을 생성한다. 이 방식을 &lt;strong&gt;3-way Merge&lt;/strong&gt; 라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;fast-forward가 가능한 경우에도 Recursive Merge 방식처럼 커밋을 새로 생성하는 방법을 제공한다. git merge 명령에 &lt;strong&gt;–no-ff&lt;/strong&gt; 옵션을 주면 강제로 commit을 생성한 merge가 진행된다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conflict&quot;&gt;Conflict&lt;/h2&gt;

&lt;p&gt;다음으로는 merge할 때 발생할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conflict&lt;/code&gt;에 대해서 알아보자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout master

//hotfix, iss53이 동일한 파일을 수정.
git merge hotfix
git merge iss53
//-&amp;gt; 충돌 발생!!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다시 이 상황을 놓고 생각해보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에서 필요한 기능이 있어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 브랜치를 생성해서 기능을 구현하고 있다.&lt;br /&gt;
그런데 도중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에서 오류를 발견해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;브랜치를 만들어 오류를 수정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;브랜치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에 merge했다. 그런데 hotfix 브랜치에서 수정한 부분이 iss53 기능 브랜치에서 수정한 부분이 동일하다고 가정하자.&lt;br /&gt;
그러면 merge를 수행할 때, 충돌이 발생하게 된다.&lt;br /&gt;
이 merge를 실행하는 시점에 git은 활성화되지 않은 새로운 커밋을 하나 생성한다. 그리고 IDE를 사용하던, 직접 충돌 부분을 수정하여 commit을 하면 충돌이 해결된다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 merge 방식과 충돌에 대해서 알아봤다. 그런데 github에서 제공하는 merge는 조금 다르다. 총 3가지 방식이 있는데 하나씩 살펴보자&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3가지-pull-request-방식&quot;&gt;3가지 pull request 방식&lt;/h1&gt;

&lt;h2 id=&quot;create-merge-commit&quot;&gt;Create merge commit&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_4.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;원래 기본적으로 base가 같을 때 merge를 수행하면 fast-forward 방식이 사용된다. 하지만 Create merge commit 방식은 새로운 commit을 만드는 방식을 사용한다.&lt;br /&gt;
이렇게 함으로써 기능 구현 후 merge 기록이 남게된다. 때문에 가독성이 높아진다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;squash-and-merge&quot;&gt;Squash and merge&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_5.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 방식도 Create merge commit 과 마찬가지로 새로운 커밋을 생성한다.&lt;br /&gt; Create merge commit과의 차이점은 feature에서 작업한 모든 commit을 하나의 commit으로 통합해서 merge한다.&lt;br /&gt;
-&amp;gt; pr 단위로 commit이 묶이기 때문에 가독성이 높아진다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rebase-and-merge&quot;&gt;Rebase and merge&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_6.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 방식은 merge 하는 모든 commit을 단순히 복사해서 붙여넣는다.&lt;br /&gt;
중간의 merge과정이 보이지 않고 history가 한줄로 나열되기 때문에 오히려 가독성이 떨어질 수도 있다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 merge와는 조금 다른 병합 방식인 rebase에 대해서 알아보겠다. &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;rebase&quot;&gt;Rebase&lt;/h1&gt;

&lt;p&gt;현재 브랜치의 &lt;strong&gt;base를 재설정하여 합치는 것&lt;/strong&gt;을 말한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/41_7.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;Merge와 동일하게 브랜치를 합치는 목적으로 사용된다.
    - Commit History가 Merge와 다르게 선형적으로 그려진다.&lt;/p&gt;

&lt;p&gt;Rebase는 현재 브랜치의 base를 바꾸는 것이다.
    - 기존의 Commit을 복사하여 새로 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;cherry-pick&quot;&gt;Cherry-pick&lt;/h1&gt;

&lt;p&gt;다른 브랜치의 있는 commit을 현재 브랜치에 적용하는 것을 의미한다. &lt;br /&gt;
일반적으로 새로운 브랜치를 하나 파서 cherry-pick을 진행하고 원격 저장소에 push하고 main으로 pr을 날리는 것이 일반적이다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//한개의 커밋 가져오기
git cherry-pick 39c123

//여러개의 커밋 가져오기
git cherry-pick 39c123..bjkd12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cherry-pick-conflict&quot;&gt;Cherry-pick Conflict&lt;/h2&gt;

&lt;p&gt;해결 방법&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Conflict 발생 파일을 수정한다.&lt;/li&gt;
  &lt;li&gt;git add 명령어로 수정된 코드를 스테이지 상태로 변경시킨다.&lt;/li&gt;
  &lt;li&gt;git cherry-pick –continue 명령을 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=b72mDco4g78&lt;/li&gt;
  &lt;li&gt;https://www.zehye.kr/git/2019/11/22/11git_merge_conflict/&lt;/li&gt;
  &lt;li&gt;https://hudi.blog/git-merge-squash-rebase/&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="git" /><category term="프로젝트 관리" /><category term="git" /><category term="우테코" /><summary type="html"></summary></entry><entry><title type="html">[클린코드] 일급 컬렉션</title><link href="http://localhost:4000/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/40/" rel="alternate" type="text/html" title="[클린코드] 일급 컬렉션" /><published>2023-10-25T00:00:00+09:00</published><updated>2023-10-25T00:00:00+09:00</updated><id>http://localhost:4000/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/40</id><content type="html" xml:base="http://localhost:4000/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/40/">&lt;p&gt;우테코 1주차 과제를 리팩토링하면서 일급 컬렉션이라는 개념에 대해서 알게 됐다. 오늘은 일급 컬렉션이 무엇인지, 그리고 언제 사용하면 유용한지에 대해서 소개하겠다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;일급-컬렉션이란-무엇일까&quot;&gt;일급 컬렉션이란 무엇일까?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;규칙 8: 일급 콜렉션 사용 &lt;br /&gt;
콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다. &lt;br /&gt;
각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다. &lt;br /&gt;
필터가 이 새 클래스의 일부가 됨을 알 수 있다. &lt;br /&gt;
필터는 또한 스스로 함수 객체가 될 수 있다. &lt;br /&gt;
또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다. &lt;br /&gt;
이는 인스턴스 변수에 대한 규칙의 확실한 확장이지만 그 자체를 위해서도 중요하다. &lt;br /&gt;
콜렉션은 실로 매우 유용한 원시 타입이다. &lt;br /&gt;
많은 동작이 있지만 후임 프로그래머나 유지보수 담당자에 의미적 의도나 단초는 거의 없다. - 소트웍스 앤솔로지 객체지향 생활체조편 &lt;br /&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 내용은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체지향 생활체조&lt;/code&gt;에서 소개된 내용이다. 개념 자체는 단순하다. 컬렉션을 클래스로 감싸고 다른 맴버 변수가 없도록 하면 이 클래스가 일급 컬렉션이 된다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;컬렉션을 감싸면서 얻는 이점은 다음과 같다. &lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;비지니스에 종속적인 자료구조가 된다.&lt;/li&gt;
  &lt;li&gt;컬렉션의 불변성을 보장한다.&lt;/li&gt;
  &lt;li&gt;상태와 행위를 한 곳에서 관리할 수 있다.&lt;/li&gt;
  &lt;li&gt;컬렉션에 이름을 부여할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 각각을 하나씩 설명해보겠다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;비지니스에-종속적인-자료구조&quot;&gt;비지니스에 종속적인 자료구조&lt;/h2&gt;

&lt;p&gt;아래와 같은 요구사항이 있다고 해보자. &lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;3자리의 수&lt;/li&gt;
  &lt;li&gt;각 수는 중복되면 X&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
이런 자료구조는 기본으로 제공하지 않는다. 이를 일반적인 자료구조로 구현하기 위해서는 이 요구사항을 만족시키는 값을 생성하는 모든 코드에 검증 로직을 추가해야 한다. 그리고 만약 신입이 처음 회사에 들어와서 코드를 작성하면 검증이 필요한 로직인지 알 수 있는 방법이 없다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉 모든 코드와 도메인을 알아야 제대로 코드를 작성할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이런 검증 로직과 데이터를 묶는 비지니스에 종속적인 자료구조가 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일급 컬렉션&lt;/code&gt;이다. 아래 코드를 보자 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ComputerNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComputerNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;createComputerNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createComputerNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Randoms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pickNumberInRange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;숫자를 저장하는 List를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ComputerNumber&lt;/code&gt;라는 클래스로 감싸서 일급 컬렉션으로 만든 코드이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ComputerNumber&lt;/code&gt;라는 일급 컬렉션을 사용하게 되면 앞으로 &lt;strong&gt;길이가 3, 중복이 없는 숫자&lt;/strong&gt;를 생성할 때 이 객체를 사용하면 된다. 비지니스에 종속적인 자료구조를 직접 만든 것이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;불변&quot;&gt;불변&lt;/h2&gt;

&lt;p&gt;일급 컬렉션은 불변을 보장한다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt;과는 차이가 있다. &lt;br /&gt;
&lt;strong&gt;java의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt;은 불변이 아니라 재할당만 금지한다.&lt;/strong&gt; 아래 코드를 보자&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FinalTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;final_test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Assertions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertEquals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행하면 set에 값이  추가된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/40_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이와같이 자바의 final은 불변이 아니라 단순 재할당만 막는 기능을 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최근의 소프트웨어의 규모가 계속 커짐에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불변&lt;/code&gt;은 굉장히 중요한 키워드가 됐다. &lt;br /&gt;
이를 java의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt;로는 해결할 수 없는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일급 컬렉션&lt;/code&gt;을 사용하면 불변 컬렉션을 만들 수 있다 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ComputerNumber&lt;/code&gt; 클래스는 처음 생성자에서 숫자를 생성하고 그 이후 변경할 수 있는 setter가 없기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불변&lt;/code&gt;을 보장한다. &lt;br /&gt;
이렇게 일급 컬렉션을 이용하면 불변 컬렉션을 만들 수 있다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;상태와-행위를-함께-관리&quot;&gt;상태와 행위를 함께 관리&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;일급 컬렉션은 값과 로직을 함께 관리한다.&lt;/strong&gt; 일급 컬렉션을 사용하지 않으면 데이터와 로직이 떨어져 있기 때문에 관리상의 어려움이 있다. &lt;br /&gt; 이는 유지보수 측면에서 좋지 못하다. 전체 도메인을 알지 못하면 해당 로직이 구현되어 있는지 알 수 없어서 똑같은 로직을 구현하는 문제가 발생할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이름이-있는-컬렉션&quot;&gt;이름이 있는 컬렉션&lt;/h2&gt;

&lt;p&gt;일급 컬렉션을 사용하면 컬렉션에 이름을 붙일 수 있다.(클래스이기 때문에 가능) 이렇게 되면 검색도 편리하고 표현도 가능하게 된다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;이름있는_컬렉션&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newyorkItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createNewyorkItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seoulItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createSeoulItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 오직 변수명으로만 검색해야 하고, 개발자마다 뜻을 다르게 사용할 여지가 있다. 따라서 명확한 표현이 불가능하다. &lt;br /&gt;
아래 코드를 보자 &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;일급컬렉션&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;SeoulItems&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seoulItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SeoulItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createSeoulItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;BusanItems&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;busanItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BusanItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createBusanItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드같은 경우 일급 컬렉션을 기반으로 검색이 가능하다. 클래스 단위로 관리되기 때문에 검색이 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이처럼 일급 컬렉션은 다양한 장점을 가지고 있고 유지보수 측면에서 굉장히 좋다. 필수적으로 공부하자!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://jojoldu.tistory.com/412&lt;/li&gt;
  &lt;li&gt;https://jamie95.tistory.com/99&lt;/li&gt;
  &lt;li&gt;https://jamie95.tistory.com/entry/%EC%9D%BC%EA%B8%89-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90&lt;/li&gt;
  &lt;li&gt;https://matouslescotousles.tistory.com/11&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="클린코드" /><category term="클린코드" /><category term="TDD" /><category term="우테코" /><summary type="html">우테코 1주차 과제를 리팩토링하면서 일급 컬렉션이라는 개념에 대해서 알게 됐다. 오늘은 일급 컬렉션이 무엇인지, 그리고 언제 사용하면 유용한지에 대해서 소개하겠다.</summary></entry><entry><title type="html">[Network] Layer4</title><link href="http://localhost:4000/network/39/" rel="alternate" type="text/html" title="[Network] Layer4" /><published>2023-10-10T00:00:00+09:00</published><updated>2023-10-10T00:00:00+09:00</updated><id>http://localhost:4000/network/39</id><content type="html" xml:base="http://localhost:4000/network/39/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;트랜스포트-계층&quot;&gt;트랜스포트 계층&lt;/h1&gt;

&lt;h2 id=&quot;역할&quot;&gt;역할&lt;/h2&gt;

&lt;p&gt;각기 다른 호스트에서 동작하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스&lt;/code&gt; 사이의 &lt;strong&gt;논리적 통신&lt;/strong&gt;을 제공한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;네트워크 계층 프로토콜은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;호스트&lt;/code&gt; 사이의 &lt;strong&gt;논리적 통신&lt;/strong&gt;을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Port&lt;/code&gt; 번호로 식별한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP&lt;/code&gt;를 통해서 호스트를, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Port&lt;/code&gt;를 통해서 프로세스를 찾아간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종단 시스템(end system, host)에 존재한다.
    &lt;ul&gt;
      &lt;li&gt;Network core, Access network에는 트랜스포트 프로토콜이 존재하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IP 계층에 대한 다양한 제어를 수행한다.
    &lt;ul&gt;
      &lt;li&gt;동적으로 IP주소를 관리, IP 변환, IP 패킷의 흐름제어를 한다.&lt;/li&gt;
      &lt;li&gt;PDU : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;세그먼트(segment)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;다중화와-역다중화&quot;&gt;다중화와 역다중화&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트랜스포트 계층&lt;/code&gt; ↔ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션 계층&lt;/code&gt; 간의 데이터를 주고 받게 해주는 서비스를 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;역다중화-demultiplexing&quot;&gt;역다중화 (demultiplexing)&lt;/h3&gt;

&lt;h4 id=&quot;정의-1&quot;&gt;정의&lt;/h4&gt;

&lt;p&gt;트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 &lt;strong&gt;역다중화&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;다중화-multiplexing&quot;&gt;다중화 (multiplexing)&lt;/h3&gt;

&lt;h4 id=&quot;정의-2&quot;&gt;정의&lt;/h4&gt;

&lt;p&gt;출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 &lt;strong&gt;다중화&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;포트-번호란&quot;&gt;포트 번호란?&lt;/h2&gt;

&lt;h3 id=&quot;정의-3&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;트랜스포트 계층에서의 식별자 역할을 하는 것을 말한다.&lt;/p&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;소켓에 대한 식별을 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일반적으로 source/destination 별로 port 번호가 존재한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;well-kown port number (0~1023)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;user-datagram-protocol-udp&quot;&gt;User Datagram Protocol (UDP)&lt;/h2&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;간단한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiplexing&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demultiplexing&lt;/code&gt; 기능의 프로토콜이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Port 번호와 Checksum만 헤에더 붙는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사실상 IP 의 기능만 수행하며, 애플리케이션 계층에서 흐름 제어, 기타 기능을 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;연결 과정 없이 바로 전송이 가능하다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비연결형&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;연결을 하지 않고 별도의 흐름제어, 혼잡제어를 수행하지 않기 때문에 TCP 보다 속도가 빠르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;헤더의 크기가 작다. (8byte)
    &lt;ul&gt;
      &lt;li&gt;TCP는 20 byte&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;송수신-과정&quot;&gt;송수신 과정&lt;/h3&gt;

&lt;h4 id=&quot;udp-소켓의-생성&quot;&gt;UDP 소켓의 생성&lt;/h4&gt;

&lt;p&gt;애플리케이션 프로세스에서 소켓 생성 즉시 트랜스포트 계층의 port 번호가 부여된다.&lt;/p&gt;

&lt;h4 id=&quot;udp-segment-송수신&quot;&gt;UDP segment 송수신&lt;/h4&gt;

&lt;p&gt;Two tuple : 목적지 IP &amp;amp; port 번호&lt;/p&gt;

&lt;p&gt;수신 port 번호가 같으면 동일한 소켓으로 들어간다. ↔ TCP는 송신 port 번호도 고려하여 소켓으로 매핑된다.&lt;/p&gt;

&lt;p&gt;상대방 호스트의 port 가 열려있으면 항상 전송이 가능하다.&lt;/p&gt;

&lt;p&gt;IP, port 번호를 지정해서 보내면 바로 전달이 가능하다. (비연결형)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Source port의 존재 의의&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;return address&lt;/strong&gt; 개념이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;udp-세그먼트-구조&quot;&gt;UDP 세그먼트 구조&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;신뢰적인-데이터-전송의-원리&quot;&gt;신뢰적인 데이터 전송의 원리&lt;/h2&gt;

&lt;h3 id=&quot;automatic-repeat-request-arq&quot;&gt;Automatic Repeat reQuest (ARQ)&lt;/h3&gt;

&lt;h4 id=&quot;정의-4&quot;&gt;정의&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Acknowlegement&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timer&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reactions&lt;/code&gt;로 구성된다.&lt;/p&gt;

&lt;p&gt;신뢰성 있는 PDU 전송을 위한 가장 보편적인 프로토콜 함수이다.&lt;/p&gt;

&lt;p&gt;TX/RX 가 confimation (ACK)를 받거나 timer-out 까지 기다리는 동안 하는 일련의 동작을 포함한다.&lt;/p&gt;

&lt;h4 id=&quot;방식&quot;&gt;방식&lt;/h4&gt;

&lt;p&gt;재전송 방법에 따라 여러 방식이 존재한다.&lt;/p&gt;

&lt;h5 id=&quot;gbn-go-back-n&quot;&gt;GBN (Go Back N)&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_3.png&quot; alt=&quot;img3&quot; width=&quot;40%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;N번째 unconfirmed PDU로 돌아가서 거기서부터 재전송을 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TX entity&lt;/code&gt;는 acknowledged 되기 전까지 보낸 PDU를 그대로 버퍼에 저장하고 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RX entity&lt;/code&gt;는 N번째 PDU가 문제가 생기면 이후에 PDU(N+1~)는 모두 버린다.&lt;/p&gt;

&lt;p&gt;time-out의 경우 N번째 PDU부터 재전송한다.&lt;/p&gt;

&lt;h5 id=&quot;sr-selective-repeat&quot;&gt;SR (Selective Repeat)&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_4.png&quot; alt=&quot;img4&quot; width=&quot;40%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;손실된 PDU에 대해서만 골라서 재전송한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RX entity&lt;/code&gt;는 제대로 받은 PDU를 저장한다.&lt;/p&gt;

&lt;p&gt;transmission order대로 다 받을때 까지 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cumulative ACK&lt;/code&gt;를 통해 제대로 전달된 PDU를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TX entity&lt;/code&gt;에서 확인한다.&lt;/p&gt;

&lt;h5 id=&quot;gbn-vs-sr&quot;&gt;GBN VS SR&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SR&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RX entity&lt;/code&gt;측에 buffer가 요구된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GBN&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TX entity&lt;/code&gt;측에 buffer가 요구된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GBN&lt;/code&gt;은 재전송 수신까지 시간이 좀 걸리는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SR&lt;/code&gt;은 상대적으로 재전송 수신이 덜 걸린다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;TCP 는 SR과 GBN 의 혼합형이라고 생각하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;transmission-control-protocol-tcp&quot;&gt;Transmission Control Protocol (TCP)&lt;/h2&gt;

&lt;h3 id=&quot;특징-3&quot;&gt;특징&lt;/h3&gt;

&lt;h4 id=&quot;tcp는-연결-지향형이다&quot;&gt;TCP는 연결 지향형이다.&lt;/h4&gt;

&lt;p&gt;connection establishment 과정이 존재한다.&lt;/p&gt;

&lt;p&gt;connection이 존재 해야지만 세그먼트를 전달할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;전이중-서비스full-duplex-service를-제공한다&quot;&gt;전이중 서비스(full-duplex service)를 제공한다.&lt;/h4&gt;

&lt;p&gt;A와 B가 연결되어 있으면 A→B, B→A 양방향으로 흐를 수 있다.&lt;/p&gt;

&lt;p&gt;TCP 연결은 항상 단일 송신자와 단일 수신자 사이의 &lt;strong&gt;점대점(point-to-point)&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt;한 송신자가 멀티캐스팅할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;four-tuple&quot;&gt;Four tuple&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source IP/port number&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destination IP/port number&lt;/code&gt; 로 구성된다.&lt;/p&gt;

&lt;p&gt;UDP와 다르게 source에 대한 정보까지 고려야여 소켓에 매핑된다.&lt;/p&gt;

&lt;h4 id=&quot;tcp-는-신뢰적-데이터-전송을-제공한다&quot;&gt;TCP 는 신뢰적 데이터 전송을 제공한다.&lt;/h4&gt;

&lt;p&gt;재전송 및 ARQ 기능을 포함한다.&lt;/p&gt;

&lt;h2 id=&quot;tcp-세그먼트-구조&quot;&gt;TCP 세그먼트 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_10.png&quot; alt=&quot;img10&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-way-handshake&quot;&gt;3-way handshake&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_5.png&quot; alt=&quot;img5&quot; width=&quot;40%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;request--setup--complete&quot;&gt;request / setup / complete&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initiator&lt;/code&gt;가 confirmation 수신에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;responder&lt;/code&gt;에게 confirm을 또 해준다. (complete)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;responder&lt;/code&gt;는 complete 수신후에 connection이 맺어진 것으로 간주한다.&lt;/p&gt;

&lt;p&gt;complete가 loss가 일어나도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;responser&lt;/code&gt;는 connection이 맺어진 상태로 가정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이전에 request를 받았으므로, connection을 맺고자 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initiator&lt;/code&gt; 의 상태는 이미 확인했다.&lt;/li&gt;
  &lt;li&gt;후속 data PDU을 수신하면 complete를 수신한 것으로 간주할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;흐름제어&quot;&gt;흐름제어&lt;/h2&gt;

&lt;h3 id=&quot;정의-5&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신자&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수신자&lt;/code&gt; 의 버퍼를 오버플로시키는 것을 방지하기 위해 속도를 조절하는 것을 의미한다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신자의 억제&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송수신 entity&lt;/code&gt; 사이에 교환되는 PDU 개수를 조정하는 것을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;필요성&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수신측&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신측&lt;/code&gt;보다 데이터 처리 속도가 느리다면 저장 용량을 초과한 이후에 오는 PDU는 손실될 수 있다.&lt;/p&gt;

&lt;p&gt;만일 손실이 발생한다면 송/수신 측 간에 불필요한 요청이 추가로 발생하게 된다.&lt;/p&gt;

&lt;p&gt;이를 막기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수신측&lt;/code&gt;의 데이터 처리 속도에 맞춰서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신측&lt;/code&gt;에서 PDU를 보내도록 할 수 있는 방법이 요구된다.&lt;/p&gt;

&lt;h3 id=&quot;방식-1&quot;&gt;방식&lt;/h3&gt;

&lt;h4 id=&quot;stop-and-wait&quot;&gt;Stop and Wait&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_6.png&quot; alt=&quot;img6&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이전에 전송한 패킷에 대한 응답을 받아야만 요청을 할 수 있도록 하는 방법이다.&lt;/p&gt;

&lt;p&gt;당연히 성능이 좋지 않기 때문에 사용하지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;sliding-window-protocol&quot;&gt;Sliding window protocol&lt;/h4&gt;

&lt;p&gt;수신측이 제공한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송하게 하여 데이터 흐름을 동적으로 제어하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/39_7.png&quot; alt=&quot;img7&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 윈도우에 포함되는 모든 패킷을 전송한 후, 패킷드의 전달이 확인되는 순간 이 윈도우를 옆으로 옮기면서 다음 패킷을 전송한다.&lt;/p&gt;

&lt;h2 id=&quot;혼잡제어&quot;&gt;혼잡제어&lt;/h2&gt;

&lt;h3 id=&quot;정의-6&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;네트워크 혼잡을 피하기 위해서 송신측에서 보내는 데이터의 전송 속도를 제어하는 것을 &lt;strong&gt;혼잡제어&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;필요성-1&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;송신측에서 전송하는 모든 데이터는 인터넷으로 연결된 네트워크를 통해서 전송된다.&lt;/p&gt;

&lt;p&gt;만약 한 라우터에 많은 패킷이 몰리게 되면 라우터의 큐가 꽉 차게되고 패킷을 버리게 된다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 송신 호스트는 결국 다시 재전송을 하게 될 것이고 네트워크 혼잡도만 높아지게 된다.&lt;/p&gt;

&lt;p&gt;때문에 네트워크가 혼잡할 때는 송신측의 전송 속도를 제어할 필요가 있다.&lt;/p&gt;

&lt;h3 id=&quot;방식-2&quot;&gt;방식&lt;/h3&gt;

&lt;h4 id=&quot;aimdadditive-increase--multiplicative-decrease&quot;&gt;AIMD(Additive Increase / Multiplicative Decrease)&lt;/h4&gt;

&lt;p&gt;패킷을 보내고 문제없이 도착하면 window 크기를 1씩 증가시키는 방식이다.&lt;/p&gt;

&lt;p&gt;패킷 전송이 실패하거나 일정 시간이 지나게 되면 보내는 속도를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;절반&lt;/code&gt;으로 줄인다.&lt;/p&gt;

&lt;p&gt;초기의 네트워크 대역폭을 높게 사용하지 못하고 네트워크가 혼잡해지는 것을 미리 감지할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;slow-start&quot;&gt;Slow start&lt;/h4&gt;

&lt;p&gt;AIMD와 달리 패킷이 성공적으로 전송되면 ACK 패킷마다 window 크기를 1씩 증가시켜준다.&lt;/p&gt;

&lt;p&gt;즉 한 주기마다 window 크기가 두배로 커진다.&lt;/p&gt;

&lt;p&gt;패킷 전송에 실패하게 되면 window 크기를 1로 줄이고 혼잡이 발생했던 window 크기까지 지수함수 크기로 증가시킨다.&lt;/p&gt;

&lt;p&gt;혼잡 발생 크기를 넘기면 1씩 증가시킨다.&lt;/p&gt;

&lt;h4 id=&quot;fast-recovery&quot;&gt;Fast Recovery&lt;/h4&gt;

&lt;p&gt;혼잡 상태가 발생하면 window 크기를 반으로 줄이고 선형 증가시키는 방식이다.&lt;/p&gt;

&lt;p&gt;혼잡 상황을 한번 겪고 나면 AIMD 방식으로 동작한다.&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&amp;amp;%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴퓨터네트워크 하향식 접근&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="Network" /><category term="Network" /><summary type="html"></summary></entry></feed>