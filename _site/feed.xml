<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-21T20:20:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[JPA] 연관관계 매핑</title><link href="http://localhost:4000/jpa/JPA4/" rel="alternate" type="text/html" title="[JPA] 연관관계 매핑" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA4</id><content type="html" xml:base="http://localhost:4000/jpa/JPA4/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;객체와-테이블의-패러다임-불일치&quot;&gt;&lt;em&gt;객체와 테이블의 패러다임 불일치&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;먼저 객체와 테이블 사이의 간극을 이해할 필요가 있다. 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조&lt;/code&gt; 를 사용해서 연관된 객체를 찾는다. 그런데 테이블은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외래키 조인&lt;/code&gt;을 통해서 연관된 테이블을 찾는다. 때문에 객체를 테이블에 맞춰서 설계를 하면 객체간의 협력 관계를 만들 수 없다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 사이의 관계를 통해 이해해보자.&lt;/p&gt;

&lt;p&gt;여기서 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 는 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 에만 속할 수 있다고 가정하자. (1:N)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;테이블에-맞춘-객체-설계&quot;&gt;테이블에 맞춘 객체 설계&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;//Team team 과 같이 참조를 가지는 것이 아니라 식별자를 가진다.&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;TEAM_ID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teamId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clas&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Team 조회&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//member.getTeam()과 같이 바로 조회할 수 없고 id를 구한 후 이를 통해 한번 더 조회해야 한다.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeamId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTeamId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;team&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TeamId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 경우가 테이블에 맞춰서 객체를 설계한 케이스이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 을 참조로 가지고 있는 것이 아니라 외래키를 그대로 들고 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 Member에서 Team을 조회할 때, 참조로 바로 Team을 조회할 수 없고 ID를 통해서 다시 조회해야 한다. 이는 객체 지향적인 방법이 아니다.&lt;/p&gt;

&lt;p&gt;ORM을 통해서 이러한 패러다임의 불일치를 해결할 수 있다. 객체는 객체대로 모델링하면 가운데서 ORM이 알맞게 매핑해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;객체지향-모델링&quot;&gt;객체지향 모델링&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  
	&lt;span class=&quot;nd&quot;&gt;@ManyToOne&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@JoinColumn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;TEAM_ID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Team&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;team&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 코드를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team&lt;/code&gt; 객체를 참조로 가지고 있다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member&lt;/code&gt; 테이블에서는 외래키로 TEAM_ID를 가지고 있을 것이다. 이런 차이를 매핑해주는 것이 바로 &lt;strong&gt;ORM&lt;/strong&gt; 이다. 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/27_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member 객체&lt;/code&gt;에 있는 Team 참조를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member Table&lt;/code&gt; 에 TEAM_ID 라는 외래키로 매핑해준다. 이 때 외래키 이름을 지정해줘야 하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@JoinColumn&lt;/code&gt; 을 통해 지정해줄 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;양방향-매핑&quot;&gt;양방향 매핑&lt;/h1&gt;

&lt;p&gt;이제 양방향 매핑에 대해서 탐구해보자. 양방향 매핑일 때는 고려해야 할 점이 좀 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt;는 양방향 매핑을 하려면 양쪽에 참조를 가져야 한다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;테이블&lt;/code&gt;은 외래키 하나로 조인을 통해서 양쪽을 이동할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/27_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림을 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member 객체&lt;/code&gt;에 있는 Team, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Team 객체&lt;/code&gt;에 있는 Member 참조값을 통해서 양쪽을 왔다갔다 할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 테이블은 MEMBER 테이블에 있는 TEAM_ID라는 외래키를 통해서 양쪽을 이동한다.&lt;/p&gt;

&lt;p&gt;사실 객체는 양방향을 구현하려면 단방향 두개가 있어야 하는 것이고 테이블은 외래키 하나만 있으면 되는 것이다. 때문에 &lt;strong&gt;두 객체 중 한쪽에서 외래키를 관리해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;연관관계의-주인&quot;&gt;연관관계의 주인&lt;/h1&gt;

&lt;p&gt;객체의 두 관계중 하나를 연관관계의 주인으로 설정하고 주인쪽에서 외래키를 관리해야 한다. 반대쪽(거울)에서는 오직 읽기만 가능하다.&lt;/p&gt;

&lt;p&gt;규칙은 간단하다. &lt;strong&gt;외래키를 가지고 있는 곳을 주인으로 설정하면 된다.&lt;/strong&gt; 1:N관계라면 무조건 N쪽에 외래키가 존재하기 때문에 N쪽을 주인으로 설정하면 된다. 거울쪽에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mappedBy&lt;/code&gt; 설정을 해주면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주의점 : 거울쪽에서 수정을 하더라도 udpate query가 날아가지 않는다. (단순 조회만 가능)
    &lt;ul&gt;
      &lt;li&gt;객체 관점에서 보면 양쪽 다 변경되는 것이 맞기 때문에 다 변경해주자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 영속성 컨텍스트</title><link href="http://localhost:4000/jpa/JPA2/" rel="alternate" type="text/html" title="[JPA] 영속성 컨텍스트" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA2</id><content type="html" xml:base="http://localhost:4000/jpa/JPA2/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;영속성-컨텍스트&quot;&gt;&lt;em&gt;영속성 컨텍스트&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;영속성 컨텍스트란 &lt;strong&gt;엔티티를 영구 저장하는 환경&lt;/strong&gt;이라는 뜻이다. 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB역할을 수행한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EntityManager&lt;/code&gt;를 통해서 엔티티를 저장하거나 조회를 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EntityManager&lt;/code&gt;는 영속성 컨텍스트에 엔티티를 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;엔티티의-생명주기&quot;&gt;&lt;em&gt;엔티티의 생명주기&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/25_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;엔티티의 생명주기는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비영속&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;영속&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준영속&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt;가 있다. 하나씩 알아보자&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비영속(new/transient)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트와 전혀 관계가 없는 상태이다. 영속성 컨텍스트가 관리하지 않는 상태를 의미한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//비영속 상태&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuantity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;영속(managed)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에 저장, 관리되는 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//영속 상태&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuantity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;EntityManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createEntityManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTransaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//영속성 컨텍스트에 집어넣는다. 이때 DB에 query가 날아가지는 않는다. transaction commit 시점에 query가 날아감.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준영속(detached)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에 저장되었다가 분리된 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//아이템 엔티티를 영속성 컨텍스트에서 분리 -&amp;gt; 준영속 상태&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;detach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제(removed)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;삭제된 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//객체를 삭제한 상태&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;영속성-컨텍스트의-장점&quot;&gt;영속성 컨텍스트의 장점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1차 캐시&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에 데이터가 있으면 DB를 거치지 않고 바로 영속성 컨텍스트에서 데이터를 조회할 수 있다. 이를 1차 캐시라고 한다.&lt;/li&gt;
      &lt;li&gt;애플리케이션 차원에서 1차 캐시를 통해서 반복 가능한 읽기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPEATABLE READ&lt;/code&gt;) 등급의 트랜잭션 격리 수준을 제공한다.&lt;/li&gt;
      &lt;li&gt;em.find(), em.persist()를 하면 해당 트랜잭션 안에서 영속성 컨텍스트로 관리된다. 예시를 보자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제코드 1)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//예시를 보자&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuantity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//persist를 하면 영속성 컨텍스트에서 저장, 관리된다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제코드 2)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;em&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;em.find()를 호출하면 영속성 컨텍스트에서 먼저 해당하는 엔티티 있는지 찾는다. 만약 없으면 DB에 query를 날려서 가져오고 이를 영속성 컨텍스트에 저장, 관리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쓰기지연&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;em.persist() 를 호출하는 시점에 DB로 query를 날리는 것이 아니라 해당 객체를 영속성 컨텍스트에서 관리하기 시작하고 쓰기 지연 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL 저장소&lt;/code&gt; 에 SQL을 쌓아두었다가 트랜잭션 커밋시점에 한번에 DB에 query를 날린다.&lt;/li&gt;
      &lt;li&gt;아래 그림을 보면 이해하기 쉬울 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/25_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변경감지(Dirty checking)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속성 컨텍스트에서 관리되는 객체들은 변경감지가 적용된다.&lt;/li&gt;
      &lt;li&gt;JPA는 영속성 컨텍스트에 엔티티를 보관할 때 최초의 상태를 저장한다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스냅샷&lt;/code&gt;이라고 한다.&lt;/li&gt;
      &lt;li&gt;영속성 컨텍스트가 Flush 되는 시점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스냅샷&lt;/code&gt; 과 엔티티의 현재 상태를 비교하고 달라진 엔티티를 찾고 변경된 필드들에 대해서 쓰기 지연 SQL에 Update query를 쌓는다.&lt;/li&gt;
      &lt;li&gt;트랜잭션 커밋시점에 쌓여있던 Update query들이 한번에 DB에 날아간다.&lt;/li&gt;
      &lt;li&gt;개발자가 일일이 변경이 발생할 때 이에 해당하는 코드를 넣어주지 않아도 되기 때문에 굉장히 편리하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;플러시&quot;&gt;&lt;em&gt;플러시&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;플러시는 영속성 컨텍스트를 DB와 동기화하는 작업이다. 플러시가 발생하면 변경 감지가 일어나고 수정된 엔티티의 update 내용이 쓰기 지연 SQL에 등록된다. 그리고 쓰기 지연 SQL 저장소의 query를 데이터베이스에 전송한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;플러시가-호출되는-상황&quot;&gt;플러시가 호출되는 상황&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;em.flush()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트랜젝션 커밋&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JPQL 쿼리 실행&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;영속성 컨텍스트를 비우지 않는다.&lt;/li&gt;
  &lt;li&gt;영속성 컨텍스트의 변경내용을 데이터베이스에 동기화한다.&lt;/li&gt;
  &lt;li&gt;트랜잭션 커밋 직전까지만 동기화가 되면 OK&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-commit과-flush의-차이는-무엇일까&quot;&gt;그렇다면 Commit과 flush의 차이는 무엇일까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;플러시는 DB에 query를 전송한느 역할을 수행하고 커밋은 내부적으로 플러시를 호출한 후 트랜잭션을 끝내는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;플러시로 전송된 query는 rollback이 가능하지만 commit을 호출하면 트랜잭션이 끝나기 때문에 rollback이 불가능하다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://code-lab1.tistory.com/290&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://small-stap.tistory.com/74&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://velog.io/@tomato2532/JPA-JPA-Entity-2-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8Persistence-Context&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] Intro</title><link href="http://localhost:4000/jpa/JPA1/" rel="alternate" type="text/html" title="[JPA] Intro" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA1</id><content type="html" xml:base="http://localhost:4000/jpa/JPA1/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA에 대해서 한번 정리해보자!&lt;/p&gt;

&lt;p&gt;본 포스팅은 Inflearn &lt;strong&gt;김영한님&lt;/strong&gt;의 강의를 바탕으로 작성했다.&lt;/p&gt;

&lt;p&gt;(Spring 관련 포스팅은 전부 김영한님 강의를 바탕으로 작성됨.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;orm&quot;&gt;&lt;em&gt;ORM&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORM&lt;/code&gt; (Object-relational mapping)은 객체와 DB 테이블이 매핑을 이루는 것을 말한다. 즉 &lt;strong&gt;객체가 테이블이 되도록 매핑 시켜주는 것&lt;/strong&gt; 을 의미한다.&lt;/p&gt;

&lt;p&gt;객체와 관계형 데이터베이스 사이의 패러다임의 불일치를 해소해주고 객체는 객체대로 설계하고 관계형 데이터베이스는 관계형 데이터베이스대로 설계할 수 있게 도와준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa&quot;&gt;&lt;em&gt;JPA&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;정의와-역할&quot;&gt;정의와 역할&lt;/h2&gt;

&lt;p&gt;그렇다면 JPA는 무엇인가? &lt;strong&gt;JPA란 자바 ORM 기술에 대한 API 표준 명세&lt;/strong&gt;이다. JPA는 ORM을 사용하기 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터페이스&lt;/code&gt; 를 모아둔 것이고, JPA를 사용하기 위해서 구현한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hibernate&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataNucleus&lt;/code&gt; 같은 ORM 프레임워크를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Item&lt;/code&gt;이라는 테이블의 데이터를 얻어오기 위해서는 &lt;strong&gt;SELECT * FROM Item&lt;/strong&gt; 이라는 query를 실행해야 하지만 ORM을 사용하면 &lt;strong&gt;Item.findAll()&lt;/strong&gt; 이라는 메서드를 통해서 데이터를 가져올 수 있다.&lt;/p&gt;

&lt;p&gt;query를 직접 작성하지 않아도 돼서 생산성이 높아진다. 대신 복잡한 query를 ORM으로 표현하기는 한계가 있고 성능도 raw query에 비해서 떨어지는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa는-어디서-동작할까&quot;&gt;JPA는 어디서 동작할까?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24_3.png&quot; alt=&quot;img3&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션에서 CRUD를 수행하면 JPA가 해당하는 SQL을 생성해주고 JDBC API를 사용해서 객체와 DB사이의 패러다임의 불일치를 해결해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa의-장점&quot;&gt;JPA의 장점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체 중심으로 개발&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;기존에는 SQL에 종속적인 개발을 했어야 했다. 그런데 JPA를 사용하면 객체 중심으로 개발을 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지보수&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;객체의 필드를 변경하면 개발자가 하나하나 해당 SQL을 수정했어야 했다. 그런데 이런 매핑과정을 JPA가 대신 해줌으로써 유지보수가 편리해졌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패러다임의 불일치 해결&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;기존에는 상속관계가 있는 객체를 DB에 넣을 때 굉장히 귀찮은 작업이 많았다. 그런데 JPA를 사용하면 알아서 필요한 SQL을 다 만들어서 넣어준다&lt;/li&gt;
      &lt;li&gt;자유로운 객체 그래프 탐색이 가능해졌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;성능&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;같은 트랜젝션 안에서 같은 엔티티를 반환한다. 이것이 가능한 이유는 조회를 한 후에 영속성 컨텍스트에 캐싱해두기 때문이다. DB에 query를 추가로 날리지 않기 때문에 약간의 성능 향상이 있다.&lt;/li&gt;
      &lt;li&gt;persist를 할때마다 DB에 쿼리를 날리지 않고 트랜젝션 커밋시점에 한번에 SQL을 날린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연로딩&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;객체가 실제로 사용되는 시점에 로딩을 한다.&lt;/li&gt;
      &lt;li&gt;사용되지 않는 것들은 프록시로 들고 있는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;즉시로딩&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Join을 통해서 연관된 객체를 한번에 가져온다.&lt;/li&gt;
      &lt;li&gt;항상 같이 사용되는 객체같은 경우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch join&lt;/code&gt;을 통해서 한번에 조회하는 것이 성능상으로 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;다음-포스팅부터는-jpa의-작동-원리와-사용-방법에-대해서-알아보겠다-&quot;&gt;다음 포스팅부터는 JPA의 작동 원리와 사용 방법에 대해서 알아보겠다. :)&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;p&gt;https://victorydntmd.tistory.com/195&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[JPA] 기본키 매핑 전략</title><link href="http://localhost:4000/jpa/JPA3/" rel="alternate" type="text/html" title="[JPA] 기본키 매핑 전략" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA3</id><content type="html" xml:base="http://localhost:4000/jpa/JPA3/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;기본-키-매핑-전략&quot;&gt;기본 키 매핑 전략&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDENTITY&lt;/code&gt; : 데이터베이스에 위임하는 전략
    &lt;ul&gt;
      &lt;li&gt;MYSQL에서 사용됨.&lt;/li&gt;
      &lt;li&gt;AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID값을 알 수 있기 때문에 em.persist() 시점에 바로 INSERT SQL을 실행하고 ID를 가져온다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strategy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GenerationType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;IDENTITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQUENCE&lt;/code&gt; : 데이터베이스 시퀀스 오브젝트 사용
    &lt;ul&gt;
      &lt;li&gt;오라클에서 사용&lt;/li&gt;
      &lt;li&gt;데이터베이스 시퀀스란 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트를 뜻한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@SequenceGenerator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ITEM_SEQ_GENERATOR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;,
sequenceName = “ITEM_SEQ&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;initialValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocationSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strategy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GenerationType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SEQUENCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Table&lt;/code&gt; : 키 생성용 테이블 사용, 모든 DB에 적용 가능
    &lt;ul&gt;
      &lt;li&gt;키 생성 전용 테이블을 하나 만들고 데이터베이스 시퀀스를 흉내내는 전략&lt;/li&gt;
      &lt;li&gt;모든 데이터베이스에 적용이 가능하지만 성능이 좋지 않다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Object&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@TableGenerator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ITEM_SEQ_GENERATOR&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;MY_SEQUENCES&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pkColumnValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ITEM_SEQ&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;, allocationSize = 1)
public class Item {
@Id
@GeneratedValue(strategy = GenerationType.TABLE,
generator = &quot;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;ITEM_SEQ_GENERATOR&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;create table MY_SEQUENCES (
sequence_name varchar(255) not null,
next_val bigint,
primary key ( sequence_name )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTO&lt;/code&gt; : 방언에 따라 자동 지정, 기본 값&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실무-사용-가이드&quot;&gt;실무 사용 가이드&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;기본키는 Long Type + 대체키 + 키 생성전략을 활용하자&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;참고 사이트 출처&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.inflearn.com/course/ORM-JPA-Basic/dashboard&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="JPA" /><category term="Spring" /><category term="JPA" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[알고리즘] Union find</title><link href="http://localhost:4000/algorithm/unionFind/" rel="alternate" type="text/html" title="[알고리즘] Union find" /><published>2023-07-20T00:00:00+09:00</published><updated>2023-07-20T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/unionFind</id><content type="html" xml:base="http://localhost:4000/algorithm/unionFind/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/23_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 Union-Find 알고리즘에 대해서 정리해보겠다. (귀엽다..)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;union-find-algorithm&quot;&gt;&lt;em&gt;Union find algorithm&lt;/em&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;유니온 파인드&lt;/strong&gt; 알고리즘은 상호 배타적 집합, Disjoin-set(서로소 집합) 이라고도 부른다. 여러 노드가 존재할 때, 어떤 두 개의 노드를 같은 집합으로 묶어 주고, 어떤 두 노드가 같은 집하에 있는지 확인하는 알고리즘이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;union-연산&quot;&gt;&lt;em&gt;Union 연산&lt;/em&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;서로 연결된 두 노드 A, B를 선택&lt;/li&gt;
  &lt;li&gt;A의 루트 노드와 B의 루트 노드를 찾기 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find&lt;/code&gt;연산)&lt;/li&gt;
  &lt;li&gt;B를  A의 부모 노드로 설정한다. (parent 리스트의 값 수정)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;union-코드&quot;&gt;union 코드&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;하지만&lt;/p&gt;

&lt;h3 id=&quot;find-연산&quot;&gt;&lt;em&gt;Find 연산&lt;/em&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;해당 노드의 루트 노드를 찾음&lt;/li&gt;
  &lt;li&gt;경로 압축을 통해 시간복잡도를 줄일 수 있다.
    &lt;ul&gt;
      &lt;li&gt;예시를 통해 확인해보자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/23_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 경우 5의 루트 노드를 찾기 위해서는 5 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1을 거쳐서 총 O(V) 만큼의 시간복잡도가 걸린다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경로 압축&lt;/code&gt;을 통해 부모를 루트로 설정하게 되면 아래와 같이 한번에 찾을 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/23_3.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5의 부모 -&amp;gt; 1&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;find-코드&quot;&gt;find() 코드&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Algorithm" /><category term="알고리즘" /><category term="Union find" /><category term="자료구조" /><summary type="html"></summary></entry><entry><title type="html">[Spring] 예외 처리</title><link href="http://localhost:4000/spring/exceptionHandle/" rel="alternate" type="text/html" title="[Spring] 예외 처리" /><published>2023-07-18T00:00:00+09:00</published><updated>2023-07-18T00:00:00+09:00</updated><id>http://localhost:4000/spring/exceptionHandle</id><content type="html" xml:base="http://localhost:4000/spring/exceptionHandle/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;exception-handle&quot;&gt;&lt;em&gt;Exception Handle&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;스프링 부트는 기본 설정으로 예외가 WAS에 전달되거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Response.sendError()&lt;/code&gt; 가 호출되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/error&lt;/code&gt; 를 호출한다. 그러면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicErrorController&lt;/code&gt; 가 제공하는 기본 정보들을 활용해서 오류 API를 생성해준다. 하지만 API 마다, 각각의 컨트롤러나 예외마다 서로 다른 응답 결과를 출력해야 할 수 있다. 때문에 API 오류 처리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ExceptionHandler&lt;/code&gt; 를 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;exceptionresolver&quot;&gt;&lt;em&gt;ExceptionResolver&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/22_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExceptionResolver&lt;/code&gt; 가 없다면 예외가 발생하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Servlet&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filter&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WAS&lt;/code&gt; 까지 올라간다.&lt;/p&gt;

&lt;p&gt;그런데 예외를 처리할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExceptionResolver&lt;/code&gt; 가 있으면 서블릿 컨테이너(WAS) 까지 예외가 전달되지 않고 MVC 선에서 예외 처리가 끝난다.&lt;/p&gt;

&lt;p&gt;가장 우선순위가 높은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExceptionResolver&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerExceptionResolver&lt;/code&gt; 이다. @ExceptionHandler를 처리하는 ExceptionResolver이며 거의 이것만 쓴다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;exceptionhandler&quot;&gt;&lt;em&gt;@ExceptionHandler&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;@ExceptionHandler 애노테이션을 붙여주고, 해당 컨트롤러에서 처리하고 싶은 예외를 지정해주면 예외가 발생했을 때 이 메서드가 호출된다. 지정한 예외 뿐 아니라 예외의 자식 클래스까지 모두 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;예시코드&quot;&gt;예시코드&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApiController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@ExceptionHandler&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleEx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IllegalArgumentException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ErrorResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BAD_REQUEST&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;우선순위&quot;&gt;우선순위&lt;/h3&gt;

&lt;p&gt;구체적인 것이 더 높은 우선순위를 가진다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부모예외처리&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식예외처리&lt;/code&gt; 가 있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식예외처리&lt;/code&gt; 가 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;controlleradvice&quot;&gt;&lt;em&gt;@ControllerAdvice&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;예외처리를 컨트롤러에 다 집어넣으면 가독성이 떨어지고 지저분한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ConrollerAdivce&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RestControllerAdvice&lt;/code&gt; 를 사용하면 정상 코드와 예외 코드를 분리할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;예시코드-1&quot;&gt;예시코드&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//@ControllerAdvice + @ResponseBody&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RestControllerAdvice&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyControllerAdvice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	&lt;span class=&quot;nd&quot;&gt;@ExceptionHandler&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ErrorResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handlerEx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ErrorResult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ErrorResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ex&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;BAD_REQUEST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;동작범위-설정&quot;&gt;동작범위 설정&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@ControllerAdvice&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Advice0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@ControllerAdvice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RestController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Advice1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@ControllerAdvice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.com.controllers&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Advice2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@ControllerAdvice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assignableTypes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ControllerInterface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Advice3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;기본적으로 범위를 설정하지 않으면 전역으로 동작하게 된다.&lt;/li&gt;
  &lt;li&gt;특정 애노테이션이 있는 컨트롤러를 지정할 수 있다.&lt;/li&gt;
  &lt;li&gt;특정 패키지를 직접 지정할 수도 있다.&lt;/li&gt;
  &lt;li&gt;특정 컨트롤러를 지정할 수 있다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Moon JinSu</name></author><category term="Spring" /><category term="Spring" /><category term="MVC" /><summary type="html"></summary></entry><entry><title type="html">[Java] Intro</title><link href="http://localhost:4000/java/javaIntro/" rel="alternate" type="text/html" title="[Java] Intro" /><published>2023-07-16T00:00:00+09:00</published><updated>2023-07-16T00:00:00+09:00</updated><id>http://localhost:4000/java/javaIntro</id><content type="html" xml:base="http://localhost:4000/java/javaIntro/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;java-정리&quot;&gt;&lt;em&gt;Java 정리&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최근 Java를 쓰면서 내가 정말 Java라는 언어를 잘 알고 있나? 라는 의문이 들었다. 프로그래밍을 하면서 자신이 쓰는 언어에 대해서 제대로 이해하는 것은 정말 중요하다. 이참에 한 번 제대로 정리하고 넘어가자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;선택한-책&quot;&gt;&lt;em&gt;선택한 책&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20_2.png&quot; alt=&quot;img2&quot; width=&quot;60%&amp;quot;&amp;quot;, height=&amp;quot;30%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공부할 책은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java의 정석&lt;/code&gt; 으로 정했다. 취업하기 전에 정리하는 느낌으로 좋다는 평이 많아서 선택했다. Java 공부 내용은 주에 최소한으로 3번은 포스팅할 예정이다 (금방 끝낼 수 있겠지?..)&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Java" /><category term="Java" /><summary type="html"></summary></entry><entry><title type="html">[Java] JVM</title><link href="http://localhost:4000/java/java_JVM1/" rel="alternate" type="text/html" title="[Java] JVM" /><published>2023-07-16T00:00:00+09:00</published><updated>2023-07-16T00:00:00+09:00</updated><id>http://localhost:4000/java/java_JVM1</id><content type="html" xml:base="http://localhost:4000/java/java_JVM1/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jvm-이란&quot;&gt;&lt;em&gt;JVM 이란?&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;JVM(Java Virtual Machine) 은 자바와 운영체제 사이에서 중개자 역할을 수행하며 자바가 OS에 의존하지 않고 프로그램을 실행할 수 있게 도와준다. 또한 가비지 컬렉터(GC)를 사용한 메모리 관리도 자동으로 해주며, 다른 하드웨어와 다르게 레지스터 기반이 아닌 스택 기반으로 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;특징&quot;&gt;&lt;em&gt;특징&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/21_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바 컴파일러(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;) 에 의해서 자바 소스 파일(.java)가 바이트 코드(.class) 로 컴파일된다. 그리고 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JVM&lt;/code&gt; 이 읽고 내부적으로 여러 과정을 거쳐서 실행시킨다.&lt;/p&gt;

&lt;p&gt;위 그림에서 알 수 있듯이 JVM은 OS에 의존한다. 때문에 각 OS 마다 다른 JVM이 요구된다. javac 에 의해 컴파일된 바이트 코드는 JVM에서 처리되기 때문에 OS에 의존하지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;write-once-run-anywhere&quot;&gt;&lt;em&gt;Write once, run anywhere&lt;/em&gt;&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;실행-과정&quot;&gt;&lt;em&gt;실행 과정&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/21_4.png&quot; alt=&quot;img4&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 JVM의 실행 과정에 대해서 간단하게 알아보자!&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받는다.&lt;/li&gt;
  &lt;li&gt;자바 컴파일러(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;) 이 자바 소스코드(.java) 를 자바 바이트 코드(.class)로 컴파일 해준다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class Loader&lt;/code&gt; 가 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;에 올린다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;에 로딩 된 바이트 코드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Execution Engine&lt;/code&gt; 을 통해서 해석된다.&lt;/li&gt;
  &lt;li&gt;이 과정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Execution Engine&lt;/code&gt;에 의해 GC가 작동하고 쓰레드 동기화가 이루어진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jvm-메모리-구조&quot;&gt;&lt;em&gt;JVM 메모리 구조&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;JVM의 구체적인 수행과정에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/21_2.png&quot; alt=&quot;img2&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class Loader&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 로더는 JVM내로 클래스 파일(*.class)을 동적으로 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
    &lt;ul&gt;
      &lt;li&gt;.class 파일을 엮어서 JVM의 메모리 영역인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime Data Areas&lt;/code&gt; 에 배치한다.&lt;/li&gt;
      &lt;li&gt;Loading -&amp;gt; Linking -&amp;gt; Initalization 과정을 거친다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loading&lt;/code&gt; : 클래스 파일을 가져와서 JVM 메모리에 로드한다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linking&lt;/code&gt; : 클래스 파일을 사용하기 위해 검증한다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Initialization&lt;/code&gt; : 클래스 변수들을 적절한 값으로 초기화한다. (static 필드를 설정한 값으로 초기화, 등등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Execution Engine&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 로더를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime Data Areas&lt;/code&gt; 에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다. 기본적으로 인터프리터 방식을 사용해서 읽다가 일정 기준을 넘어가면 JLT 컴파일 방식으로 어셈블러 같은 네이티브 코드로 바꿔서 실행한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JTL&lt;/code&gt; : 바이트 코드 전체를 컴파일해서 네이티브 코드로 변경하고 이후 메서드를 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드로 변경하는 것도 비용이 있음으로 JVM은 모든 코드를  JLT 방식으로 실행하지는 않고 인터프리터 방식을 사용하다가  일정 기준을 넘어가면 JLT 컴파일러가 작동하는 방식을 사용한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interpreter&lt;/code&gt; : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행한다. 같은 메소드라도 여러번 호출이 된다면 매번 해석하고 수행해야 되서 전체적인 속도는 느린 편이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Garbage Collector&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GC는 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않는 객체들을 탐색해서 제거하는 역할을 한다. GC가 실행되는 시점은 정확하게 알 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수동으로 GC를 실행하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.gc()&lt;/code&gt; 를 호출할 수 있지만, 실제 함수 실행은 보장되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 나뉜다. Method Area, Heap Area는 모든 쓰레드가 공유하고 나머지는 각 쓰레드마다 생성되는 개별 영역이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/21_3.png&quot; alt=&quot;img3&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Method Area&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;모든 쓰레드가 공유하는 영역이다.&lt;/strong&gt; 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 저장한다.&lt;/li&gt;
  &lt;li&gt;JVM이 동작하고 클래스가 로드될 때 적재되서 프로그램 종료될 때까지 유지된다.&lt;/li&gt;
  &lt;li&gt;Class Area, Static Area 로도 불린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Heap Area&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/21_5.png&quot; alt=&quot;img3&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;마찬가지로 모든 쓰레드가 공유하며&lt;/strong&gt;, new 키워드로 생성된 객체와 배열이 생성되는 영역이다. 메소드 영역에 로드된 클래스만 생성이 가능하고 GC가 작동하는 영역이다.&lt;/li&gt;
  &lt;li&gt;Heap Area는  GC를 효율적으로 작동시키기 위해서 또 5가지 세부 영역으로 나뉜다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Young Generation&lt;/code&gt; : 생명 주기가 짧은 객체를 GC 대상으로 하는 영역
        &lt;ul&gt;
          &lt;li&gt;Suvivor 0 / Survivor 1 : 각 영역이 채워지게 되면, 살아남은 객체는 비워진 Survivor로 순차적으로 이동&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eden&lt;/code&gt; : new를 통해 새로 생성된 객체가 위치한다. 정기적인 GC후 살아남은 객체는 Survivor로 이동된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Old Generation&lt;/code&gt; : 생명 주기가 긴 객체를 GC 대상으로 하는 영역, Yuoung Generation에서 마지막까지 살아남은 객체가 들어온다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack Area&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메서드를 호출할 때마다 각각의 스택 프레임이 생성된다. 그리고 메서드 안에서 사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산할 때 생성되는 값들을 임시로 저장한다. 메서드 수행이 끝나면 프레임별로 삭제된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC Register&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쓰레드가 시작될 때 생성되는 공간으로 쓰레드마다 하나씩 존재한다. 쓰레드가 어떤 부분을 어떤 명령으로 실행해야 하는지에 대한 기록을 하는 부분이다. 현재 수행중인 JVM의 명령 주소를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Native method stack&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트-출처&quot;&gt;&lt;em&gt;참고 사이트 출처&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8&lt;/p&gt;

&lt;p&gt;https://steady-coding.tistory.com/305&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Java" /><category term="Java" /><category term="JVM" /><summary type="html"></summary></entry><entry><title type="html">[디자인패턴] MVC, MVP, MVVM 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/dpMVC/" rel="alternate" type="text/html" title="[디자인패턴] MVC, MVP, MVVM 패턴" /><published>2023-07-14T00:00:00+09:00</published><updated>2023-07-14T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/dpMVC</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/dpMVC/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvc-pattern&quot;&gt;&lt;em&gt;MVC Pattern&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;MVC 패턴이란 Model, View, Controller 로 이루어진 디자인패턴이다. M, V, C 역할을 분리해서 코드를 관리하기 때문에 유지보수가 편해지고 개발 효율성이 높아진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvc-구조&quot;&gt;&lt;em&gt;MVC 구조&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/19_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;용어&quot;&gt;용어&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model&lt;/code&gt; : 애플리케이션에서 사용되는 데이터와 이 데이터를 처리하는 부분이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt; : 사용자에게 보여지는 UI 부분이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; : 사용자의 입력을 받고 처리하는 부분이다.&lt;/p&gt;

&lt;h3 id=&quot;동작&quot;&gt;동작&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;사용자의 Action이 Controller로 들어온다.&lt;/li&gt;
  &lt;li&gt;Controller는 사용자의 Action을 확인하고, Model의 값을 update한다.&lt;/li&gt;
  &lt;li&gt;Controller 는 Model을 나타낼 View를 선택한다.&lt;/li&gt;
  &lt;li&gt;View는 Model을 활용해서 화면을 랜더링한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt; 가 update 되는 방법은 여러가지가 있다.
    &lt;ul&gt;
      &lt;li&gt;View가 Model을 이용해서 직접 update&lt;/li&gt;
      &lt;li&gt;Model에서 View에게 Nofity 하는 방법 (Observer Pattern)&lt;/li&gt;
      &lt;li&gt;View가 Polling으로 주기적으로 Model의 변경을 감지하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;특징&quot;&gt;특징&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt; 는 1:N 관계이다.&lt;/li&gt;
  &lt;li&gt;Controller는 View를 직접 update 하지 않고 View 도 Controller를 알지 못한다.&lt;/li&gt;
  &lt;li&gt;View와 Model 사이의 의존성이 높다. (단점)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvp-pattern&quot;&gt;&lt;em&gt;MVP Pattern&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;MVP 패턴은 Model, View, Presenter 로 이루어진 디자인패턴이다. Model, View는 MVC 패턴과 동일하지만, Controller 대신에 Presenter가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvp-구조&quot;&gt;&lt;em&gt;MVP 구조&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/19_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;용어-1&quot;&gt;용어&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt; : 사용자에게 보여지는 UI&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model&lt;/code&gt; : 애플리케이션에서 사용되는 데이터와 이 데이터를 처리하는 부분&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Presenter&lt;/code&gt; : View에서 요청한 정보를 Model을 가공하여 View에게 전달하는 부분, View와 Model을 연결하는 역할을 한다.&lt;/p&gt;

&lt;h3 id=&quot;동작-1&quot;&gt;동작&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;사용자의 Action이 View를 통해서 들어온다.&lt;/li&gt;
  &lt;li&gt;View는 데이터를 Presenter에게 요청&lt;/li&gt;
  &lt;li&gt;Presenter는 Model에게 데이터를 요청&lt;/li&gt;
  &lt;li&gt;Model은 Presenter에게 요청받은 데이터를 응답&lt;/li&gt;
  &lt;li&gt;Presenter가 View에게 데이터를 넘겨줌&lt;/li&gt;
  &lt;li&gt;View는 Presenter가 준 데이터를 사용해서 화면을 랜더링&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Presenter가 Model과 View의 인스턴스를 가지고 있고 이를 연결하는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Presenter와 View는 1:1 관계&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MVC 패턴의 문제였던 View와 Model 사이의 의존성 문제는 해결되었다. 그렇지만 View와 Presenter 사이의 의존성이 높아졌다. (장단)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvvm-pattern&quot;&gt;&lt;em&gt;MVVM Pattern&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;MVVM 패턴은 Model, View, View Model 로 이루어진 디자인패턴이다. Model, View는 동일하고 ViewModel이 새로 생겼다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvvm-구조&quot;&gt;&lt;em&gt;MVVM 구조&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/19_3.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;용어-2&quot;&gt;용어&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model&lt;/code&gt; : 애플리케이션에서 사용되는 데이터와 이 데이터를 처리하는 부분&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt; : 사용자에게 보이는 UI&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View Model&lt;/code&gt; : View를 표현하기 위해 등장한 View를 위한 Model, View를 나타내는 Model이자 여기에 필요한 데이터 처리를 하는 부분&lt;/p&gt;

&lt;h3 id=&quot;동작-2&quot;&gt;동작&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;사용자의 Action이 View를 통해 들어온다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Command 패턴으로 View Model에 Action을 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;View Model에서 Model에게 데이터를 요청&lt;/li&gt;
  &lt;li&gt;Model에서 데이터 응답&lt;/li&gt;
  &lt;li&gt;View Model에서 응답 데이터를 가공하여 저장&lt;/li&gt;
  &lt;li&gt;View는 View Model 데이터를 Binding하여 화면을 랜더링&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Command 패턴과 Binding 패턴이 사용되는 패턴이다.&lt;/li&gt;
  &lt;li&gt;View와 View Model 사이의 의존성을 제거했다. (장점)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;View Model : View는 1:N 관계이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;View Model의 설계가 쉽지 않다. (단점)&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><category term="CS" /><summary type="html"></summary></entry><entry><title type="html">[디자인패턴] 노출모듈 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/RevealingModule/" rel="alternate" type="text/html" title="[디자인패턴] 노출모듈 패턴" /><published>2023-07-14T00:00:00+09:00</published><updated>2023-07-14T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/RevealingModule</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/RevealingModule/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;revealing-module-pattern&quot;&gt;&lt;em&gt;Revealing Module Pattern&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;즉시 실행 함수를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; 과 같은 접근 제어자를 만든느 패턴이다.&lt;/p&gt;

&lt;p&gt;자바 스크립트에서는 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행된다. 때문에 접근 제어자를 사용하고 싶으면 노출모듈 패턴을 통해서 public, private 접근 제어자를 만들어서 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;그렇다면-즉시-실행-함수란-무엇일까&quot;&gt;&lt;em&gt;그렇다면 즉시 실행 함수란 무엇일까?&lt;/em&gt;&lt;/h1&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;function &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉시 실행함수는 선언과 동시에 바로 호출되는 함수이다. 재사용이 불가능하고 초기화, 라이브러리 전역 변수 충돌을 피하기 위해 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;접근-제어자&quot;&gt;&lt;em&gt;접근 제어자&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; : 클래스에서 정의된 함수, 자식, 외부 클래스 모두 접근 가능&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt; : 클래스에서 정의된 함수, 자식 클래스에서만 접근 가능&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt; : 클래스에 정의된 함수에서만 접근 가능&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;노출모듈-패턴-장단점&quot;&gt;&lt;em&gt;노출모듈 패턴 장단점&lt;/em&gt;&lt;/h1&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;깔끔한 접근 제어 방법 제공&lt;/li&gt;
  &lt;li&gt;private 데이터 제공&lt;/li&gt;
  &lt;li&gt;전역변수를 덜 더럽힌다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;private 메소드에 접근 방법이 없음&lt;/li&gt;
  &lt;li&gt;private 메소드에 대해 함수를 확장하는 게 어려움&lt;/li&gt;
  &lt;li&gt;private 메소드를 참조하는 public 메소드를 수정하기 어려움&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><category term="CS" /><summary type="html"></summary></entry></feed>