<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-08T15:40:16+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[운영체제] 좀비 프로세스 vs 고아 프로세스</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57/" rel="alternate" type="text/html" title="[운영체제] 좀비 프로세스 vs 고아 프로세스" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57/">&lt;p&gt;좀비 프로세스와 고아 프로세스를 이해하기 위해서 먼저 프로세스를 생성하는 과정을 좀 더 자세하게 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;프로세스-생성&quot;&gt;프로세스 생성&lt;/h1&gt;

&lt;p&gt;부모 프로세스는 시스템 콜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;를 통해서 자식 프로세스를 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;는 부모 프로세스의 주소 공간을 그대로 복사한다. 이 상태에서 시스템 콜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt;을 호출하게 되면 생성된 자식 프로세스의 메모리 공간을 새로운 프로그램으로 대체할 수 있다. 이러한 과정을 통해 부모와 다른 실행 흐름을 가진 자식 프로세스를 생성할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;자식-프로세스-트리&quot;&gt;자식 프로세스 트리&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/57_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리눅스에서는 커널이 자체적으로 생성한 init 프로세스가 있고 이후에 생성된 모든 프로세스는 init의 자손이 되며 트리구조를 이룬다.&lt;/p&gt;

&lt;p&gt;일단 모든 프로세스의 조상 프로세스는 커널이 생성한 init이라는 것만 기억하고 넘어가자. (아래에 설명하겠다.)&lt;/p&gt;

&lt;h2 id=&quot;실행-흐름&quot;&gt;실행 흐름&lt;/h2&gt;

&lt;p&gt;위에서 자식 프로세스를 생성하는 방법을 설명했다. 그렇다면 이렇게 생성된 자식 프로세스와 부모 프로세스는 어떤 방식으로 실행될 수 있을까?&lt;/p&gt;

&lt;p&gt;결론부터 말하자면 2가지 흐름이 있을 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 프로세스가 자식 프로세스의 종료까지 기다리고 이후에 실행한다.&lt;/li&gt;
  &lt;li&gt;부모 프로세스와 자식 프로세스를 동시에 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1번-케이스&quot;&gt;1번 케이스&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/57_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우는 부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하여 자식 프로세스의 종료를 기다린다. 그리고 자식 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;을 호출하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;의 파라미터로 자식 프로세스의 상태가 들어오게 되는데 이를 통해서 자식 프로세스가 사용하던 자원을 모두 반납한다.&lt;/p&gt;

&lt;p&gt;이 경우는 별다른 문제가 없는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2번-케이스&quot;&gt;2번 케이스&lt;/h3&gt;

&lt;p&gt;이 케이스는 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않는다. 부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않는다면 어떤 일이 생길까?&lt;/p&gt;

&lt;p&gt;이제 좀비 프로세스와 고아 프로세스가 등장한다.&lt;/p&gt;

&lt;h2 id=&quot;좀비-프로세스&quot;&gt;좀비 프로세스&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;좀비 프로세스는 자식 프로세스가 부모 프로세스보다 먼저 종료된 프로세스를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정의만 보면 무슨말인지 잘 이해가 안될 것이다. 자식 프로세스가 종료되면 종료된 것 아닌가?&lt;/p&gt;

&lt;p&gt;여기서 주목해야 하는 점은 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 을 호출하지 않았다는 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않았기 때문에 자식 프로세스가 종료되더라도 종료에 대한 정보가 부모 프로세스에 전달되지 못하고 사용하던 리소스를 반납할 방법이 없어진다.&lt;/p&gt;

&lt;p&gt;종료되도 리소스가 계속 남아있기 때문에 &lt;strong&gt;좀비 프로세스&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;커널은 이런 상황을 대비하여 프로세스에 대한 최소한의 정보를 저장하고 있다. 이후에 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하여 남아있는 리소스를 제거할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;고아-프로세스&quot;&gt;고아 프로세스&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;고아 프로세스는 부모 프로세스가 자식 프로세스보다 먼저 종료된 프로세스를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 경우도 좀비 프로세스 경우와 마찬가지로 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않은 경우에 발생한다.&lt;/p&gt;

&lt;p&gt;부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않고 자신의 로직을 수행하다 자식 프로세스보다 먼저 종료되면 자식 프로세스는 종료됐을 때 리소스를 반납해줄 주체가 없어진다. 이렇게 부모가 없이 남겨진 프로세스를 &lt;strong&gt;고아 프로세스&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;이렇게 부모가 사라진 경우 고아 프로세스는 위에서 설명한 init 프로세스의 자식 프로세스가 된다. init 프로세스는 이 프로세스가 종료되면 리소스를 회수하고 정상적으로 프로세스를 제거한다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;좀비 프로세스 : 부모가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않은 상태에서 자식 프로세스가 종료되어 리소스를 반납하지 못하는 프로세스&lt;/p&gt;

&lt;p&gt;고아 프로세스 : 부모가 먼저 종료되서 남겨진 프로세스&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://itstory1592.tistory.com/89&quot;&gt;https://itstory1592.tistory.com/89&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">좀비 프로세스와 고아 프로세스를 이해하기 위해서 먼저 프로세스를 생성하는 과정을 좀 더 자세하게 알아보자.</summary></entry><entry><title type="html">[운영체제] 프로세스</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56/" rel="alternate" type="text/html" title="[운영체제] 프로세스" /><published>2023-12-27T00:00:00+09:00</published><updated>2023-12-27T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56/">&lt;h1 id=&quot;프로세스&quot;&gt;프로세스&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스는 컴퓨터에서 실행 중인 프로그램을 말한다. 프로그램이 메모리에 올라가면 프로세스가 되고 CPU에 의해서 프로세스가 실행된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;각 프로세스는 서로 완전히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않는다. 때문에 한 프로세스에서 오류가 발생하더라도 다른 프로세스에 영향을 주지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;상태&quot;&gt;상태&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;new&quot;&gt;new&lt;/h3&gt;

&lt;p&gt;프로세스가 생성된 상태&lt;/p&gt;

&lt;h3 id=&quot;ready&quot;&gt;ready&lt;/h3&gt;

&lt;p&gt;프로세스가 CPU 할당을 기다리고 있는 상태&lt;/p&gt;

&lt;p&gt;CPU만 받으면 바로 실행할 수 있는 상태이다.&lt;/p&gt;

&lt;h3 id=&quot;running&quot;&gt;running&lt;/h3&gt;

&lt;p&gt;프로세스가 CPU를 할당 받아서 명령어를 실행하고 있는 상태이다.&lt;/p&gt;

&lt;h3 id=&quot;waiting&quot;&gt;waiting&lt;/h3&gt;

&lt;p&gt;프로세스가 이벤트가 발생할 때까지 대기하고 있는 상태&lt;/p&gt;

&lt;h3 id=&quot;terminated&quot;&gt;terminated&lt;/h3&gt;

&lt;p&gt;프로세스가 종료된 상태&lt;/p&gt;

&lt;p&gt;프로세스가 소유한 모든 자원을 반납하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-구조&quot;&gt;메모리 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드-영역-code&quot;&gt;코드 영역 (code)&lt;/h3&gt;

&lt;p&gt;실행할 프로그램의 코드가 저장되는 영역이다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서(fetch) 실행(execution)한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-영역-data&quot;&gt;데이터 영역 (data)&lt;/h3&gt;

&lt;p&gt;전역변수, 정적변수가 저장되는 영역으로 프로그램이 시작될 때 할당되며 프로그램이 종료할 때 소멸한다.&lt;/p&gt;

&lt;h3 id=&quot;힙-영역-heap&quot;&gt;힙 영역 (heap)&lt;/h3&gt;

&lt;p&gt;메모리 공간이 동적으로 할당되고 헤제되는 영역이다.&lt;/p&gt;

&lt;p&gt;낮은 주소에서 높은 주소로 채워진다.&lt;/p&gt;

&lt;h3 id=&quot;스택-영역-stack&quot;&gt;스택 영역 (stack)&lt;/h3&gt;

&lt;p&gt;함수 호출에 따른 지역변수와 매개변수가 저장되는 영역이다. 함수가 호출될 때마다 호출될 떄의 환경 등 특정 정보가 스택에 계속 저장된다.&lt;/p&gt;

&lt;p&gt;높은 주소에서 낮은 주소로 채워진다.&lt;/p&gt;

&lt;h4 id=&quot;힙과-스택의-차이&quot;&gt;힙과 스택의 차이&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pcb&quot;&gt;PCB&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;PCB는 프로세스 제어 블록으로 프로세스를 관리하기 위한 정보를 포함하는 운영체제 커널의 자료구조이다. 프로세스의 중요한 정보를 저장하고 있기 때문에 보호된 메모리에 저장된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;구조&quot;&gt;구조&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로세스 식별자&lt;/strong&gt; :  프로세스 식별변호&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스 상태&lt;/strong&gt; : new, ready, running, wating, terminated 등의 상태를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그램 카운터 (PC)&lt;/strong&gt; : 프로세스가 다음에 실행할 명령어의 주소를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 레지스터&lt;/strong&gt; : 프로세스를 실행하기 위해 저장해야 할 레지스터 정보&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 스케줄링 정보&lt;/strong&gt; : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;계정 정보&lt;/strong&gt; : 프로세스 실행에 사용된 CPU 사용량, 실행 유저 정보&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메모리 관리 정보&lt;/strong&gt; : 페이지, 세그먼트 테이블 등과 같은 정보를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O 상태 정보&lt;/strong&gt; : 프로세스에 할당된 I/O 디바이스 목록&lt;/p&gt;

&lt;h2 id=&quot;멀티-프로세싱&quot;&gt;멀티 프로세싱&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러 개의 프로세스를 통해서 병렬적으로 작업을 수행하는 것을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;프로세스끼리는 메모리를 공유하지 않기 때문에 하나의 프로세스에 문제가 발생하더라도 다른 프로세스에 영향을 끼치지 않는다.&lt;/p&gt;

&lt;p&gt;하지만 멀티 스레드 방식보다 많은 양의 메모리 공간과 CPU를 차지한다는 단점이 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Operating System Concepts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;면접을 위한 CS 전공지식 노트&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">프로세스</summary></entry><entry><title type="html">[Spring] Spring Security (진행중)</title><link href="http://localhost:4000/spring/55/" rel="alternate" type="text/html" title="[Spring] Spring Security (진행중)" /><published>2023-12-21T00:00:00+09:00</published><updated>2023-12-21T00:00:00+09:00</updated><id>http://localhost:4000/spring/55</id><content type="html" xml:base="http://localhost:4000/spring/55/">&lt;h1 id=&quot;스프링-시큐리티&quot;&gt;스프링 시큐리티&lt;/h1&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;애플리케이션을 개발함에 있어서 보안은 굉장히 중요한 이슈이다. 보안이 뚫리게 되면 단순히 데이터, 돈을 잃는 것을 넘어서 수년간 쌓아온 브랜드 평판과 유저로부터의 신뢰를 한번에 잃을 수 있다. 그렇다고 애플리케이션을 만들때마다 자체 보안 시스템을 만드는 것은 매우 비효율적이다. 기능적으로 문제가 발생할 위험도 있고 많은 시간과 돈이 들어간다. 스프링은 이런 문제를 해결해주기 위해 스프링 시큐리티라는 스프링 하부 프레임워크를 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;흐름&quot;&gt;흐름&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 가장 기본적인 Security의 흐름을 보여준다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;클라이언트로부터 HTTP 요청이 들어오면 Spring Security의 필터가 이를 가로챈다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;요청에 들어있는 유저의 아이디, 패스워드를 추출하여 Authentication을 구현한 UsernamePasswordAuthenticationToken을 생성하고 AuthenticationManager를 구현한 ProviderManager의 authenticate()메서드를 호출하며 이를 넘겨준다.&lt;/li&gt;
  &lt;li&gt;ProviderManager는 모든 AuthenticationProvider를 순차적으로 호출하여 인증을 수행한다.&lt;/li&gt;
  &lt;li&gt;AuthenticationProvider에서는 UserDetailService/UserDetailManager와 PasswordEncoder의 도움을 받아 인증을 수행하며 Authentication 객체를 반환한다.&lt;/li&gt;
  &lt;li&gt;인증에 성공하게 되면 AuthenticationManager는 Authentication 객체를 반환하고 필터에서 이를 받아 SecurityContextHolder 내부의 Context에 인증 객체를 저장하게 된다.&lt;/li&gt;
  &lt;li&gt;만약 실패하게 되면 AuthenticationManager는 또 다른 AuthenticationProvider를 호출하여 위 과정을 계속 반복하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 각각의 역할에 대해서 더 자세하게 알아보자&lt;/p&gt;

&lt;h2 id=&quot;spring-security-filter&quot;&gt;Spring Security Filter&lt;/h2&gt;

&lt;h3 id=&quot;defaultloginpagegeneratorfilter&quot;&gt;DefaultLoginPageGeneratorFilter&lt;/h3&gt;

&lt;p&gt;스프링 시큐리티 의존성을 추가하고 우리의 서비스에 접근하려고 하면 아래와 같은 로그인 페이지로 넘어가지는 경험을 해봤을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 로그인 기능을 구현한 필터가 바로 DefaultLoginPageGeneratorFilter이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요청으로부터 로그인 정보를 확인하여 로그인을 하지 않은 상태라면 위와 같은 로그인 페이지를 만든다. 실질적으로 로그인 페이지를 만드는 로직은 generateLoginPageHtml()메서드 안에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한땀한땀 html 코드가 작성되어 있는 것을 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;usernamepasswordauthenticationfilter&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 UsernamePasswordAuthenticationFilter이다. 코드를 보면 request로부터 유저의 아이디, 패스워드를 추출하고 Authentication을 구현한 UsernamePasswordAuthenticationToken을 생성하는 것을 볼 수 있다. 그리고 AuthenticationManager의 authenticate() 메서드를 호출하며 이를 넘기는 것을 볼 수 있다. 그렇다면 이 UsernamePasswordAuthenToken의 정체는 무엇일까?&lt;/p&gt;

&lt;p&gt;아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/55_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Authentication 객체는 현재 요청하고 있는 주체의 정보가 들어있다. 이 객체는 SecurityContextHolder 안의 ContextHolder에 실질적으로 저장되는 유저의 정보이기도 하다. 뜬금없이 Authentication에 대해서 설명한 이유는 UsernamePasswordAuthenticationToken이 authentication을 구현한 클래스이기 때문이다. (실제로는 AbstractAuthenticationToken을 상속받는데 이 추상 클래스가 Authentication을 구현하고 있다.)&lt;/p&gt;

&lt;h3 id=&quot;usernamepasswordauthenticationtoken&quot;&gt;UsernamePasswordAuthenticationToken&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UsernamePasswordAuthenticationToken을 보면 두 개의 생성자가 있는 것을 볼 수 있다. 위 생성자는 내부에서 setAuthenticated(false)로 인증 실패 상태를 넣는 것을 볼 수 있고 아래는 true를 넣어 성공 상태를 넣는다. 우리가 위에서 설명한 UsernamePasswordAuthenticationFilter 내부에서는 첫번째 생성자를 이용하여 객체를 생성한다.&lt;/p&gt;

&lt;p&gt;그렇다면 두번째 생성자는 언제 사용될까? AuthenticationProvider에서 실질적인 인증을 수행한 후 인증에 성공하면 Authentication 객체를 반환하는데 이 때 두번째 생성자를 사용하게 된다.&lt;/p&gt;

&lt;p&gt;다음으로 AuthenticationManager에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;authenticationmanager&quot;&gt;AuthenticationManager&lt;/h2&gt;

&lt;p&gt;AuthenticationManager는 인터페이스이고 단 하나의 메소드 authenticate()를 정의하고 있다. AuthenticationManager를 구현한 ProviderManager내부의 authenticate() 메서드 내부를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 반복문을 활용하여 가지고 있는 모든 Provider를 활용하여 인증을 시도한다. 모든 Provider에 대해서 인증이 실패하면 실패 Authentication 객체를 반환하고 성공하&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Spring" /><category term="Spring" /><category term="Security" /><summary type="html">스프링 시큐리티</summary></entry><entry><title type="html">[디자인패턴] 커맨드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/" rel="alternate" type="text/html" title="[디자인패턴] 커맨드 패턴" /><published>2023-12-10T00:00:00+09:00</published><updated>2023-12-10T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/">&lt;h1 id=&quot;커맨드-패턴&quot;&gt;커맨드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요구사항(요청, 명령)을 객체로 캡슐화하여 서로 다른 요구사항을 가진 클라이언트를 매개변수화시킬 수 있고 요구사항을 큐에 넣어 로그를 남기거나 작업을 취소할 수 있는 기능을 가능하게 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;invoker&quot;&gt;Invoker&lt;/h3&gt;

&lt;p&gt;요청을 받고 이를 실행시키는 역할을 수행한다. Command 인터페이스만 알고 있으며 실제로 Command가 어떻게 실행되는지는 알지 못한다.&lt;/p&gt;

&lt;h3 id=&quot;command&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt; 메소드를 선언한다.&lt;/p&gt;

&lt;h3 id=&quot;concretecommand&quot;&gt;ConcreteCommand&lt;/h3&gt;

&lt;p&gt;Command 인터페이스를 구현하며 맴버 변수로 Receiver를 가지고 있다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Receiver 메소드를 호출하여 로직이 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;receiver&quot;&gt;Receiver&lt;/h3&gt;

&lt;p&gt;실제 명령이 실행되는 부분이다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;h4 id=&quot;1-실제로-실행하는-객체receiver와-실행을-요청하는-객체invoker를-분리하여-결합도를-낮춘다&quot;&gt;1. 실제로 실행하는 객체(Receiver)와 실행을 요청하는 객체(Invoker)를 분리하여 결합도를 낮춘다.&lt;/h4&gt;

&lt;p&gt;Invoker는 Reciver를 알지 못한 채로 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드를 통해 실행을 하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-기존의-코드를-수정하지-않고도-새로운-명령을-추가할-수-있다-ocp-원칙&quot;&gt;2. 기존의 코드를 수정하지 않고도 새로운 명령을 추가할 수 있다. (OCP 원칙)&lt;/h4&gt;

&lt;p&gt;새로운 명령이 추가되도 Invoker를 수정하지 않고 Revicer와  Command만 구현하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;h4 id=&quot;1-새로운-명령이-생길때마다-클래스가-추가되기-때문에-코드-복잡성이-증가할-수-있다&quot;&gt;1. 새로운 명령이 생길때마다 클래스가 추가되기 때문에 코드 복잡성이 증가할 수 있다.&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 이제 예제를 보면서 이해해보자!&lt;/p&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;다음과 같은 기능을 가진 리모컨을 생각해보자.&lt;/p&gt;

&lt;h3 id=&quot;리모컨-기능&quot;&gt;리모컨 기능&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;전등  ON/OFF&lt;/li&gt;
  &lt;li&gt;TV ON/OFF&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 표현하기 위해서는 리모컨, 전등, TV 클래스가 필요할 것이다. 아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;remote-class&quot;&gt;Remote Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리모컨 클래스이다. 불끄기, 불켜기, Tv켜기, Tv끄기 메소드를 가진다.&lt;/p&gt;

&lt;h3 id=&quot;light--tv-class&quot;&gt;Light &amp;amp; Tv Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 이 상황에서 새로운 요구사항이 생겼다고 가정해보자.&lt;/p&gt;

&lt;h4 id=&quot;추가된-요구사항&quot;&gt;추가된 요구사항&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;리모컨을 통해 프로젝트를 켜고 끄는 기능을 추가해주세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 만족시키기 위해서는 Remote 클래스에 맴버 변수로 Project를 추가하고 Project를 켜고 끄는 메소드를 추가해야 한다. 이는 기존 코드인 Remote를 수정하는 것이기 때문에 OCP를 위반하게 된다. 커맨드 패턴을 적용하면 요청을 호출하는 Remote 클래스와 실제 실행이 되는 Tv, Light 클래스 사이의 결합도를 낮추고 새로운 요구사항(프로젝트 Up/Down)이 생겼을 때 기존 코드(Remote 클래스)를 손보지 않고 기능을 추가할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;코드를 통해서 확인해보자!&lt;/p&gt;

&lt;h3 id=&quot;커맨드-패턴을-적용한-코드&quot;&gt;커맨드 패턴을 적용한 코드&lt;/h3&gt;

&lt;h3 id=&quot;command-1&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령을 추상화한 Command 인터페이스이다.&lt;/p&gt;

&lt;h3 id=&quot;project-receiver&quot;&gt;Project (Receiver)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 추가된 명령을 수행하는 Project 클래스이다. 위의 클래스 다이어그램에서 설명했던 Receiver 역할을 수행하는 클래스이다.&lt;/p&gt;

&lt;p&gt;앞서 봤던 Light, Tv도 모두 Receiver이다. (Light, Tv는 코드가 동일하니 위의 코드를 참고하자.)&lt;/p&gt;

&lt;h3 id=&quot;lightoncommandlightoffcommand-concrete-command&quot;&gt;LightOnCommand/LightOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Command 인터페이스를 구현하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Light(Receiver)의 메소드를 호출한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Remote 클래스(Invoker)와 Light 클래스(Receiver) 사이의 결합도를 낮추게 된다.&lt;/p&gt;

&lt;h3 id=&quot;tvoncommandtvoffcommand-concrete-command&quot;&gt;TvOnCommand/TvOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 설명한 Light의 경우와 완전히 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;projectoncommandprojectoffcommand-concrete-command&quot;&gt;ProjectOnCommand/ProjectOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 Light, Tv와 완전히 동일하니 설명은 생략한다.&lt;/p&gt;

&lt;h3 id=&quot;remote-invoker&quot;&gt;Remote (Invoker)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remote 클래스는 Command 인터페이스에만 의존한다. 때문에 실제로 각 ConcreteCommand가 어떤 Recevier를 호출하는지 알지 못한다.&lt;/p&gt;

&lt;p&gt;커맨드를 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setCommand()&lt;/code&gt;, On/Off 버튼을 누르는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onButtonPush()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offButtonPush()&lt;/code&gt;메소드를 가지고 있다.&lt;/p&gt;

&lt;p&gt;이 함수 내부에서는 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 새로운 기능을 추가함에 있어서 기존 코드를 수정할 필요가 없다 (OCP원칙). 그저 새로운 Receiver (여기서는 Project)와 ConcreteCommand(ProjectOnCommand, ProjectOffComand)만 새로 만들면 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;커맨드 패턴을 사용하면 실행을 요청하는 객체와 실제 실행하는 객체 사이의 결합도를 낮출 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 새로운 요구사항이 발생해도 유연하게 대처할 수 있다. 하지만 관리해야 하는 객체의 수가 늘어나기 때문에 무분별한 사용은 코드의 복잡도를 증가시킬 수 있다.&lt;/p&gt;

&lt;p&gt;무작정 적용하기보다는 꼭 필요한 곳에만 사용하도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">커맨드 패턴</summary></entry><entry><title type="html">[디자인패턴] 어댑터 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51/" rel="alternate" type="text/html" title="[디자인패턴] 어댑터 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51/">&lt;h1 id=&quot;어댑터-패턴&quot;&gt;어댑터 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Convert the interface of a class into another interface clients expect. 
Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어댑터 패턴(Adapter Pattern)은 클래스의 인터페이스를 클라이언트가 원하는 형태의 또 다른 인터페이스로 변환해준다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;클라이언트 입장에서는 새로운 기능을 사용하기 위해 Adaptee의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specificRequest()&lt;/code&gt; 써야 되는데 기존에 사용하던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request()&lt;/code&gt;로 접근하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;target&quot;&gt;Target&lt;/h3&gt;

&lt;p&gt;기존에 사용하던 인터페이스라고 생각하면 된다. 새로운 인터페이스(Adaptee)를 어댑터를 사용해서 Target인터페이스를 사용하듯이 하는 것이 목표이다.&lt;/p&gt;

&lt;h3 id=&quot;adapter&quot;&gt;Adapter&lt;/h3&gt;

&lt;p&gt;새로운 인터페이스인 Adaptee를 기존에 사용하던 Target인터페이스처럼 사용할 수 있도록 변환해주는 역할을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;adaptee&quot;&gt;Adaptee&lt;/h3&gt;

&lt;p&gt;새로운 인터페이스로 기존에 사용하던 Target인터페이스와 다르다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;어댑터 패턴을 사용함으로써 기존 클래스를 수정하지 않고도 클라이언트에서 새로운 인터페이스를 사용할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;어댑터 클래스를 새로 작성해야 하기 때문에 소스 코드가 늘어나고 코드의 복잡도가 늘어난다.&lt;/p&gt;

&lt;p&gt;어댑터가 중간에 데이터를 변환하는 과정에서 추가적인 처리 시간과 오버헤드가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 회사의 시스템이 있다고 해보자. 그런데 새로운 기능을 구현하기 위해 다른 업체에서 제공하는 클래스 라이브러리를 사용해야 하는 상황이 생겼다.&lt;/p&gt;

&lt;p&gt;이 상황에서 만약 기존 시스템의 인터페이스와 새로운 업체에서 사용하는 인터페이스가 다르면 호환성 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;이때 어댑터 패턴을 사용하면 이를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;우리는 핸드폰을 사용하고 있다. 이 핸드폰은 두 가지 기능이 있는데 화면을 보여주는 기능과 전원을 종료하는 기능이다.&lt;/p&gt;

&lt;p&gt;이를 코드로 나타내보면 아래와 같다.&lt;/p&gt;

&lt;h4 id=&quot;phone-class-target&quot;&gt;Phone Class (Target)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_3.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;galaxy-phone의-구현-객체&quot;&gt;Galaxy (Phone의 구현 객체)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_4.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;화면 보여주는 기능 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;전원을 종료하는 기능 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutDown()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 상황에서 태블릿 기기를 선물 받았다고 해보자.&lt;/p&gt;

&lt;p&gt;태블릿 클래스 코드는 아래와 같다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tablet-adaptee&quot;&gt;Tablet (Adaptee)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_5.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 우리는 태블릿 기기를 사용하려면 여러가지 기능을 새로 배워야 한다.&lt;/p&gt;

&lt;p&gt;그래서 우리는 태블릿을 기존에 사용하던 핸드폰과 동일한 인터페이스로 사용할 수 있도록 어댑터를 장착하기로 결정했다!&lt;/p&gt;

&lt;h3 id=&quot;phoneadapter-adapter&quot;&gt;PhoneAdapter (Adapter)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_6.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PhoneAdapter클래스는 Phone을 구현하고 내부적으로 Tablet을 맴버 변수로 가지고 있다.&lt;/p&gt;

&lt;p&gt;기존에 사용하던 Phone인터페이스를 구현하는 것은 같은데 내부적으로는 Tablet의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;메소드를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 우리(Client)는 Tablet클래스를 사용할 때 기존에 사용하던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutDown()&lt;/code&gt;을 통하여 접근할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;어댑터 패턴은 인터페이스 사이에 유연성이 필요한 상황에 효율적으로 사용될 수 있는 디자인 패턴이다.&lt;/p&gt;

&lt;p&gt;하지만 코드의 복잡도가 발생할 수 있고 추가적인 오버헤드가 생길 수 있기 때문에 적절한 상황에만 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://yozm.wishket.com/magazine/detail/2077/&quot;&gt;요즘IT&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">어댑터 패턴</summary></entry><entry><title type="html">[디자인패턴] 상태 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53/" rel="alternate" type="text/html" title="[디자인패턴] 상태 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53/">&lt;h1 id=&quot;상태-패턴&quot;&gt;상태 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;객체 내부의 상태가 바뀔 때, 객체의 동작을 변경할 수 있도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;context&quot;&gt;Context&lt;/h3&gt;

&lt;p&gt;여러 상태가 존재하는 시스템을 말한다. 시스템은 상태를 나타내는 State를 가지고 있으며 클라이언`로부터 요청을 받으면  State에 실행을 위임한다.&lt;/p&gt;

&lt;h3 id=&quot;state&quot;&gt;State&lt;/h3&gt;

&lt;p&gt;상태를 추상화한 인터페이스이다.&lt;/p&gt;

&lt;p&gt;ConcreteStatus는 이를 구현하여 구체적인 상태를 나타내게 된다.&lt;/p&gt;

&lt;h3 id=&quot;concretestatus&quot;&gt;ConcreteStatus&lt;/h3&gt;

&lt;p&gt;구체적인 상태를 나타내는 클래스이다.&lt;/p&gt;

&lt;p&gt;맴버 변수로 Context를 가지고 있으며 연산에 따라 Context의 상태를 변경한다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;아래와 같은 상태가 존재하는 &lt;strong&gt;뽑기 기계&lt;/strong&gt;를 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뽑기 기계는 상태( 동전 투입 여부, 알맹이 개수)에 따라 동작 방식이 달라진다.&lt;/p&gt;

&lt;p&gt;이를 구현하기 위해서는 &lt;strong&gt;분기 처리&lt;/strong&gt;를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;만약 여기서 새로운 요구사항이 생기면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;예를 들어서 5번에 한 번마다 알맹이가 2개가 나오게 변경한다고 생각해보자.&lt;/p&gt;

&lt;p&gt;그러면 우리는 5번째인지 확인하기 위해 조건문을 모든 메소드에 추가해야 한다.&lt;/p&gt;

&lt;p&gt;매번 요구사항이 추가될 때마다 기존 코드를 변경해야 하는 것은 유지보수 측면에서 좋지 않다. 이를 해결하는 방법 중 하나가 &lt;strong&gt;상태 패턴&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;상태 패턴을 사용하게 되면 상태에 따른 동작을 클래스로 관리할 수 있게 되고 코드의 복잡도도 줄일 수 있게 된다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 상태 패턴의 필요성에 대해서 봤으니 이제 상태 패턴의 장단점에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;상태에 따른 객체의 동작을 클래스로 관리할 수 있게 된다.&lt;/li&gt;
  &lt;li&gt;상태에 관련된 동작을 각 클래스로 분산시켜 코드의 복잡도를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;새로운 요구사항이 생겨서 변경이 발생하더라도 기존의 코드를 그대로 유지할 수 있다. (OCP원칙)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;상태별로 클래스로 관리해야 하기 때문에 클래스의 수가 증가한다.&lt;/li&gt;
  &lt;li&gt;객체의 상태가 몇 개 없거나 상태가 거의 변경되지 않는 경우에 상태 패턴을 적용하는 것은 &lt;strong&gt;오버엔지니어링&lt;/strong&gt;일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;위에 필요성에서 설명했던 예제인 &lt;strong&gt;뽑기 기계&lt;/strong&gt;를 가지고 상태 패턴을 이해해보자.&lt;/p&gt;

&lt;p&gt;먼저 뽑기 기계의 상태에 대해서 생각해보자. 아래와 같이 4가지 상태가 존재할 것이다.&lt;/p&gt;

&lt;h4 id=&quot;sold_out&quot;&gt;SOLD_OUT&lt;/h4&gt;

&lt;p&gt;머신의 알맹이가 다 떨어진 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;no_coin&quot;&gt;NO_COIN&lt;/h4&gt;

&lt;p&gt;동전이 투입되지 않은 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;has_coin&quot;&gt;HAS_COIN&lt;/h4&gt;

&lt;p&gt;동전이 투입된 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;sold&quot;&gt;SOLD&lt;/h4&gt;

&lt;p&gt;손잡이를 돌려서 알맹이가 나오고 있는 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;그리고 이런 상태에 4가지 행위가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;뽑기 기계에 코인을 넣는 행위&lt;/li&gt;
  &lt;li&gt;뽑기 기계에서 알맹이를 뽑는 행위&lt;/li&gt;
  &lt;li&gt;뽑기 기계에서 동전을 반환하는 행위&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;-&amp;gt; 이제 이를 상태 패턴 없이 코드로 작성해보겠다.&lt;/p&gt;

&lt;h3 id=&quot;machine-class&quot;&gt;Machine Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상태에 따른 동작을 &lt;strong&gt;분기 처리&lt;/strong&gt;를 통해서 구현했다.&lt;/p&gt;

&lt;p&gt;그리고 각 상태(SOLD_OUT, SOLD, HAS_COIN, NO_COIN)를 상태 변수로 처리했다.&lt;/p&gt;

&lt;p&gt;하지만 이 코드에는 여러 단점이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상태 전환을 하기 위해 조건 분기를 해야 한다. 이는 가독성에 좋지 않다.&lt;/li&gt;
  &lt;li&gt;상태에 따른 추가 요구사항이 생기면 메소드를 다 수정해야 한다. &lt;strong&gt;OCP&lt;/strong&gt;를 위반하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그렇다면 이제 상태 패턴을 적용하여 이러한 단점을 보안해보자.&lt;/p&gt;

&lt;p&gt;여기서는 상태 패턴 + 싱글톤 패턴을 같이 적용한 코드를 볼 것이다.&lt;/p&gt;

&lt;p&gt;싱글톤 패턴을 적용한 이유는 상태를 변경할 때마다 새로운 객체를 생성하게 되면 &lt;strong&gt;메모리 낭비&lt;/strong&gt;가 발생하기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;상태-패턴--싱글톤-패턴-적용&quot;&gt;상태 패턴 + 싱글톤 패턴 적용&lt;/h3&gt;

&lt;h4 id=&quot;machine-context&quot;&gt;Machine (Context)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Machine 클래스는 맴버 변수로 상태를 가지고 있다. 그리고 동전 넣기, 동전 반환, 손잡이 돌리기, 뽑기라는 4가지 행위를 가진다.&lt;/p&gt;

&lt;p&gt;각각의 행위는 State에 위임되며 현재 Machine의 상태에 따라 다르게 동작하게 된다.&lt;/p&gt;

&lt;p&gt;그리고 동작이 일어나고 상황에 맞게 State가 변경될 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;state-state&quot;&gt;State (State)&lt;/h4&gt;

&lt;h4&gt;&lt;img src=&quot;/assets/images/53_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/h4&gt;

&lt;p&gt;상태를 추상화한 인터페이스이다.&lt;/p&gt;

&lt;h4 id=&quot;nocoinstate-concretestate&quot;&gt;NoCoinState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동전이 없는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;p&gt;싱글톤 패턴을 적용하였는데 만약 싱글톤 패턴을 적용하지 않았다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertCoin(Machine machine)&lt;/code&gt; 에서 머신의 상태를 변경할 때, 새로운 객체를 생성해서 넘겼어야 했을 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 상태가 변할때마다 객체가 생성되기 때문에 효율적이지 않다.&lt;/p&gt;

&lt;p&gt;물론  &lt;strong&gt;GC&lt;/strong&gt;가 주기적으로 정리해주긴 하지만 이러한 쓰레기가 늘어나게 되면 제거 과정에서 &lt;strong&gt;Stop-the-world&lt;/strong&gt;가 발생하여 프로그램이 느려질 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;hascoinstate-concretestate&quot;&gt;HasCoinState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_11.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_12.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동전이 들어있는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;p&gt;동전이 들어있을 때는 동전 반환, 손잡이 돌리기를 수행하면 상태가 변하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;soldoutstate-concretestate&quot;&gt;SoldOutState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_13.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_14.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;알맹이가 떨어진 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;h4 id=&quot;soldstate-concretestate&quot;&gt;SoldState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_15.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_16.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;알맹이가 나가고 있는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;상태 패턴은 상태를 객체화하여 객체의 행동을 상태에 특화된 행위들로 분리할 수 있다.&lt;/p&gt;

&lt;p&gt;상태에 따라 행위가 달라진다면 상태 패턴을 고려해보면 좋을 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%83%81%ED%83%9CState-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">상태 패턴</summary></entry><entry><title type="html">[디자인패턴] 퍼사드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52/" rel="alternate" type="text/html" title="[디자인패턴] 퍼사드 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52/">&lt;h1 id=&quot;퍼사드-패턴&quot;&gt;퍼사드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.&lt;/p&gt;

  &lt;p&gt;Wrap a complicated subsystem with a simpler interface.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;퍼사드 패턴은 서브 시스템에 있는 여러 개의 인터페이스를 통합하여 하나의 인터페이스를 제공한다.&lt;/p&gt;

&lt;p&gt;복잡한 서브 시스템을 사용하기 쉽게 고수준의 인터페이스를 정의하는 패턴이다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;클라이언트는 서브 시스템에 바로 접근할 수도 있고 Facade를 통해서 서브 시스템의 기능을 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;facade&quot;&gt;Facade&lt;/h3&gt;

&lt;p&gt;서브 시스템 기능을 묶은 고수준의 인터페이스이다. 이를 통해서 클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;additional-facade&quot;&gt;Additional Facade&lt;/h3&gt;

&lt;p&gt;Facade가 하나라는 규칙은 존재하지 않는다. 다양한 서브 시스템을 묶어서 새로운 Facade를 만들수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 묶인 Facade는 다른 Facade에 포함될 수도 있고 클라이언트에서 바로 사용될 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;subsystem&quot;&gt;SubSystem&lt;/h3&gt;

&lt;p&gt;여러개의 서브 클래스를 나타낸다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;그렇다면 퍼사드 패턴은 언제 사용하면 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;1-시스템이-복잡할-때&quot;&gt;1. 시스템이 복잡할 때&lt;/h4&gt;

&lt;p&gt;시스템이 굉장히 복잡한 경우를 생각해보자. 이런 경우 서브 시스템의 인터페이스를 하나씩 사용하여 로직을 구성해야 하는데 굉장히 복잡할 수 있다.&lt;/p&gt;

&lt;p&gt;이때 퍼사드 패턴을 사용하면 복잡한 서브 시스템 호출을 내부에 감추면서 고수준의 인터페이스 하나로 사용할 수 있게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-의존성을-낮추고-싶을-때&quot;&gt;2. 의존성을 낮추고 싶을 때&lt;/h4&gt;

&lt;p&gt;시스템을 사용하는 클라이언트와 서브 시스템간의 의존성이 높을 때 퍼사드 패턴이 유용하다.&lt;/p&gt;

&lt;p&gt;퍼사드 패턴을 통해 서브 시스템의 기능을 사용하게 되면 &lt;strong&gt;클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;그렇다면 퍼사드 패턴을 사용하는 것이 무조건 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;1-퍼사드-패턴과-서브-시스템-사이의-의존성&quot;&gt;1. 퍼사드 패턴과 서브 시스템 사이의 의존성&lt;/h4&gt;

&lt;p&gt;퍼사드 패턴을 사용하게 되더라도 퍼사드 객체와 서브 시스템 사이의 의존성은 피할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;2-추가적인-코드&quot;&gt;2. 추가적인 코드&lt;/h4&gt;

&lt;p&gt;퍼사드 패턴을 사용하기 위해서는 퍼사드 객체를 만들어야 한다. 이는 코드의 증가를 유발하고 유지보수 관점에서 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;퍼사드 패턴을 사용하면서 얻을 수 있는 이점과 추가적인 유지보수 비용을 잘 비교하여 사용 여부를 결정하는 것이 중요하다!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;집에서 스크린을 통해서 영화를 보는 상황을 생각해보자.&lt;/p&gt;

&lt;p&gt;방에서 스크린으로 영화를 보기 위해서는 스크린을 내리고 화면도 나오게 세팅해야 한다. 그리고 음향도 적절하게 조절하고 방의 불도 꺼야 한다.&lt;/p&gt;

&lt;p&gt;리모컨 버튼 하나로 이 모든 것이 된다면 얼마나 좋을까??&lt;/p&gt;

&lt;p&gt;이를 실현해주는 것이 퍼사드 패턴이다!&lt;/p&gt;

&lt;p&gt;아래 코드를 보며 이해해보자.&lt;/p&gt;

&lt;h3 id=&quot;screen-speaker-lighter-projector-subsystem&quot;&gt;Screen, Speaker, Lighter, Projector (SubSystem)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크린, 스피커, 라이터, 프로젝터는 위에서 말한 서브 시스템이다. 퍼사드 패턴을 사용하지 않고 영화를 보는 환경을 세팅하기 위해서는 아래와 같이 클라이언트에서 서브 시스템 각각을 호출해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;main-client&quot;&gt;Main (Client)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_3.png&quot; alt=&quot;img3&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트(Main)과 서브 시스템의 의존성이 강한 것을 확인할 수 있다. 그리고 각각의 서브 시스템을 클라이언트에서 호출해야 한다.&lt;/p&gt;

&lt;p&gt;퍼사드 패턴을 사용하면 좀 더 간단한 인터페이스를 사용하여 서브 클래스의 동작을 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;moviefacade-facade&quot;&gt;MovieFacade (Facade)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러 서브 시스템을 묶어서 하나의 인터페이스(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMovieEnv()&lt;/code&gt;)를 제공하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이제 MovieFacade를 통해서 클라이언트에서 서브 시스템에 접근하는 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;main-client-1&quot;&gt;Main (Client)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_5.png&quot; alt=&quot;img5&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트에서 MovieFacade의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMovieEnv()&lt;/code&gt;를 통해서 서브 시스템에 접근하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;물론 여전히 클라이언트는 각 서브 시스템에도 직접 접근할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;지금까지 퍼사드 패턴에 대해서 알아봤다. 퍼사드 패턴은 복잡한 서브 시스템을 묶어서 클라이언트와 서브 시스템의 의존성을 낮추고 좀 더 간단한 인터페이스로 접근할 수 있게 도와준다.&lt;/p&gt;

&lt;p&gt;이렇게 좋은 점도 있지만 추가적인 유지보수 비용도 있기 때문에 득실을 잘 따져서 적절하게 사용하는 것이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">퍼사드 패턴</summary></entry><entry><title type="html">[디자인패턴] 컴포짓 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/50/" rel="alternate" type="text/html" title="[디자인패턴] 컴포짓 패턴" /><published>2023-12-04T00:00:00+09:00</published><updated>2023-12-04T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/50</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/50/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;컴포짓-패턴&quot;&gt;컴포짓 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Composite design pattern comes under &lt;strong&gt;Structural Patterns&lt;/strong&gt; is one of the most important and usable part of design pattern. Developers, in his daily life uses this pattern in somehow but he doesn’t know that its really a &lt;strong&gt;Composite Design Pattern.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴포짓 패턴은 클라이언트로 하여금 각 객체와 객체의 묶음을 동일하게 다룰 수 있게 해준다. 복합 객체와 단일 객체를 동일하게 취급하고 싶을 때 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/50_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;component&quot;&gt;Component&lt;/h3&gt;
&lt;p&gt;Leaf와 Composite을 묶는 상위 인터페이스이다. 여기서 Leaf는 단일 객체, Composite은 복합 객체라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;composite&quot;&gt;Composite&lt;/h3&gt;
&lt;p&gt;다른 Component 를 포함할 수 있는 Component로서 개별 객체 또는 다른 복합 객체를 포함시키 수 있다.&lt;br /&gt;
Component 구현체들을 내부에 리스트로 가지고 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getChild()&lt;/code&gt; 메소드는 내부 리스트에 단일, 복합 객체를 저장, 삭제, 조회한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;operation()&lt;/code&gt;를 복합 객체에서 호출하게 되면 &lt;strong&gt;재귀적&lt;/strong&gt;으로 추가 단일 객체를 저장한 하위 복합 객체를 순회한다.&lt;/p&gt;

&lt;h3 id=&quot;leaf&quot;&gt;Leaf&lt;/h3&gt;
&lt;p&gt;단일 객체로서, 다른 Component를 포함할 수 없다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 결국 Composite 패턴의 핵심은 단일 객체와 복합 객체를 Client 입장에서 동일한 인터페이스를 통해서 다룰 수 있게 해준다는 것이다.
예시 코드를 보면서 이해해보자!&lt;/p&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;
&lt;p&gt;저녁에 너무 배고파서 식당에 왔다. 식당 메뉴를 보니 정말 다양하다. 
펜케이크 메뉴, 디저트 메뉴, 카페 메뉴, …&lt;br /&gt;
그리고 한 메뉴 안에서도 또 메뉴가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 경우에 중첩되어 있는 메뉴(Menu)와 메뉴 항목(Menus)을 동일한 구조로 처리할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;예제-코드&quot;&gt;예제 코드&lt;/h3&gt;

&lt;h4 id=&quot;menucomponent-component&quot;&gt;MenuComponent (Component)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;우선 Component부터 살펴보자. Menu와 Menus를 묶는 역할을 한다.
공통으로 사용하는 operation으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getName()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getDescription()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt;가 있다.
이제 이를 구현한 Leaf와 Composite을 살펴보자.&lt;/p&gt;

&lt;h4 id=&quot;menu-leaf&quot;&gt;Menu (Leaf)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;단일 객체인 Menu를 살펴보자. Component에서 정의된 operation들을 구현한 것을 확인할 수 있다.
여기서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 함수가 단순히 자신의 맴버 변수인 price를 리턴한다는 것을 보고 넘어가자. 자세한 것은 아래서 설명하겠다.&lt;/p&gt;

&lt;h4 id=&quot;menus-composite&quot;&gt;Menus (Composite)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;클래스가 길어서 두번에 나눠서 설명하겠다.&lt;br /&gt;
이 부분을 보면 Component 리스트를 저장하고 있는 것을 볼 수 있다. &lt;br /&gt;
위에서 설명한 것처럼 복합 객체는 단일 객체, 복합 객체를 모두 가지고 있을 수 있다.&lt;br /&gt;
그것들이 리스트 형태로 저장된 것이라고 생각하면 된다.&lt;br /&gt;
리스트에 추가(add), 삭제(remove), 조회(getChild)하는 기능이 들어가 있는 것도 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 가장 주요하게 살펴봐야 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드를 보자.&lt;br /&gt;
이 부분에 어떻게 복합 객체와 단일 객체를 동일하게 사용할 수 있는지에 대한 실마리가 있다. -&amp;gt; 바로 &lt;strong&gt;재귀&lt;/strong&gt;이다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드는 Component 리스트를 순회하면서 각 Component의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드를 호출하게 된다. &lt;br /&gt;
만약 Component 안의 객체가 단일 객체라면 Menu 클래스에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드처럼 단순하게 맴버 변수인 price를 리턴할 것이다.&lt;br /&gt;
그런데 복합 객체라면 Menus의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드가 호출되며 제귀적으로 자신의 Component 리스트를 순회하면서 또&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt;를 호출할 것이다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;재귀 동작&lt;/strong&gt;을 통해서 하위 객체에게 작업을 위임하게 함으로써 복합 객체와 단일 객체에 동일한 작업을 적용할 수 있게 돼서 이 둘을 구분할 필요가 없어지게 된다.&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;다시 한번 말하지만 컴포짓 패턴은 단일 객체, 복합 객체를 동일한 인터페이스로 처리하고 싶을 때 사용하면 좋다는 것을 기억하면 좋겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://url.kr/eu6sr9&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html"></summary></entry><entry><title type="html">[디자인패턴] 템플릿 메소드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49/" rel="alternate" type="text/html" title="[디자인패턴] 템플릿 메소드 패턴" /><published>2023-12-04T00:00:00+09:00</published><updated>2023-12-04T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;템플릿-메소드-패턴&quot;&gt;템플릿 메소드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;템플릿 메소드 패턴은 알고리즘의 뼈대를 정의하고 서브 클래스마다 세부 동작 사항을 다르게 구현하는 패턴을 말한다.
변하지 않는 템플릿은 상위 클래스에 만들어두고 자주 변경되거나 확장되는 기능은 하위 클래스에서 만들도록 하여, 템플릿 메소드의 동작 순서는 고정하고 세부 실행 내용을 다양화할 때 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;abstract-class&quot;&gt;Abstract Class&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;템플릿 메소드&lt;/code&gt;를 구현하고, 템플릿 메소드에 사용되는 추상 메소드를 선언한다.
이 추상 메소드는 하위 클래스인 Concreate Class에서 구현된다.&lt;/p&gt;

&lt;h3 id=&quot;concreate-class&quot;&gt;Concreate Class&lt;/h3&gt;
&lt;p&gt;Abstract Class를 상속하고 추상 메소드를 구현한다. Concreate Class에서 구현한 메소드는 Abstract Class의 템플릿 메소드에서 호출된다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;공통되는 부분을  묶어서 관리하기 때문에 코드의 중복을 줄일 수 있고 관리하기도 편하다.&lt;/li&gt;
  &lt;li&gt;알고리즘의 특정 부분만 재정의하여 변경 사항에 대한 영향을 줄일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;템플릿 메소드에 정의한 골격은 고정돼있기 때문에 유연성이 제한될 수 있다.&lt;/li&gt;
  &lt;li&gt;알고리즘이 복잡하다면 템플릿 메소드를 만들거나 유지하기 어려울 수 있다.&lt;/li&gt;
  &lt;li&gt;추상 메소드가 많아지면 새로운 서브 클래스를 추가하거나 관리하기가 어려울 수 있다.&lt;/li&gt;
  &lt;li&gt;템플릿 메소드의 실행 흐름을 이해해야지만 서브 클래스에서 추상 메소드를 재정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;만약 템플릿 메소드의 알고리즘이 변경된다면 서브 클래스에서 재정의한 추상 메소드를 수정해야 할 수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금까지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;템플릿 메소드 패턴&lt;/code&gt;의 구조와 특징에 대해서 알아봤다.
이제 실제로 어떤식으로 활용될 수 있는지 코드를 통해서 확인하자!&lt;/p&gt;

&lt;h2 id=&quot;예제-코드&quot;&gt;예제 코드&lt;/h2&gt;

&lt;h3 id=&quot;beverage-클래스-abstract-class&quot;&gt;Beverage 클래스 (Abstract Class)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt;메소드는 템플릿 메소드이다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boilWater()&lt;/code&gt;,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pour()&lt;/code&gt;는 모든 음료가 공통으로 처리해야 하는 로직이라고 생각하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;는 각 음료마다 재료가 다르기 때문에 달라져야 하는 부분이라고 생각해보자.
그러면 공통되는 부분은 나두고 각 음료마다 바뀌는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;를 추상 메소드로 선언하여 서브 클래스에서 구현하게 하면 변경을 최소화하면서 각 서브 클래스로 구현을 미루면서 유연한 확장을 할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;americano-chocolatelatee-클래스-concreate-class&quot;&gt;Americano, ChocolateLatee 클래스 (Concreate Class)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_3.png&quot; alt=&quot;img3&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Americano와  ChocolateLatte는 Beverage를 상속받아서 각자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;메소드를 구현하게 된다. 그리고 템플릿 메소드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt;를 호출하게 되면 전체적인 알고리즘 흐름은 동일하지만 세부 실행 내용을 변경할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;hook-메소드&quot;&gt;hook 메소드&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;hook 메소드&lt;/strong&gt;는 서브 클래스에서 좀 더 유연하게 템플릿 메소드의 알고리즘 로직을 다양화할 수 있게 도와주는 역할을 수행한다.
일반적으로 추상 메소드가 아닌 일반 메소드로 구현을 하게 된다.
그냥 나두게 되면 원래 설정한 기본 흐름대로 실행되고 서브 클래스에서 오버라이딩하게 되면 상황에 맞게 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;간단한 예시 코드를 보면서 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;템플릿 메소드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt; 안에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCustomerWantsTopping()&lt;/code&gt;가 앞에서 말한 hook 메서드이다.
기본적인 요구사항이 토핑을 추가하여 음료를 제공한다고 생각하고 로직을 작성한 것이다. 그런데 어떤 음료에는 토핑이 들어가지 않아야 할 수 있다. 이런 경우에는 서브 클래스에서 hook 메서드를 선택적으로 오버라이딩하여 템플릿 메소드의 흐름을 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_5.png&quot; alt=&quot;img5&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Americano에 기본적으로 토핑이 들어가면 안된다고 할 때, hook 메서드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCustomerWantsTopping()&lt;/code&gt;을 제정의하여 템플릿 메소드 안에있는 로직의 실행 흐름을 제어할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://url.kr/tw2s8o&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html"></summary></entry><entry><title type="html">[DevOps] CI/CD &amp;amp; 무중단 배포</title><link href="http://localhost:4000/devops/48/" rel="alternate" type="text/html" title="[DevOps] CI/CD &amp;amp; 무중단 배포" /><published>2023-11-25T00:00:00+09:00</published><updated>2023-11-25T00:00:00+09:00</updated><id>http://localhost:4000/devops/48</id><content type="html" xml:base="http://localhost:4000/devops/48/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;devops&quot;&gt;&lt;em&gt;DevOps&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_8.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Development&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;개발과 운영을 결합시켜 만든 개발 방법론을 의미한다.&lt;/p&gt;

&lt;p&gt;소프트웨어 개발과 운영을 통합하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;효율성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;협력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속도&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정성&lt;/code&gt;을 개선하는 개발 및 운영 방법론이다.&lt;/p&gt;

&lt;h2 id=&quot;장점&quot;&gt;&lt;em&gt;장점&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;속도&lt;/strong&gt;&lt;br /&gt;
애플리케이션 개발 단계를 자동화하여 애플리케이션을 더 짧은 주기로 고객에게 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;신속한 제공&lt;/strong&gt;&lt;br /&gt;
릴리스 빈도와 속도를 개선하여 제품을 더 빠르게 개선할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안정성&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;와 같은 방식을 사용하여 각 변경 사항이 제대로 작동하고 안전한지 테스트를 할 수 있다.&lt;br /&gt;
모니터링과 로깅을 통해 실시간으로 성능에 대한 정보를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확장&lt;/strong&gt;&lt;br /&gt;
자동화와 일관성이 지원되기 때문에 위험을 줄이면서 복합한 시스템을 효율적으로 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;협업 강화&lt;/strong&gt;&lt;br /&gt;
개발자와 운영팀이 긴밀하게 협력하고 많은 책임을 공유한다.&lt;br /&gt;
이를 통해서 비효율성을 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;br /&gt;
자동화된 규정 준수 정책, 세분화된 제어 및 구성 관리 기술을 사용하여 보안을 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;→ 애플리케이션 개발, 배포 단계를 자동화하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD (Continuous Integration/Continuous Delivery)&lt;/code&gt;라고 하는데 이에 대해서 자세히 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cicd&quot;&gt;&lt;em&gt;CI/CD&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI&lt;/code&gt; 는 개발자를 위한 자동화 프로세스인 지속적인 통합을 의미하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt;는 지속적인 서비스 제공(Continuous Delivery) 및 지속적인 배포(Continuous Deployment)를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 각각에 대해서 알아보자.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;ci-continuous-integration&quot;&gt;CI (Continuous Integration)&lt;/h2&gt;

&lt;p&gt;CI는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 통합&lt;/code&gt;을 의미하는데 간단하게 &lt;strong&gt;빌드와 테스트를 자동화&lt;/strong&gt;하는 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;필요성&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;CI가 없을 때는 여러 개발자가 수정한 변경 사항을 한번에 모아서 Merge를 했었는데 이때 만약 에러가 발생하면 어느 곳에서 에러가 발생한지 디버깅 하는 것이 굉장히 어려웠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ CI를 성공적으로 구축하게 되면 코드를 변경할 때마다 바로 빌드 및 테스트가 진행되기 때문에 위와 같은 문제가 발생하지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;과정&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;개발자가 코드를 수정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI tool&lt;/code&gt;에 병합을 요청한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI tool&lt;/code&gt;에서 변경된 코드를 빌드하고 테스트를 수행한다.&lt;/li&gt;
  &lt;li&gt;문제가 없다면 코드를 병합한다.&lt;/li&gt;
  &lt;li&gt;만약 테스트가 실패하면 바로 개발자에게 피드백을 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cd-continuous-deliverydeployment&quot;&gt;CD (Continuous Delivery/Deployment)&lt;/h2&gt;

&lt;p&gt;CD는 &lt;strong&gt;배포를 자동화하는 과정&lt;/strong&gt;이라고 생각하면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 제공(Continuous Delivery)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 배포(Continuous Deployment)&lt;/code&gt;를 의미하며 이 두 용어는 상호 교환적으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;이 두가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 의미하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;필요성-1&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;하나의 서버만 운영한다면 직접 이 서버에 들어가서 배포를 진행하면 된다.&lt;/p&gt;

&lt;p&gt;그런데 서버가 여러대가 있다면?&lt;/p&gt;

&lt;p&gt;하나 하나 서버에 들어가서 수동으로 스크립트를 실행하여 배포해야 한다. 이는 굉장히 비효율적이다.&lt;/p&gt;

&lt;p&gt;→ CD를 구축하게 되면 모든 서버에 자동으로 배포할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-delivery&quot;&gt;Continuous Delivery&lt;/h3&gt;

&lt;p&gt;애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드되는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;리포지토리에 올라온 것을 개발자나 운영팀에서 직접 검증하고 애플리케이션을 실시간으로 프로덕션 환경에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수동&lt;/code&gt; 배포한다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-deployment&quot;&gt;Continuous Deployment&lt;/h3&gt;

&lt;p&gt;개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자동&lt;/code&gt;으로 릴리스하는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 제공(Continuous Delivery)&lt;/code&gt;과의 차이점은 개발자, 운영팀에서 리포지토리에 올라온 릴리스를 확인하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자동&lt;/code&gt;으로 배포까지 수행한다는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;cicd를-위한-대표적인-도구&quot;&gt;CI/CD를 위한 대표적인 도구&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gihub Actions&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circleci&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GitLab CI/CD&lt;/code&gt;등이 있다.&lt;br /&gt;
이 중에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;를 가장 많이 사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;무중단-배포&quot;&gt;&lt;em&gt;무중단 배포&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;다운타임-downtime&quot;&gt;다운타임 (DownTime)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;한대의 서버를 사용하여 서비스를 운영한다고 생각해보자. V1이 실행되고 있는 상황에서 새로운 기능이 추가된 V2가 개발이 완료됐다. 사용자에게 새로운 기능을 제공하기 위해서는 V2를 배포해야 한다.&lt;/p&gt;

&lt;p&gt;하지만 서버를 한대로 운영하고 있기 때문에 V2를 실행하기 위해서는 V1을 종료하고 V2를 실행해야 한다.&lt;/p&gt;

&lt;p&gt;V1을 종료하고 V2를 실행하는 동안에 사용자는 서비스를 이용할 수 없다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다운타임(downTime)&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다운타임&lt;/code&gt; 없이 새로운 기능을 추가하기 위한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무중단 배포&lt;/code&gt;라고 한다. 이를 위해서는 최소한 2대의 서버가 있어야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리버스-프록시-reverse-proxy&quot;&gt;리버스 프록시 (Reverse Proxy)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무중단 배포&lt;/code&gt;를 이해하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리버스 프록시&lt;/code&gt;에 대해서 알아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리버스 프록시&lt;/code&gt;란 클라이언트와 웹 서버 간의 중개자 역할을 하는 서버이다.&lt;/p&gt;

&lt;p&gt;서버 대신에 클라이언트의 요청을 대신 받아서 웹 서버로 전달하고, 웹 서버의 응답을 클라이언트에게 전달하는 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;이를 통해서 &lt;strong&gt;웹 서버의 부하를 분산&lt;/strong&gt;시키고, &lt;strong&gt;보안을 강화&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;로드 밸런싱&lt;/strong&gt;&lt;br /&gt;
웹 서버에 동시에 많은 트래픽이 몰릴 때, 서버에 부하가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;리버스 프록시를 사용하면 클라이언트의 요청을 여러 대의 서버로 분산시켜 각 서버의 부하를 줄이고, 서버의 가용성을 높여 안정적으로 서비스를 운영할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;&lt;br /&gt;
리버스 프록시를 사용하면 외부에서 서버로 바로 접근하지 못하게 된다.&lt;/p&gt;

&lt;p&gt;서버와 클라이언트 사이에서 악성 요청을 필터링하거나, 접근 제한과 같은 역할을 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;캐싱 및 가속화&lt;/strong&gt;&lt;br /&gt;
자주 사용되는 정적 파일(CSS, JS)를 캐시에 저장하여 빠르게 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;이로 인해 서버의 부하를 줄이고 응답 시간을 단축시킬 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추가적인 서버 설정 비용&lt;/strong&gt;&lt;br /&gt;
리버스 프록시를 사용하기 위해서는 추가적인 서버 설정과 관리가 요구된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;네트워크 지연&lt;/strong&gt;&lt;br /&gt;
중간 다리(리버스 프록시)를 거치기 때문에 약간의 네트워크 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;복잡성 증가&lt;/strong&gt;&lt;br /&gt;
아키텍처가 복잡해질 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ 리버스 프록시의 장단점은 사실 프록시 패턴의 장단점과 동일하다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;로드-밸런싱&quot;&gt;&lt;em&gt;로드 밸런싱&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;정의-1&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;컴퓨터 네트워크 기술의 일종으로 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 &lt;strong&gt;컴퓨터 자원들에게 작업, 즉 부하를 나누는 것&lt;/strong&gt;을 의미한다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;필요성-2&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;서비스 런칭 단계에서는 고객이 거의 없기 때문에 서버 한대로도 모든 요청을 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 점점 고객의 수가 늘어나고 서비스가 확장되면 서버 한대로는 모든 요청을 처리할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;증가하는 트래픽을 대처하기 위해서 사용할 수 있는 방법은 크게 2가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scale-up&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scale-out&lt;/code&gt; 이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Scale up&lt;/strong&gt; : 서버 자체의 성능을 향상하는 방법으로 비용이 상대적으로 많이 든다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Scale out&lt;/strong&gt; : 서버를 증설하는 방법이다. 이 방법을 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;로드밸런싱&lt;/code&gt;이 필수로 요구된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;L4 로드밸런싱&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송 계층&lt;/code&gt;에서 로드(트래픽)을 분산시킨다.&lt;br /&gt;
IP주소나 포트번호, MAC주소 등에 따라 트래픽을 나누고 분선처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L7 로드밸런싱&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션 계층&lt;/code&gt;에서 로드를 분산시킨다.&lt;br /&gt;
HTTP, SMTP, FTP 등을 바탕으로 로드를 분산 처리할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;로드밸런싱-알고리즘&quot;&gt;로드밸런싱 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;라운드로빈-방식&quot;&gt;라운드로빈 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;단순히 서버로 요청이 들어온 순서를 바탕으로 처리하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트의 요청 순서에 따라 처리되기 때문에 여러 대의 서버가 동일한 스펙을 가지고 있고, 서버와의 연결이 오래 지속되지 않을 때 사용하면 좋다.&lt;/p&gt;

&lt;h3 id=&quot;가중-라운드로빈-방식&quot;&gt;가중 라운드로빈 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버마다 가중치를 설정하고 가중치가 높은 서버에 클라이언트의 요청을 우선적으로 배분하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 서버의 트래픽 처리 능력이 다를 때 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;ip-해시-방식&quot;&gt;IP 해시 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트의  IP 주소를 바탕으로 해시함수를 돌려서 항상 동일한 서버에 도달하게 만드는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트는 항상 동일한 서버로부터 서비스를 받을 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;최소-연결-방식&quot;&gt;최소 연결 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트 요청이 들어올 때를 기준으로 가장 트래픽이 적은 서버로 연결하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서버에 분산된 트래픽이 일정하지 않을 때 적합하다.&lt;/p&gt;

&lt;h3 id=&quot;최소-리스폰타임&quot;&gt;최소 리스폰타임&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버의 연결 상태와 응답 시간을 모두 고려하여 트래픽을 분산하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;무중단-배포-방식&quot;&gt;&lt;em&gt;무중단 배포 방식&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;롤링rolling-배포&quot;&gt;롤링(Rolling) 배포&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ 여기서의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nginx&lt;/code&gt;는 로드밸런서 역할을 하는 리버스 프록시라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;롤링 배포 방식은 사용중인 인스턴스 내에서 새로운 버전을 점진적으로 교체해 나가는 방식으로 무중단 배포의 가장 기본적인 방법이다.&lt;/p&gt;

&lt;p&gt;위에서부터 차례대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버3&lt;/code&gt;이라고 해보자.&lt;/p&gt;

&lt;h3 id=&quot;과정-1&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;로드밸런서(Nginx)에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;로 라우팅되지 않게 설정한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;에 새로운 버전을 배포한다.&lt;/li&gt;
  &lt;li&gt;로드밸런서에서 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;로 라우팅될 수 있도록 변경한다.&lt;/li&gt;
  &lt;li&gt;이 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버3&lt;/code&gt;에 점진적으로 적용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;장점-2&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;차례대로 배포를 진행하기 때문에 상황에 따라서 롤백이 어렵지 않다.&lt;/p&gt;

&lt;p&gt;추가적인 인스턴스를 늘리지 않아도 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;새로운 버전을 배포할 때마다 처리할 수 있는 서버가 줄어들기 때문에 트래픽이 몰릴 수 있다.&lt;/p&gt;

&lt;p&gt;배포가 진행될 때 구버전과 신버전이 동시에 존재하기 때문에 &lt;strong&gt;호환성 문제&lt;/strong&gt;가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;blue-green-배포-방식&quot;&gt;Blue Green 배포 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블루&lt;/code&gt;는 구버전을, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그린&lt;/code&gt;은 신버전을 의미한다.&lt;/p&gt;

&lt;p&gt;운영중인 구버전과 동일하게 신버전 인스턴스를 구성하고 로드밸런서를 사용하여 모든 트래픽을 한번에 신버전으로 전환하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;장점-3&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;구버전의 인스턴스가 그대로 남아있기 때문에 롤백이 쉽다.&lt;/p&gt;

&lt;p&gt;한번에 라우팅을 변경하기 때문에 배포하는 속도가 빠르다.&lt;/p&gt;

&lt;p&gt;구버전 환경을 다음 배포에 재사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점-2&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;구버전과 신버전을 가지고 있어야 하기 때문에 시스템 자원이 2배로 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;카나리-배포-방식&quot;&gt;카나리 배포 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;과정-2&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;신버전을 소수의 유저들에게 배포하고 문제가 없는지 확인한다.&lt;/li&gt;
  &lt;li&gt;만약 문제가 없다면 점차 많은 유저에게 배포한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블루 그린 방식&lt;/code&gt;과 유사하지만 트래픽을 한번에 바꾸는 것이 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단계적으로 바꾸는 것&lt;/code&gt;이 차이점이다.&lt;/p&gt;

&lt;h3 id=&quot;장점-4&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;성능 모니터링에 유용하다.&lt;/p&gt;

&lt;p&gt;A/B 테스트로 활용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A/B 테스트란?
    &lt;blockquote&gt;
      &lt;p&gt;A/B 테스팅이란 웹 사이트 방문자를 임의로 두 집단으로 나누고, 한 집단에게는 기존 사이트를 보여주고 다른 집단에게는 새로운 사이트를 보여준 다음, 두 집단 중 어떤 집단이 더 높은 성과를 보이는지 측정하여, 새 사이트가 기존 사이트에 비해 좋은지를 정량적으로 평가하는 방식을 말한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점-3&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;네트워크 트래픽을 제어하는 부담이 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://aws.amazon.com/ko/devops/what-is-devops/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.redhat.com/ko/topics/devops&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://velog.io/@lee2302/Deploy-CICD%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%B0%ED%8F%AC&quot;&gt;https://velog.io/@lee2302/Deploy-CICD자동화-배포&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://seosh817.tistory.com/104&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://hudi.blog/zero-downtime-deployment/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.youtube.com/watch?v=sIPU_VkrguI&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://narup.tistory.com/238&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://aday7.tistory.com/entry/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9CReverse-Proxy-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%ED%95%84%EC%9A%94%EC%84%B1-%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EC%86%94%EB%A3%A8%EC%85%98%EA%B9%8C%EC%A7%80&quot;&gt;https://aday7.tistory.com/entry/리버스-프록시Reverse-Proxy-쉽게-이해하기-개념부터-필요성-오픈-소스-솔루션까지&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://velog.io/@yanghl98/OS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-Load-Balancing-%EC%A0%95%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98&quot;&gt;https://velog.io/@yanghl98/OS운영체제-로드밸런싱-Load-Balancing-정의-종류-알고리즘&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://bruno-jang.tistory.com/34&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="DevOps" /><category term="DevOps" /><category term="CI/CD" /><category term="리버스 프록시" /><category term="무중단 배포" /><summary type="html"></summary></entry></feed>