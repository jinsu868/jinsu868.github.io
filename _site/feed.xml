<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-17T17:50:21+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[트러블슈팅] 커서 기반 페이지네이션</title><link href="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/63/" rel="alternate" type="text/html" title="[트러블슈팅] 커서 기반 페이지네이션" /><published>2024-03-02T00:00:00+09:00</published><updated>2024-03-02T00:00:00+09:00</updated><id>http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/63</id><content type="html" xml:base="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/63/">&lt;h2 id=&quot;문제-인식&quot;&gt;문제 인식&lt;/h2&gt;

&lt;p&gt;필자는 &lt;strong&gt;Palgona&lt;/strong&gt; 프로젝트에서 상품 리스트 조회 로직 구현을 맡았다.&lt;/p&gt;

&lt;p&gt;프로젝트 요구사항에 상품을 &lt;strong&gt;최신순&lt;/strong&gt;, &lt;strong&gt;북마크 순&lt;/strong&gt;, &lt;strong&gt;최고 입찰가순&lt;/strong&gt;으로 정렬해서 보여주는 요구사항이 있었다.&lt;/p&gt;

&lt;p&gt;처음 구현했을 때는 오프셋 기반의 페이지네이션을 사용해서 구현했는데 팀원분이 커서 기반 페이지네이션을 적용하면 좋을 것 같다는 피드백을 주셨다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 커서 기반 페이지네이션 적용 과정에 대해서 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기존-방식의-문제점-offset-based&quot;&gt;기존 방식의 문제점 (offset based)&lt;/h2&gt;

&lt;h3 id=&quot;단순한-조회-쿼리-예시&quot;&gt;단순한 조회 쿼리 (예시)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단한 예시로 설명하겠다. 처음에 상품이 5개가 있다고 가정하자. (id = 1, 2, 3, 4, 5)&lt;/p&gt;

&lt;p&gt;(1)에서 쿼리가 나가면 상품 Id가 (5~3)인 상품이 조회될 것이다.&lt;/p&gt;

&lt;p&gt;(2)에서 2개의 상품이 추가될 것이다.&lt;/p&gt;

&lt;p&gt;(3)에서 다음 페이지를 조회하는데 결과는 상품 Id가 (4~2)인 상품이 조회될 것이다.&lt;/p&gt;

&lt;p&gt;→ 데이터가 중복 조회되는 결과가 발생한다. (id = 4, 3 중복 조회)&lt;/p&gt;

&lt;p&gt;(뿐만 아니라 조회 중간에 데이터를 삭제하게 되면 어떤 상품은 조회되지 않는 상황도 발생할 수 있다.)&lt;/p&gt;

&lt;h3 id=&quot;offset-증가에-따른-성능-문제&quot;&gt;offset 증가에 따른 성능 문제&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 쿼리를 보면 알 수 있듯이 원하는 데이터는 3개인데 앞의 백만 개의 데이터를 다 읽고 3개의 데이터를 가져와야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;뒤에 있는 데이터를 읽을수록 점점 조회 성능이 떨어질 것이라는 것은 자명하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;→ &lt;strong&gt;커서 기반 페이지네이션 방식&lt;/strong&gt;을 도입하면 위의 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커서-기반-페이지네이션&quot;&gt;커서 기반 페이지네이션&lt;/h2&gt;

&lt;h3 id=&quot;쿼리-예시&quot;&gt;쿼리 예시&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;커서 기반 페이지네이션 방식은 위와 같이 커서를 기준으로 limit의 개수만큼 조회하는 방식이다.&lt;/p&gt;

&lt;p&gt;오프셋 방식처럼 앞의 데이터를 다 읽을 필요가 없기 때문에 뒤쪽의 데이터를 읽더라도 성능 저하가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;커서 데이터만 중복되지 않는다면&lt;/strong&gt; 성능도 좋고 데이터의 중복도 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;이제 간단한 도메인에 대해 소개하고 커서 기반 페이지네이션 방식을 적용한 방법을 소개하겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;erd&quot;&gt;ERD&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상품 조회에 연관된 Entity만 남겼고 사용되는 필드를 제외하고는 다 걷어냈다.&lt;/p&gt;

&lt;h3 id=&quot;상품-리스트-조회-api-응답값&quot;&gt;상품 리스트 조회 API 응답값&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모바일 앱을 기준으로 개발했기 때문에 Slice 방식을 채택하여 무한 스크롤이 가능하도록 했다. 이를 위해 위와 같은 응답을 정의했다. 여기서 중요한 부분은 커서인데 뒤에서 설명하겠다.&lt;/p&gt;

&lt;h3 id=&quot;productpageresponse&quot;&gt;ProductPageResponse&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ProductPageResponse가 실제 응답 값이고 이를 SliceResponse로 감싸서 나가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 조회 쿼리 최적화 과정과 커서 기반 페이지네이션을 어떻게 적용했는지 살펴보자!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;커서-커스텀-커서&quot;&gt;커서 (커스텀 커서)&lt;/h3&gt;

&lt;p&gt;Palgona 프로젝트에서 상품은 &lt;strong&gt;최신순, 입찰가순, 북마크 순&lt;/strong&gt;으로 정렬할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;여기서 최신순을 제외한 입찰가, 북마크 순의 경우 &lt;strong&gt;커서 데이터에 중복&lt;/strong&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 별도의 커스텀 커서를 만들어줘야 데이터의 중복이 발생하지 않고 정상적으로 페이지네이션 처리를 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최신순의 경우는 product_id를 커서 데이터로 쓰면 되기 때문에 중복 걱정은 안 해도 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;커서-생성-부분&quot;&gt;커서 생성 부분&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정렬 조건에 따라서 커스텀 커서를 생성하는 부분이다.&lt;/p&gt;

&lt;p&gt;CONCAT과 LPAD 함수를 사용하여 &lt;strong&gt;유일한 식별자&lt;/strong&gt;를 만들었다.&lt;/p&gt;

&lt;h3 id=&quot;생성-예시&quot;&gt;생성 예시&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입찰가의 경우 9자리로 패딩하고 8자리로 패딩한 product_id와 조합하여 유일한 식별자를 만든다.&lt;/p&gt;

&lt;p&gt;→ ex) 입찰가가 70만 원이고 상품 Id가 1이라면 00070000000000001 와 같은 커스텀 커서가 만들어진다.&lt;/p&gt;

&lt;p&gt;북마크는 자리수만 다르고 로직은 동일하기 때문에 설명은 생략하겠다.&lt;/p&gt;

&lt;h3 id=&quot;커서-비교-로직-isinsearchrange&quot;&gt;커서 비교 로직 (isInSearchRange)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 조회될 데이터인지 판단하는 부분이다.&lt;/p&gt;

&lt;p&gt;비교를 위해 값을 패딩하고 Id를 조합해서 값을 만든다. 이를 커서와 비교하여 조회 대상인지 판단한다.&lt;/p&gt;

&lt;h3 id=&quot;정렬-기준-createorderspecifier&quot;&gt;정렬 기준 (createOrderSpecifier)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_10.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정렬 기준은 Querydsl의 OrderSpecifier 를 사용했다.&lt;/p&gt;

&lt;h3 id=&quot;상품-리스트-조회-findallbycategoryandsearchword---전체-로직&quot;&gt;상품 리스트 조회 (findAllByCategoryAndSearchWord) - 전체 로직&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_11.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_12.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_13.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상품 리스트는 총 &lt;strong&gt;2번의 쿼리&lt;/strong&gt;를 통해서 가져왔다. 하나씩 살펴보자!&lt;/p&gt;

&lt;h3 id=&quot;1-상품-조회-쿼리&quot;&gt;(1) 상품 조회 쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_14.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 쿼리에서는 Product를 Bookmark, Bidding과 left join해서 최고 입찰가와 북마크 수를 같이 가져온다.&lt;/p&gt;

&lt;p&gt;그냥 조회하게 되면 Product가 Bookmark, Bidding과 모두 1:N 관계라서 튜플수가 늘어나게 되서 제대로 페이징 처리를 할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groupBy(product.id)&lt;/code&gt; 를 통해서 상품 아이디로 묶어주어 페이징 처리가 제대로 이뤄지게 구현했다.&lt;/p&gt;

&lt;p&gt;여기서 상품 이미지를 같이 조회하지 않고 쿼리를 분리한 이유는 대표 사진만 보여줘야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;대표 사진은 image_id가 가장 낮은 이미지로 처음으로 등록되는 이미지를 말한다.&lt;/p&gt;

&lt;p&gt;만약 쿼리를 나누지 않고 이미지를 같이 가져오게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groupBy(product.id)&lt;/code&gt; 를 하면서 최초 이미지를 가져오는 것을 보장할 수 없게 된다.&lt;/p&gt;

&lt;h3 id=&quot;2-이미지-조회-쿼리&quot;&gt;(2) 이미지 조회 쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_15.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 쿼리에서는 첫 번째 쿼리에서 조회된 product_id를 가지고 in 쿼리를 날린다. 이를 통해서 product_id에 속하는 모든 이미지를 가져온다.&lt;/p&gt;

&lt;h3 id=&quot;toproductids&quot;&gt;toProductIds&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_16.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1번 쿼리에서 조회한 product_id를 추출해서 리스트로 반환하는 메서드이다.&lt;/p&gt;

&lt;h3 id=&quot;3-상품---이미지-매핑-작업&quot;&gt;(3) 상품 - 이미지 매핑 작업&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_17.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 이미지 조회 결과를 product_id 키로 묶고 대표 이미지를 뽑아서 최종 상품 리스트 응답 값을 생성한다.&lt;/p&gt;

&lt;h3 id=&quot;convertoslice&quot;&gt;converToSlice&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_18.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 상품 리스트 응답 값을 SliceResponse로 감싸는 부분이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커서-기반-페이지네이션-처리-이후-쿼리-결과&quot;&gt;커서 기반 페이지네이션 처리 이후 쿼리 (결과)&lt;/h2&gt;

&lt;h3 id=&quot;sorttype--latest-최신순-테스트&quot;&gt;SortType = LATEST (최신순) 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_19.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿼리&quot;&gt;쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_20.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;총 2번의 쿼리가 나가고 첫 번째 쿼리에서는 having 절에 커서(product_id)를 기준으로 조회가 되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;두 번째 쿼리에서는 in 쿼리로 이미지가 조회되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sorttype--higest_price-입찰가-높은순-테스트&quot;&gt;SortType = HIGEST_PRICE (입찰가 높은순) 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_22.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿼리-1&quot;&gt;쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_23.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;달라진 부분은 &lt;strong&gt;having절&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_24.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CONCAT과 LPAD를 사용되어 커스텀 식별자가 생성됐고 이를 커서와 비교하는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sorttype--bookmark-북마크순-테스트&quot;&gt;SortType = BOOKMARK (북마크순) 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_25.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿼리-2&quot;&gt;쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_26.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;북마크도 마찬가지이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_27.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;달라진 점은 패딩을 하는 값에 북마크의 수가 들어간다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-결과&quot;&gt;테스트 결과&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_28.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최종적으로 모든 테스트를 통과한 것을 확인할 수 있었다.!!&lt;/p&gt;

&lt;h3 id=&quot;느낀점&quot;&gt;느낀점&lt;/h3&gt;

&lt;p&gt;중간에 키가 중복돼서 중복 조회가 발생하기도 하고 Querydsl에서 SQL 함수를 쓰는 방법을 몰라서 많이 헤매기도 했었다. 힘들었지만 테스트의 녹색불을 확인하니 너무 뿌듯했다!!&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="프로젝트" /><category term="트러블슈팅" /><category term="프로젝트" /><summary type="html">문제 인식</summary></entry><entry><title type="html">[운영체제] 메모리 (진행중)</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6md/" rel="alternate" type="text/html" title="[운영체제] 메모리 (진행중)" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-14T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6md</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6md/">&lt;h2 id=&quot;메모리의-종류&quot;&gt;메모리의 종류&lt;/h2&gt;

&lt;p&gt;CPU에 가까운 순서대로 레지스터, 캐시, 주기억장치, 보조기억장치가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/61_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;

&lt;p&gt;캐시는 CPU와 메모리 사이의 속도 차이를 완화하기 위해서 사용한다.&lt;/p&gt;

&lt;p&gt;캐시는 메모리의 데이터를 미리 가져와 저장해두는 임시 저장소로, 크기는 메인 메모리보다 작기 때문에 앞으로 사용될 것으로 예상되는 데이터를 미리 저장하는 것이 키 포인트이다. 캐시에 있는 데이터를 가져와서 사용하는 것을 캐시 적중이라 하고 적중을 높이기 위해 &lt;strong&gt;지역성의 원리&lt;/strong&gt;가 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;시간-지역성&quot;&gt;시간 지역성&lt;/h3&gt;

&lt;p&gt;최근 사용한 데이터에 다시 접근하려는 특성을 말한다.&lt;/p&gt;

&lt;p&gt;반복문 for문의 인덱스 변수가 여기에 해당한다.&lt;/p&gt;

&lt;h3 id=&quot;공간-지역성&quot;&gt;공간 지역성&lt;/h3&gt;

&lt;p&gt;최근 사용한 데이터의 인접한 주소의 내용을 다시 접근하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;배열의 연속된 원소들이 같이 조회되는 것을 생각하면 된다.&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h2&gt;

&lt;p&gt;메모리에 프로그램을 할당할 때는 시작 메모리의 위치와 메모리 할당 크기를 기반으로 할당한다. 방법에는 연속 할당, 불연속 할당 방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h3&gt;

&lt;p&gt;연속 할당 방식은 프로세스 이미지가 분리되지 않고 온전한 프로세스를 메인 메모리에 적재하는 방식이다.&lt;/p&gt;

&lt;p&gt;연속 할당 방식에는 고정 분할 방식, 가변 분할 방식이 있다.&lt;/p&gt;

&lt;h4 id=&quot;고정-분할-방식&quot;&gt;고정 분할 방식&lt;/h4&gt;

&lt;p&gt;메모리를 고정된 파트로 분리하고, 프로세스를 해당 파트에 삽입한다. 고정된 길이의 파트 내에 프로세스가 들어가기 때문에 여백이 생길 수 있는데 이것을 &lt;strong&gt;내부 단편화&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;가변-분할-방식&quot;&gt;가변 분할 방식&lt;/h4&gt;

&lt;p&gt;메모리를 프로세스의 길이에 알맞게 파트를 분리하고, 해당 프로세스를 적재하는 방식이다. 내부 단편화는 발생하지 않지만 가변적인 길이 할당에 의해서 메모리의 일부분이 남기 때문에 &lt;strong&gt;외부 단편화&lt;/strong&gt;가 발생한다.&lt;/p&gt;

&lt;p&gt;최초 적합 : 메모리의 처음부터 검사하여 크기가 충분한 첫번째 공간에 할당한다.&lt;/p&gt;

&lt;p&gt;최적 적합 : 프로세스의 크기 이상인 공간 중 가장 작은 공간에 할당한다.&lt;/p&gt;

&lt;p&gt;최악 적합 : 프로세스의 크기와 가장 많이 차이가 나는 공간에 할당한다.&lt;/p&gt;

&lt;h3 id=&quot;불연속-할당&quot;&gt;불연속 할당&lt;/h3&gt;

&lt;p&gt;프로세스를 연속된 이미지가 아닌 분리된 이미지로 구성하여 메인 메모리에 적재하는 방식을 말한다. 페이징, 세그멘테이션 방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이징&quot;&gt;페이징&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/62_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리하여 메인 메모리에 불연속적으로 저장하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;내부 단편화&lt;/strong&gt;가 발생할 수 있다. (프로세스의 크기를 페이지의 크기로 나누고 남은 나머지의 크기만큼)&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션&quot;&gt;세그멘테이션&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/62_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 가변적인 크기의 세그먼트로 분리하여 메모리에 적재하는 방식이다. 주로 논리적인 블록 단위로 나누며 Code, Date, Heap, Stack 으로 분리할 수 있다. 세그멘테이션은 &lt;strong&gt;외부 단편화&lt;/strong&gt;가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;내부-외부-단편화&quot;&gt;내부, 외부 단편화&lt;/h2&gt;

&lt;h3 id=&quot;단편화&quot;&gt;단편화&lt;/h3&gt;

&lt;p&gt;단편화란 프로세스들이 차지하는 메모리 사이에 사용하지 못할 만큼의 작은 공간을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;내부-단편화&quot;&gt;내부 단편화&lt;/h3&gt;

&lt;p&gt;내부 단편화는 고정 분할 방식 / 페이지에서 나타나며, 물리 메모리를 고정적인 파트로 잘랐을 때, 해당 파트의 길이보다 더 작은 크기의 조각이 들어가게 되서 생기게 된다.&lt;/p&gt;

&lt;h3 id=&quot;외부-단편화&quot;&gt;외부 단편화&lt;/h3&gt;

&lt;p&gt;메모리가 할당되고 해제되는 과정이 반복될 때, 작은 메모리가 사이사이에 생겨나는 것을 말한다. 이러한 메모리 공간이 많이자면 총 사용 가능한 메모리 공간은 충분하지만 메모리를 할당할 수 없는 상황이 생기는데 이를 외부 단편화라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;가상-메모리&quot;&gt;가상 메모리&lt;/h2&gt;

&lt;p&gt;가상 메모리는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.&lt;/p&gt;

&lt;p&gt;가상 주소 -&amp;gt; MMU -&amp;gt; 실제 주소&lt;/p&gt;

&lt;p&gt;TLB : CPU와 메모리 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하여 CPU가 페이지 테이블까지 가지 않도록 하여 속도를 향상시킨다.&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;가상 메모리를 사용하면 동시에 많은 프로세스를 실행할 수 있고, 응답 시간을 유지하며 CPU 이용률과 처리률을 높일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;물리 메모리로 사용하는 것보다는 느리다.&lt;/p&gt;

&lt;h2 id=&quot;요구-페이징&quot;&gt;요구 페이징&lt;/h2&gt;

&lt;p&gt;요구 페이징은 프로그램을 실행할 때, 프로그램 전체를 물리 메모리에 적재하는 대신 초기에 필요한 부분들만 적재하여 구동시키는 방식이다. 가상 메모리와 페이지 개념을 활용하여 관리된다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체&quot;&gt;페이지 교체&lt;/h3&gt;

&lt;p&gt;요구 페이징 방식을 사용하게 되면 초기에 필요한 페이지들만 메인 메모리에 올라가게 된다. 프로세스 동작 중에, 필요한 페이지가 물리 메모리에 없는 상황이 발생할 수 있는데 이를 &lt;strong&gt;페이지 부재&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;페이지 부재가 발생하면 원하는 페이지를 하드디스크에 스왑 공간으로부터 가져오게 된다. 하지만 물리 메모리가 모두 사용중이라서 원하는 페이지를 가져오지 못한다면 페이지 교체가 일어난다.&lt;/p&gt;

&lt;h3 id=&quot;스와핑&quot;&gt;스와핑&lt;/h3&gt;

&lt;p&gt;메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 사용하는 것을 스와핑이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘&quot;&gt;페이지 교체 알고리즘&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;FIFO&lt;/strong&gt; : 가장 간단한 방식으로 메모리에 올리온 지 가장 오래된 페이지를 교체하는 알고리즘이다. 페이지가 올라온 순서를 큐에 저장하여 구현한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최적 페이지 교체&lt;/strong&gt; &lt;strong&gt;(OPT)&lt;/strong&gt;: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식이다. 프로세스가 앞으로 사용할 페이지를 미리 알아야 하는데 이는 불가능하기 때문에 구현이 불가능하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LRU (Least Recently Used)&lt;/strong&gt; : 가장 오래 사용되지 않은 페이지를 교체하는 방식이다. OPT 알고리즘보다 페이지 교체 횟수가 높지만  FIFO 알고리즘보다는 효율적이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LFU (Least Frequency Used)&lt;/strong&gt; : 참조 횟수가 가장 적은 페이지를 교체하는 방식이다. 만약 대상인 페이지가 여러개일 경우 LRU 알고리즘에 따라 가장 오래 사용되지 않은 페이지를 교체한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MFU (Most Frequency Used)&lt;/strong&gt; : LFU 알고리즘의 반대로 참조 횟수가 가장 많은 페이지를 교체하는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;스레싱&quot;&gt;스레싱&lt;/h2&gt;

&lt;p&gt;페이지 부재율이 높은 상태를 말한다. 페이지 부재가 발생하면 페이지 교체, 페이지 로드가 일어난다. 다양한 프로세스가 메모리에 올라오면서 메모리의 유효 공간은 줄어들고 CPU의 가동 시간은 올라가며 자원을 최대한 사용하게 된다.&lt;/p&gt;

&lt;p&gt;하지만 메모리의 프로세스가 일정 수 이상 올라가면 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령어가 진행될 때마다 페이지 부재가 발생한다. 이 경우 역으로 CPU 사용률이 줄어들게 된다.&lt;/p&gt;

&lt;p&gt;페이지를 교체하는 과정에서는 CPU가 사용되지 않기 때문에 페이지 교체만 계속해서 실행되면 운영체제는 CPU가 놀고 있다고 판단하고 더 많은 프로세스를 메모리에 적재한다. 이렇게 되면 더 많은 페이지 부재가 발생하는 악순환이 반복된다. 이를 &lt;strong&gt;스레싱&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;해결&quot;&gt;해결&lt;/h3&gt;

&lt;h4 id=&quot;작업-세트&quot;&gt;작업 세트&lt;/h4&gt;

&lt;p&gt;프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 메모리에 로드하는 것을 말한다. 미리 메모리에 로드하면 탐색 비용도 줄일 수 있고 스와핑또한 줄일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;pff&quot;&gt;PFF&lt;/h3&gt;

&lt;p&gt;페이지 폴트 빈도를 조절하는 방식으로 상한선과 하한선을 만드는 방식이다. 만약 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; CPU 사용률과 메모리 적재량을 함께 체크해야 스레싱 유무를 확인할 수 있다.&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">메모리의 종류</summary></entry><entry><title type="html">[운영체제] 블로킹/논블로킹 &amp;amp; 동기/비동기</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/61/" rel="alternate" type="text/html" title="[운영체제] 블로킹/논블로킹 &amp;amp; 동기/비동기" /><published>2024-01-11T00:00:00+09:00</published><updated>2024-01-11T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/61</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/61/">&lt;p&gt;동기/비동기, 블로킹/논블로킹는 서로 비슷해 보이지만 이 둘을 구분하는 기준이 다르다. 동기/비동기는 각 작업(함수)들이 서로 시간을 맞춰서 실행되는지를 기준으로 나뉘고 블로킹/논블로킹은 한 작업을 처리하는 동안 다른 작업을 처리할 수 있는지를 기준으로 나눈다.&lt;/p&gt;

&lt;p&gt;하나씩 살펴보자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;블로킹blocking-과-논블로킹non-blocking&quot;&gt;블로킹(Blocking) 과 논블로킹(Non-Blocking)&lt;/h1&gt;

&lt;p&gt;앞서 말한 것처럼 블로킹/논블로킹은 하나의 작업을 처리하고 있는 상태에서 다른 작업을 처리할 수 있는지를 따진다고 했다. 이는 다른 작업(함수)를 호출했을 때, 현재 작업(함수)가 실행이 차단되는지, 아닌지를 따진다는 것이다.&lt;/p&gt;

&lt;p&gt;블로킹/논블로킹을 설명하는데 &lt;strong&gt;제어권&lt;/strong&gt;, &lt;strong&gt;결과값&lt;/strong&gt;이라는 용어가 자주 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;제어권은 함수 내의 명령어를 실행할 수 있는 권한이고 결과값은 함수의 리턴값이다. 이제 이 2가지 개념을 통해서 블로킹과 논블로킹을 구분해보자.&lt;/p&gt;

&lt;h2 id=&quot;블로킹-blocking&quot;&gt;블로킹 (Blocking)&lt;/h2&gt;

&lt;p&gt;블로킹은 함수를 호출할 때, 제어권을 호출된 함수로 넘긴다. 때문에 제어권을 상실한 호출한 쪽은 자신의 로직을 실행할 수 없고 호출된 함수가 제어권을 돌려줄 때까지 기다려야 한다.&lt;/p&gt;

&lt;h2 id=&quot;논블로킹-non-blocking&quot;&gt;논블로킹 (Non-Blocking)&lt;/h2&gt;

&lt;p&gt;논블로킹도 블로킹 방식과 마찬가지고 함수를 호출하면 제어권이 넘어가지만 곧바로 제어권이 다시 돌아온다. 때문에 실행이 블락되지 않고 자신의 로직을 계속 실행하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;동기synchronous-와-비동기asynchronous&quot;&gt;동기(Synchronous) 와 비동기(Asynchronous)&lt;/h1&gt;

&lt;p&gt;동기와 비동기의 경우는 각 작업(함수)들이 서로 시간을 맞춰서 실행하는지를 따져서 구분한다.&lt;/p&gt;

&lt;h2 id=&quot;동기-synchronous&quot;&gt;동기 (Synchronous)&lt;/h2&gt;

&lt;p&gt;동기는 요청한 작업의 완료 여부를 따져서 처리한다. 이는 다른 말로 호출한 쪽에서 호출된 쪽을 계속 신경쓴다는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 함수 A가 함수 B를 호출했다면 함수A는 함수 B의 종료를 확인할 때까지 계속해서 함수 B의 상태를 확인한다.&lt;/p&gt;

&lt;p&gt;동기의 경우 제어권과 결과값이 동시에 반환된다고 말할수도 있다. 호출된 함수가 결과값을 리턴하는 시점에 제어권이 호출하는 함수쪽으로 넘어가기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;비동기-asynchronous&quot;&gt;비동기 (Asynchronous)&lt;/h2&gt;

&lt;p&gt;비동기의 경우 요청한 작업의 완료 여부를 신경쓰지 않는다. 한번 호출하면 호출된 쪽의 상태를 신경쓰지 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어서 함수 A가 함수 B를 호출했을 때, 함수 A는 함수 B의 종료를 신경쓰지 않고 자신의 로직을 수행한다.&lt;/p&gt;

&lt;p&gt;비동기의 경우는 제어권과 결과값이 따로 반환된다. 제어권은 호출하고 거의 바로 돌려 받지만 결과값은 호출된 함수가 종료되는 시점에 돌려주기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;가능한-조합&quot;&gt;가능한 조합&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_12.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;총 4가지 조합이 가능하며 주로 동기-블로킹, 비동기-논블로킹 조합을 구성한다. 여기서는 이 두가지 경우에 대해서만 자세히 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;동기--블로킹&quot;&gt;동기 &amp;amp; 블로킹&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/61_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동기 &amp;amp; 블로킹 조합은 다른 작업이 수행되는 동안에 자신의 작업은 처리하지 않고 다른 작업의 종료 여부를 받아서 순차적으로 작업을 처리하는 방식이다. 이는 다른 작업이 자신의 작업에 영향을 줄 수 있는 경우에 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;비동기--논블로킹&quot;&gt;비동기 &amp;amp; 논블로킹&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/61_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비동기 &amp;amp; 논블로킹 조합은 다른 작업을 수행할 때도 자신의 작업을 처리하고, 다른 작업의 결과를 기다리지 않는 방식이다. 다른 작업이 자신의 작업에 영향을 주지 않는 경우 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC&quot;&gt;https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://joooing.tistory.com/category&quot;&gt;https://joooing.tistory.com/category&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">동기/비동기, 블로킹/논블로킹는 서로 비슷해 보이지만 이 둘을 구분하는 기준이 다르다. 동기/비동기는 각 작업(함수)들이 서로 시간을 맞춰서 실행되는지를 기준으로 나뉘고 블로킹/논블로킹은 한 작업을 처리하는 동안 다른 작업을 처리할 수 있는지를 기준으로 나눈다.</summary></entry><entry><title type="html">[운영체제] 프로세스 스케줄링</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/60/" rel="alternate" type="text/html" title="[운영체제] 프로세스 스케줄링" /><published>2024-01-10T00:00:00+09:00</published><updated>2024-01-10T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/60</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/60/">&lt;h1 id=&quot;cpu-스케줄링&quot;&gt;CPU 스케줄링&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU 스케줄링은 프로세스가 작업을 수행할 때, 언제 어떤 프로세스에게 CPU를 할당할지를 결정하는 작업이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;분류&quot;&gt;분류&lt;/h2&gt;

&lt;h3 id=&quot;비선점형-알고리즘&quot;&gt;비선점형 알고리즘&lt;/h3&gt;

&lt;p&gt;비선점형 알고리즘은 한번 프로세스가 실행되면 해당 프로세스가 종료되거나 CPU를 자진해서 반납하는 상황이 아니라면 계속 실행되게 하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;선점형 알고리즘과 달리 문맥 교환에 따른 오버헤드는 없지만 사용자에게 동시에 작업이 수행되는 느낌을 줄 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;h4 id=&quot;fcfs-first-come-first-served&quot;&gt;FCFS (First Come First Served)&lt;/h4&gt;

&lt;p&gt;말 그대로 준비큐에 먼저 도착한 순서대로 프로세스가 실행된다.&lt;/p&gt;

&lt;p&gt;예시를 보자. (여기서 Burst Time은 CPU 사용 시간이다. 임의로 단위는 T라고 하자)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세 개의 프로세스 P1, P2, P3가 순서대로 준비큐에 도착했을 때 어떻게 실행되는지 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 준비큐에 가장 먼저 도착한 P1이 CPU를 24T만큼 사용한다. 그리고 준비큐에 두번째로 도착한 P2가 3T만큼 CPU를 가지고 실행한다. 마지막으로 P3가 3T만큼 실행된다.&lt;/p&gt;

&lt;p&gt;예시에서 볼 수 있듯이 P2, P3는 CPU 실행시간이 짧음에도 불구하고 P1의 실행을 기다려야 하기 때문에 대기시간이 길어지는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 작업 시간이 긴 프로세스가 먼저 큐에 도착하여 다른 프로세스의 실행 시간이 전부 늦어져 효율성이 떨어지는 현상을 &lt;strong&gt;콘보이 효과(Convoy effect)&lt;/strong&gt;라고 한다&lt;/p&gt;

&lt;h4 id=&quot;sjf-shortest-job-first&quot;&gt;SJF (Shortest Job First)&lt;/h4&gt;

&lt;p&gt;SJF는 CPU burst가 가장 낮은  프로세스에게 CPU를 먼저 할당하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;예시를 보자. (여기서는 P1, P2, P3, P4가 전부 메모리에 올라가있는 상태라고 가정하자.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU burst가 짧은 순으로 P4, P1, P3, P2가 실행되는 것을 확인할 수 있다. 위의 경우 평균 대기 시간은 (3 + 16 + 9 + 0) / 4 = 7이 된다.&lt;/p&gt;

&lt;p&gt;SJF는 비선점 알고리즘이기 때문에 중간에 준비큐에 CPU burst가 더 짧은 프로세스가 들어와도 중간에 실행되던 프로세스에게서 CPU를 뺏을 수 없다. 그리고 CPU를 얼만큼 사용할지는 실행 전에는 알 수 없기 때문에 이전에 실행한 로그를 토대로 추측한다.&lt;/p&gt;

&lt;p&gt;기본적으로 CPU burst가 작은 프로세스를 우선적으로 실행하기 때문에 CPU burst가 긴 프로세스는 계속해서 실행이 안될 수 있다. 이를 &lt;strong&gt;기아 현상(starvation)&lt;/strong&gt;이라고 한다. (이는 &lt;strong&gt;Aging&lt;/strong&gt;을 통해 해결할 수 있다.)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Aging : 시간이 지날수록 우선순위를 올려주는 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hrn-highest-response-ratio-next&quot;&gt;HRN (Highest Response Ratio Next)&lt;/h4&gt;

&lt;p&gt;HRN은 대기 시간과 처리 시간을 모두 고려하여 CPU를 할당하는 방식이다.&lt;/p&gt;

&lt;p&gt;우선순위 = (대기 시간 + 처리 시간) / 처리 시간&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;선점형-알고리즘&quot;&gt;선점형 알고리즘&lt;/h3&gt;

&lt;p&gt;선점형 알고리즘은 실행 상태에 있는 프로세스의 작업을 강제로 중지하고 새로운 프로세스에게 CPU가 넘어갈 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;선점형 알고리즘의 경우 문맥 교환으로 인해서 오버헤드가 증가하게 된다. 하지만 사용자에게 동시(Concurrency)에 여러 작업이 수행되는 것처럼 보이게 하기 위해서 대부분의 운영체제는 선점형 알고리즘을 사용하여 스케줄링을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;종류-1&quot;&gt;종류&lt;/h3&gt;

&lt;h4 id=&quot;rr-round-robin&quot;&gt;RR (Round Robin)&lt;/h4&gt;

&lt;p&gt;한 프로세스가 할당 받은 시간(time slice)동안 작업을 수행하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 차례를 기다리는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림의 경우 time slice = 4이다. 즉 프로세스가 CPU를 4 burst time 실행하면 다른 프로세스로 CPU가 넘어간다는 것이다.&lt;/p&gt;

&lt;p&gt;P1이 우선 4만큼 실행한 시점에서 20만큼의 CPU burst가 남는데 이를 끝마치지 않고 CPU가 P2 프로세스로 넘어가는 것을 볼 수 있다. P2는 CPU를 3만큼 실행하고 자진해서 CPU를 P3에게 넘겨준다. 그리고 P3도 마찬가지로 3만큼 실행하고 P1으로 CPU를 넘긴다.&lt;/p&gt;

&lt;p&gt;이후 준비큐에 P1을 제외한 다른 프로세스가 존재하지 않기 때문에 P1이 계속해서 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;srt-shortest-remaining-time&quot;&gt;SRT (Shortest Remaining Time)&lt;/h3&gt;

&lt;p&gt;앞에서 살펴본  SJF에서 중간에 CPU를 뺏을 수 있다는 것만 추가됬다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P1이 0T에 준비큐에 도착한 시점에는 P1을 제외한 다른 프로세스가 없기 때문에 바로 실행된다.&lt;/p&gt;

&lt;p&gt;1T에 P2가 도착했는데 이 때 P2의 Burst Time(4)가 P1의 남은 Burst Time(7)보다 짧기 때문에 사용하던 CPU를 뺏어서 P2가 실행된다.&lt;/p&gt;

&lt;p&gt;2T에 P3가 도착했지만 P2의 남은 Burst Time(3)보다 길기 때문에 P2가 그대로 실행된다.&lt;/p&gt;

&lt;p&gt;3T에 P4가 도착했지만 P2의 남은 Burst Time(2)보다 길기 때문에 P2가 그대로 실행된다.&lt;/p&gt;

&lt;p&gt;이후 5T에 P2의 실행이 끝나서 준비큐에 있는 P1(7), P3(9), P4(5) 중 가장 짧은 P4가 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 SRT에서는 실행중인 프로세스보다 현재 준비큐에 도착한 프로세스의 CPU burst가 더 작은 경우 CPU를 강제로 뺏을 수 있다.&lt;/p&gt;

&lt;p&gt;이 경우도 SJF와 마찬가지로 &lt;strong&gt;기아 현상(starvation)&lt;/strong&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;multi-level-feedback-queue&quot;&gt;Multi-Level Feedback Queue&lt;/h3&gt;

&lt;p&gt;여러 개의 준비 큐를 두고, 각 큐에 우선순위를 부여하여 우선순위가 높은 큐에 있는 프로세스에게 CPU를 할당하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;동작&quot;&gt;동작&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;우선순위가 높은 큐에 있는 프로세스가 먼저 실행된다.&lt;/li&gt;
  &lt;li&gt;우선순위가 같다면 RR 방식으로 처리된다.&lt;/li&gt;
  &lt;li&gt;프로세스는 준비큐에 들어오면 가장 높은 우선순위를 가진 큐로 들어간다.&lt;/li&gt;
  &lt;li&gt;프로세스가 주어진 time-slice를 모두 소진하면 한 단계 우선순위가 낮은 큐로 들어간다.&lt;/li&gt;
  &lt;li&gt;프로세스가 time-slice 시간 안에 CPU를 다른 프로세스에게 양도한다면 같은 레벨의 큐에 들어간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Bf2YAyFbreI&quot;&gt;https://www.youtube.com/watch?v=Bf2YAyFbreI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">CPU 스케줄링</summary></entry><entry><title type="html">[운영체제] 프로세스 동기화</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59/" rel="alternate" type="text/html" title="[운영체제] 프로세스 동기화" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59/">&lt;p&gt;프로세스 동기화에 대해서 이해하기 위해서는 우선 임계 영역과 경쟁 상태에 대해서 이해해야 한다. 차례대로 살펴보며 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;임계-영역-critical-section&quot;&gt;임계 영역 (Critical Section)&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;임계 영역(Critical Section)이란 프로세스간에 공유자원을 접근함에 있어서 문제가 발생하지 않도록 한번에 하나의 프로세스만 공유자원에 접근하도록 보장해줘야 하는 영역을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;상호 배제 (Mutual Exclusion)&lt;/strong&gt; : 하나의 프로세스가 임계 영역에 들어가 있으면 다른 프로세스는 들어갈 수 없어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;진행 (Progress)&lt;/strong&gt; : 임계 영역에 들어간 프로세스가 없는 상태에서 임계 영역에 들어가려는 프로세스가 여러 개라면 어느 프로세스가 먼저 들어갈 지 결정할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;한정 대기 (Bounded Waiting)&lt;/strong&gt; : 다른 프로세스의 기아를 방지하기 위해, 한번 임계 영역에 들어간 프로세스는 다음 임계 영역에 들어갈 때 제한을 두어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태-race-condition&quot;&gt;경쟁 상태 (Race Condition)&lt;/h2&gt;

&lt;h2 id=&quot;정의-1&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;경쟁 상태 (Race Condition)란 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값이 접근 순서나 접근 시점에 따라 달라질 수 있는 것을 말한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;경쟁-상태가-발생할-수-있는-상황&quot;&gt;경쟁 상태가 발생할 수 있는 상황&lt;/h2&gt;

&lt;h4 id=&quot;커널-작업-수행-중에-인터럽트가-발생하는-경우&quot;&gt;커널 작업 수행 중에 인터럽트가 발생하는 경우&lt;/h4&gt;

&lt;p&gt;해결 방법 : 커널 모드에서 작업을 수행하는 동안 인터럽트를 disable 시켜서 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스가-시스템콜을-호출하여-커널-모드로-진입하여-작업을-수행하는-도중에-문맥교환이-발생한-경우&quot;&gt;프로세스가 시스템콜을 호출하여 커널 모드로 진입하여 작업을 수행하는 도중에 문맥교환이 발생한 경우&lt;/h4&gt;

&lt;p&gt;프로세스가 커널 모드에서 작업하는 경우에는 CPU 허용 시간이 초과되더라도 CPU 제어권을 다른 프로세스로 넘기지 않게 함으로써 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;멀티-프로세스-환경에서-공유-메모리-내의-커널-데이터에-접근할-경우&quot;&gt;멀티 프로세스 환경에서 공유 메모리 내의 커널 데이터에 접근할 경우&lt;/h4&gt;

&lt;p&gt;커널 내부의 공유 메모리에 접근할 때마다 Lock/UnLock을 하여 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;간단한 예를 살펴보며 이해해 보자.&lt;/p&gt;

&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/58_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 코드에서 counter는 공급자와 소비자가 공유하는 부분이다. 만약 공급자에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;을 하는 시점에 소비자에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 동시에 실행하게 되면 어떻게 될까? (여기서의 counter 연산은 원자적이지 않다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;이라는 연산은 원자적인 연산처럼 보이지만 사실 어셈블러로 내려가면 그렇지 않다. 위의 코드를 보면 알 수 있듯이 3개의 연산으로 쪼개진다.  공급자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;을 호출한 시점에 소비자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 호출한 상황을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;register1에는 6이 저장되고 counter에 옮기는 작업을 하는 중간에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;가 끼어들어서 counter의 값이 6이 되자마자 register2(4)의 값으로 덮어써서 공급자 입장에서 counter값 6을 기대했지만 4가 나오는 결과가 도출된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이러한 문제들을 해결할 수 있을까? 이제부터 이에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스-mutex&quot;&gt;뮤텍스 (Mutex)&lt;/h2&gt;

&lt;h3 id=&quot;정의-2&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;뮤텍스란 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 매커니즘이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;연산&quot;&gt;연산&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Acquire&lt;/strong&gt; : 현재의 임계 구역에 들어갈 권한을 가져온다. 만약 다른 프로세스가 임계 구역에 있다면 나올때까지 대기한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Release&lt;/strong&gt; : 현재의 임계 구역을 모두 사용했음을 알린다. Release후에 다른 프로세스가 임계 구역에 접근할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;boolean 타입의 lock 변수를 통해 잠금 여부를 확인할 수 있고 한 개의 프로세스/스레드만 공유자원을 소유하고 해제할 수 있다. 그리고 대기중인 프로세스/스레드가 busy waiting 방식으로 대기하지 않고 대기 큐에 잠들어서 기다린다.(CPU 자원 소비 X)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;busy waiting&lt;/strong&gt; : CPU의 자원을 지속적으로 사용하며 특정 조건이 만족할 때까지 대기하는 방식 (while 문을 계속 돌고있다고 생각하면 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세마포어-semaphore&quot;&gt;세마포어 (Semaphore)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세마포어는 교착 상태에 대한 해법으로 두 개의 원자적 함수로 제어되는 정수 변수로 멀티프로그래밍 환경에서 공유자원에 대한 접근 제어를 하는 방법으로 사용되며, 1개의 공유되는 자원에 제한된 개수의 프로세스, 또는 스레드만 접근할 수 있도록 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;흐름&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허용되는 공유 자원에 접근할 수 있는 수로 세마포어 값을 초기화한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로세스/스레드가 공유 자원에 접근할 때마다 세마포어 변수의 값을 1감소 시킨다. (세마포어 변수가 0이 되면 꽉찬 것이다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세마포어 변수값이 0이하면 더 이상 접근할 수 없다는 의미이고 세마포어 변수에 절대값을 씌운 값이 현재 대기큐에서 잠들고 있는 프로세스/스레드의 수이다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;뮤텍스와 다르게 한 개 이상의 프로세스/스레드가 공유 자원에 접근할 수 있다. Wait(P) 연산을 통해 공유자원을 획득하고 Signal(V) 연산을 통해 해제한다. 세마포어도 뮤텍스와 마찬가지로 busy waiting 방식이 아닌 대기 큐에서 잠들다가 깨어나는 방식을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;이진 세마포어&lt;/strong&gt; : 세마포어 변수값이 0, 1만 될 수 있으며 최대 한개의 프로세스/스레드가 공유 자원에 접근 가능한 세마포어이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;카운팅 세마포어&lt;/strong&gt; : 최대 n개의 프로세스/스레드가 공유 자원에 접근 가능한 세마포어이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스와-세마포어의-차이점&quot;&gt;뮤텍스와 세마포어의 차이점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;뮤텍스는 소유한 프로세스/스레드만 뮤텍스 락을 변경할 수 있다. 반면 세마포어는 여러 프로세스/스레드가 세마포어 변수값을 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;뮤텍스는 세마포어로 사용될 수 없지만 세마포어는 뮤텍스로서 사용될 수 있다.&lt;/li&gt;
  &lt;li&gt;세마포어는 실행순서의 동기화를 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착상태-dead-lock&quot;&gt;교착상태 (dead lock)&lt;/h2&gt;

&lt;h2 id=&quot;정의-3&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;둘 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;교착상태-조건&quot;&gt;교착상태 조건&lt;/h2&gt;

&lt;h3 id=&quot;비선점-non-preemptive&quot;&gt;비선점 (Non Preemptive)&lt;/h3&gt;

&lt;p&gt;다른 프로세스가 사용하고 있는 자원을 선점할 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;순환-대기-circular-wait&quot;&gt;순환 대기 (Circular wait)&lt;/h3&gt;

&lt;p&gt;두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조를 이룬다.&lt;/p&gt;

&lt;h3 id=&quot;점유-대기-hold-and-wait&quot;&gt;점유 대기 (Hold and Wait)&lt;/h3&gt;

&lt;p&gt;공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구한다.&lt;/p&gt;

&lt;h3 id=&quot;상호-배제-mutual-exclusion&quot;&gt;상호 배제 (Mutual Exclusion)&lt;/h3&gt;

&lt;p&gt;한번에 한 프로세스만 공유 자원에 접근이 가능하며, 접근 권한이 제한적이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 위 4가지 조건중에 한 가지라도 만족하지 않으면 데드락은 발생하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;교착상태-예시&quot;&gt;교착상태 예시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원 R1을 가진 P1과 자원 R2를 가진 P2가 있다. P1은 R2를 필요로 하고 P2는 R1을 필요로 한다면 두 프로세스는 서로의 자원을 얻기 위해 무한정 기다리는 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착상태-해결&quot;&gt;교착상태 해결&lt;/h2&gt;

&lt;p&gt;위에 설명한 4가지 조건중 하나를 만족시키지 않게 상태를 변경하면 된다. 하지만 변경에 여러 비용이 수반된다. 현대의 운영체제는 교착상태가 발생하면 강제 종료를 시켜서 해결한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NL9JQh5bbZ8&quot;&gt;https://www.youtube.com/watch?v=NL9JQh5bbZ8&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">프로세스 동기화에 대해서 이해하기 위해서는 우선 임계 영역과 경쟁 상태에 대해서 이해해야 한다. 차례대로 살펴보며 이해해보자.</summary></entry><entry><title type="html">[운영체제] 스레드</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58/" rel="alternate" type="text/html" title="[운영체제] 스레드" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58/">&lt;h1 id=&quot;스레드&quot;&gt;스레드&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드는 프로세스 내의 여러 실행 흐름의 단위이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;프로세스내의 스레드끼리는 Stack을 제외한 메모리 공간 (Code, Data, Heap)을 공유한다. 메모리 공간을 공유하기 때문에 하나의 스레드에서 오류가 발생한다면 다른 스레드에서 영향을 받을 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;독립적으로-할당되는-자원&quot;&gt;독립적으로 할당되는 자원&lt;/h3&gt;

&lt;p&gt;그렇다면 스레드마다 별도로 할당되는 자원에는 어떤게 있을까? &lt;strong&gt;Stack&lt;/strong&gt;과 &lt;strong&gt;Reigster&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;각 스레드가 독립적인 Stack을 가지는 이유는 함수의 실행과 연관된다. 독립적으로 Stack을 가진다는 말은 곧 독립적인 함수 호출이 가능하다는 뜻이다. 즉 프로세스 내에서 독립적인 실행 흐름을 만들 수 있다는 것이다. 때문에 Stack은 각 스레드마다 별도로 가지고 있어야 한다.&lt;/p&gt;

&lt;p&gt;그리고 스레드는 별도의 Register를 가지는데 여기서 의문이 있을 것이다. Register는 프로세서에 있는 친구아닌가?&lt;/p&gt;

&lt;p&gt;여기서 말하는 Register란 현재 스레드의 실행 정보가 저장된 상태값이다. 시분할 시스템에서는 문맥교환이 발생하게 되는데 문맥교환이 발생하면 스레드의 경우는 Code, Data, Heap은 공유하기 때문에 자신의 Stack 상태와 어디까지 실행했는지에 대한 정보(PC)만 저장하면 된다. 이 때, 현재 상태가 저장되기 때문에 Register 값이 저장되게 되는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 이유로 각 스레드는 Register를 별도로 가진다고 하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;문맥교환-context-switching&quot;&gt;문맥교환 (Context Switching)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;문맥교환이란 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말한다. 한 프로세스의 문맥은 그 프로세스의 PCB에 저장되어 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;발생-상황&quot;&gt;발생 상황&lt;/h4&gt;

&lt;p&gt;문맥교환은 인터럽트 발생, 실행중인 프로세스의 CPU 허용 시간 초과, 입출력 대기시에 발생하게 된다.&lt;/p&gt;

&lt;p&gt;문맥교환을 하는 동안에 CPU는 아무것도 하지 않게 된다. 그럼에도 불구하고 문맥교환을 하는 이유는 I/O와 같은 작업이 발생하여 CPU가 블록되는 시간이 문맥교환 시간보다 길기 때문에 문맥교환을 하여 다른 프로세스를 실행하는 것이 CPU 사용률을 높일 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레드&quot;&gt;멀티 스레드&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 스레드란 하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하며 작업을 수행하는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;멀티 스레드는 하나의 프로세스의 자원을 공유하기 때문에 멀티 프로세스보다 더 적은 메모리를 차지한다.그리고 메모리(Code, Data, Heap)를 공유하기 때문에 문맥교환 속도가 더 빠르다.&lt;/p&gt;

&lt;p&gt;하지만 오류로 인해서 하나의 스레드에 문제가 발생하게 된다면 전체 스레드에 영향을 줄 수도 있다. 그리고 메모리를 공유하기 때문에 동기화에 신경써서 프로그래밍해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레드-vs-멀티-프로세스&quot;&gt;멀티 스레드 vs 멀티 프로세스&lt;/h2&gt;

&lt;p&gt;일반적으로 멀티 스레드 방식을 더 많이 사용한다. 왜 그럴까?&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식의 경우 문맥 교환을 할 때, 스택 영역만 초기화하면 되기 때문에 속도가 빠르다. 그리고 프로세스의 경우 생성할 때 &lt;strong&gt;시스템콜&lt;/strong&gt;을 호출하게 되기 때문에 멀티 스레드 방식에 비해서 비효율적이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템콜 : 사용자나 응용프로그램이 커널에서 제공하는 기능을 사용하기 위한 인터페이스를 의미한다.
    &lt;ul&gt;
      &lt;li&gt;커널이 제공하는 서비스를 시스템콜을 통해서만 접근하게 제한함으로써 컴퓨터 자원을 보호하면서 사용자나 응용프로그램에게 서비스를 제공할 수 있게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;스레드는 프로세스 내의 여러 실행 흐름 단위로서 프로세스의 자원을 사용하게 된다.&lt;/p&gt;

&lt;p&gt;프로세스 내에 여러 스레드가 있을 때, 스레드끼리 메모리(Code, Date, Heap)을 공유하며 Stack, Register는 별도로 가진다.&lt;/p&gt;

&lt;p&gt;일반적으로 멀티 프로세스 방식보다는 멀티 스레드 방식을 많이 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">스레드</summary></entry><entry><title type="html">[운영체제] 좀비 프로세스 vs 고아 프로세스</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57/" rel="alternate" type="text/html" title="[운영체제] 좀비 프로세스 vs 고아 프로세스" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/57/">&lt;p&gt;좀비 프로세스와 고아 프로세스를 이해하기 위해서 먼저 프로세스를 생성하는 과정을 좀 더 자세하게 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;프로세스-생성&quot;&gt;프로세스 생성&lt;/h1&gt;

&lt;p&gt;부모 프로세스는 시스템 콜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;를 통해서 자식 프로세스를 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;는 부모 프로세스의 주소 공간을 그대로 복사한다. 이 상태에서 시스템 콜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt;을 호출하게 되면 생성된 자식 프로세스의 메모리 공간을 새로운 프로그램으로 대체할 수 있다. 이러한 과정을 통해 부모와 다른 실행 흐름을 가진 자식 프로세스를 생성할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;자식-프로세스-트리&quot;&gt;자식 프로세스 트리&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/57_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리눅스에서는 커널이 자체적으로 생성한 init 프로세스가 있고 이후에 생성된 모든 프로세스는 init의 자손이 되며 트리구조를 이룬다.&lt;/p&gt;

&lt;p&gt;일단 모든 프로세스의 조상 프로세스는 커널이 생성한 init이라는 것만 기억하고 넘어가자. (아래에 설명하겠다.)&lt;/p&gt;

&lt;h2 id=&quot;실행-흐름&quot;&gt;실행 흐름&lt;/h2&gt;

&lt;p&gt;위에서 자식 프로세스를 생성하는 방법을 설명했다. 그렇다면 이렇게 생성된 자식 프로세스와 부모 프로세스는 어떤 방식으로 실행될 수 있을까?&lt;/p&gt;

&lt;p&gt;결론부터 말하자면 2가지 흐름이 있을 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모 프로세스가 자식 프로세스의 종료까지 기다리고 이후에 실행한다.&lt;/li&gt;
  &lt;li&gt;부모 프로세스와 자식 프로세스를 동시에 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1번-케이스&quot;&gt;1번 케이스&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/57_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우는 부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하여 자식 프로세스의 종료를 기다린다. 그리고 자식 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;을 호출하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;의 파라미터로 자식 프로세스의 상태가 들어오게 되는데 이를 통해서 자식 프로세스가 사용하던 자원을 모두 반납한다.&lt;/p&gt;

&lt;p&gt;이 경우는 별다른 문제가 없는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2번-케이스&quot;&gt;2번 케이스&lt;/h3&gt;

&lt;p&gt;이 케이스는 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않는다. 부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않는다면 어떤 일이 생길까?&lt;/p&gt;

&lt;p&gt;이제 좀비 프로세스와 고아 프로세스가 등장한다.&lt;/p&gt;

&lt;h2 id=&quot;좀비-프로세스&quot;&gt;좀비 프로세스&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;좀비 프로세스는 자식 프로세스가 부모 프로세스보다 먼저 종료된 프로세스를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정의만 보면 무슨말인지 잘 이해가 안될 것이다. 자식 프로세스가 종료되면 종료된 것 아닌가?&lt;/p&gt;

&lt;p&gt;여기서 주목해야 하는 점은 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 을 호출하지 않았다는 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않았기 때문에 자식 프로세스가 종료되더라도 종료에 대한 정보가 부모 프로세스에 전달되지 못하고 사용하던 리소스를 반납할 방법이 없어진다.&lt;/p&gt;

&lt;p&gt;종료되도 리소스가 계속 남아있기 때문에 &lt;strong&gt;좀비 프로세스&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;커널은 이런 상황을 대비하여 프로세스에 대한 최소한의 정보를 저장하고 있다. 이후에 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하여 남아있는 리소스를 제거할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;고아-프로세스&quot;&gt;고아 프로세스&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;고아 프로세스는 부모 프로세스가 자식 프로세스보다 먼저 종료된 프로세스를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 경우도 좀비 프로세스 경우와 마찬가지로 부모 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않은 경우에 발생한다.&lt;/p&gt;

&lt;p&gt;부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않고 자신의 로직을 수행하다 자식 프로세스보다 먼저 종료되면 자식 프로세스는 종료됐을 때 리소스를 반납해줄 주체가 없어진다. 이렇게 부모가 없이 남겨진 프로세스를 &lt;strong&gt;고아 프로세스&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;이렇게 부모가 사라진 경우 고아 프로세스는 위에서 설명한 init 프로세스의 자식 프로세스가 된다. init 프로세스는 이 프로세스가 종료되면 리소스를 회수하고 정상적으로 프로세스를 제거한다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;좀비 프로세스 : 부모가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;을 호출하지 않은 상태에서 자식 프로세스가 종료되어 리소스를 반납하지 못하는 프로세스&lt;/p&gt;

&lt;p&gt;고아 프로세스 : 부모가 먼저 종료되서 남겨진 프로세스&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://itstory1592.tistory.com/89&quot;&gt;https://itstory1592.tistory.com/89&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">좀비 프로세스와 고아 프로세스를 이해하기 위해서 먼저 프로세스를 생성하는 과정을 좀 더 자세하게 알아보자.</summary></entry><entry><title type="html">[운영체제] 프로세스</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56/" rel="alternate" type="text/html" title="[운영체제] 프로세스" /><published>2023-12-27T00:00:00+09:00</published><updated>2023-12-27T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/56/">&lt;h1 id=&quot;프로세스&quot;&gt;프로세스&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스는 컴퓨터에서 실행 중인 프로그램을 말한다. 프로그램이 메모리에 올라가면 프로세스가 되고 CPU에 의해서 프로세스가 실행된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;각 프로세스는 서로 완전히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않는다. 때문에 한 프로세스에서 오류가 발생하더라도 다른 프로세스에 영향을 주지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;상태&quot;&gt;상태&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;new&quot;&gt;new&lt;/h3&gt;

&lt;p&gt;프로세스가 생성된 상태&lt;/p&gt;

&lt;h3 id=&quot;ready&quot;&gt;ready&lt;/h3&gt;

&lt;p&gt;프로세스가 CPU 할당을 기다리고 있는 상태&lt;/p&gt;

&lt;p&gt;CPU만 받으면 바로 실행할 수 있는 상태이다.&lt;/p&gt;

&lt;h3 id=&quot;running&quot;&gt;running&lt;/h3&gt;

&lt;p&gt;프로세스가 CPU를 할당 받아서 명령어를 실행하고 있는 상태이다.&lt;/p&gt;

&lt;h3 id=&quot;waiting&quot;&gt;waiting&lt;/h3&gt;

&lt;p&gt;프로세스가 이벤트가 발생할 때까지 대기하고 있는 상태&lt;/p&gt;

&lt;h3 id=&quot;terminated&quot;&gt;terminated&lt;/h3&gt;

&lt;p&gt;프로세스가 종료된 상태&lt;/p&gt;

&lt;p&gt;프로세스가 소유한 모든 자원을 반납하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-구조&quot;&gt;메모리 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드-영역-code&quot;&gt;코드 영역 (code)&lt;/h3&gt;

&lt;p&gt;실행할 프로그램의 코드가 저장되는 영역이다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서(fetch) 실행(execution)한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-영역-data&quot;&gt;데이터 영역 (data)&lt;/h3&gt;

&lt;p&gt;전역변수, 정적변수가 저장되는 영역으로 프로그램이 시작될 때 할당되며 프로그램이 종료할 때 소멸한다.&lt;/p&gt;

&lt;h3 id=&quot;힙-영역-heap&quot;&gt;힙 영역 (heap)&lt;/h3&gt;

&lt;p&gt;메모리 공간이 동적으로 할당되고 헤제되는 영역이다.&lt;/p&gt;

&lt;p&gt;낮은 주소에서 높은 주소로 채워진다.&lt;/p&gt;

&lt;h3 id=&quot;스택-영역-stack&quot;&gt;스택 영역 (stack)&lt;/h3&gt;

&lt;p&gt;함수 호출에 따른 지역변수와 매개변수가 저장되는 영역이다. 함수가 호출될 때마다 호출될 떄의 환경 등 특정 정보가 스택에 계속 저장된다.&lt;/p&gt;

&lt;p&gt;높은 주소에서 낮은 주소로 채워진다.&lt;/p&gt;

&lt;h4 id=&quot;힙과-스택의-차이&quot;&gt;힙과 스택의 차이&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/56_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pcb&quot;&gt;PCB&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;PCB는 프로세스 제어 블록으로 프로세스를 관리하기 위한 정보를 포함하는 운영체제 커널의 자료구조이다. 프로세스의 중요한 정보를 저장하고 있기 때문에 보호된 메모리에 저장된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;구조&quot;&gt;구조&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로세스 식별자&lt;/strong&gt; :  프로세스 식별변호&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로세스 상태&lt;/strong&gt; : new, ready, running, wating, terminated 등의 상태를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그램 카운터 (PC)&lt;/strong&gt; : 프로세스가 다음에 실행할 명령어의 주소를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 레지스터&lt;/strong&gt; : 프로세스를 실행하기 위해 저장해야 할 레지스터 정보&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 스케줄링 정보&lt;/strong&gt; : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;계정 정보&lt;/strong&gt; : 프로세스 실행에 사용된 CPU 사용량, 실행 유저 정보&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메모리 관리 정보&lt;/strong&gt; : 페이지, 세그먼트 테이블 등과 같은 정보를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O 상태 정보&lt;/strong&gt; : 프로세스에 할당된 I/O 디바이스 목록&lt;/p&gt;

&lt;h2 id=&quot;멀티-프로세싱&quot;&gt;멀티 프로세싱&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러 개의 프로세스를 통해서 병렬적으로 작업을 수행하는 것을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;프로세스끼리는 메모리를 공유하지 않기 때문에 하나의 프로세스에 문제가 발생하더라도 다른 프로세스에 영향을 끼치지 않는다.&lt;/p&gt;

&lt;p&gt;하지만 멀티 스레드 방식보다 많은 양의 메모리 공간과 CPU를 차지한다는 단점이 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Operating System Concepts&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;면접을 위한 CS 전공지식 노트&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">프로세스</summary></entry><entry><title type="html">[Spring] Spring Security (진행중)</title><link href="http://localhost:4000/spring/55/" rel="alternate" type="text/html" title="[Spring] Spring Security (진행중)" /><published>2023-12-21T00:00:00+09:00</published><updated>2023-12-21T00:00:00+09:00</updated><id>http://localhost:4000/spring/55</id><content type="html" xml:base="http://localhost:4000/spring/55/">&lt;h1 id=&quot;스프링-시큐리티&quot;&gt;스프링 시큐리티&lt;/h1&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;애플리케이션을 개발함에 있어서 보안은 굉장히 중요한 이슈이다. 보안이 뚫리게 되면 단순히 데이터, 돈을 잃는 것을 넘어서 수년간 쌓아온 브랜드 평판과 유저로부터의 신뢰를 한번에 잃을 수 있다. 그렇다고 애플리케이션을 만들때마다 자체 보안 시스템을 만드는 것은 매우 비효율적이다. 기능적으로 문제가 발생할 위험도 있고 많은 시간과 돈이 들어간다. 스프링은 이런 문제를 해결해주기 위해 스프링 시큐리티라는 스프링 하부 프레임워크를 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;흐름&quot;&gt;흐름&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 가장 기본적인 Security의 흐름을 보여준다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;클라이언트로부터 HTTP 요청이 들어오면 Spring Security의 필터가 이를 가로챈다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;요청에 들어있는 유저의 아이디, 패스워드를 추출하여 Authentication을 구현한 UsernamePasswordAuthenticationToken을 생성하고 AuthenticationManager를 구현한 ProviderManager의 authenticate()메서드를 호출하며 이를 넘겨준다.&lt;/li&gt;
  &lt;li&gt;ProviderManager는 모든 AuthenticationProvider를 순차적으로 호출하여 인증을 수행한다.&lt;/li&gt;
  &lt;li&gt;AuthenticationProvider에서는 UserDetailService/UserDetailManager와 PasswordEncoder의 도움을 받아 인증을 수행하며 Authentication 객체를 반환한다.&lt;/li&gt;
  &lt;li&gt;인증에 성공하게 되면 AuthenticationManager는 Authentication 객체를 반환하고 필터에서 이를 받아 SecurityContextHolder 내부의 Context에 인증 객체를 저장하게 된다.&lt;/li&gt;
  &lt;li&gt;만약 실패하게 되면 AuthenticationManager는 또 다른 AuthenticationProvider를 호출하여 위 과정을 계속 반복하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 각각의 역할에 대해서 더 자세하게 알아보자&lt;/p&gt;

&lt;h2 id=&quot;spring-security-filter&quot;&gt;Spring Security Filter&lt;/h2&gt;

&lt;h3 id=&quot;defaultloginpagegeneratorfilter&quot;&gt;DefaultLoginPageGeneratorFilter&lt;/h3&gt;

&lt;p&gt;스프링 시큐리티 의존성을 추가하고 우리의 서비스에 접근하려고 하면 아래와 같은 로그인 페이지로 넘어가지는 경험을 해봤을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 로그인 기능을 구현한 필터가 바로 DefaultLoginPageGeneratorFilter이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요청으로부터 로그인 정보를 확인하여 로그인을 하지 않은 상태라면 위와 같은 로그인 페이지를 만든다. 실질적으로 로그인 페이지를 만드는 로직은 generateLoginPageHtml()메서드 안에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한땀한땀 html 코드가 작성되어 있는 것을 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;usernamepasswordauthenticationfilter&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 UsernamePasswordAuthenticationFilter이다. 코드를 보면 request로부터 유저의 아이디, 패스워드를 추출하고 Authentication을 구현한 UsernamePasswordAuthenticationToken을 생성하는 것을 볼 수 있다. 그리고 AuthenticationManager의 authenticate() 메서드를 호출하며 이를 넘기는 것을 볼 수 있다. 그렇다면 이 UsernamePasswordAuthenToken의 정체는 무엇일까?&lt;/p&gt;

&lt;p&gt;아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/55_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Authentication 객체는 현재 요청하고 있는 주체의 정보가 들어있다. 이 객체는 SecurityContextHolder 안의 ContextHolder에 실질적으로 저장되는 유저의 정보이기도 하다. 뜬금없이 Authentication에 대해서 설명한 이유는 UsernamePasswordAuthenticationToken이 authentication을 구현한 클래스이기 때문이다. (실제로는 AbstractAuthenticationToken을 상속받는데 이 추상 클래스가 Authentication을 구현하고 있다.)&lt;/p&gt;

&lt;h3 id=&quot;usernamepasswordauthenticationtoken&quot;&gt;UsernamePasswordAuthenticationToken&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UsernamePasswordAuthenticationToken을 보면 두 개의 생성자가 있는 것을 볼 수 있다. 위 생성자는 내부에서 setAuthenticated(false)로 인증 실패 상태를 넣는 것을 볼 수 있고 아래는 true를 넣어 성공 상태를 넣는다. 우리가 위에서 설명한 UsernamePasswordAuthenticationFilter 내부에서는 첫번째 생성자를 이용하여 객체를 생성한다.&lt;/p&gt;

&lt;p&gt;그렇다면 두번째 생성자는 언제 사용될까? AuthenticationProvider에서 실질적인 인증을 수행한 후 인증에 성공하면 Authentication 객체를 반환하는데 이 때 두번째 생성자를 사용하게 된다.&lt;/p&gt;

&lt;p&gt;다음으로 AuthenticationManager에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;authenticationmanager&quot;&gt;AuthenticationManager&lt;/h2&gt;

&lt;p&gt;AuthenticationManager는 인터페이스이고 단 하나의 메소드 authenticate()를 정의하고 있다. AuthenticationManager를 구현한 ProviderManager내부의 authenticate() 메서드 내부를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/55_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 반복문을 활용하여 가지고 있는 모든 Provider를 활용하여 인증을 시도한다. 모든 Provider에 대해서 인증이 실패하면 실패 Authentication 객체를 반환하고 성공하&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="Spring" /><category term="Spring" /><category term="Security" /><summary type="html">스프링 시큐리티</summary></entry><entry><title type="html">[디자인패턴] 커맨드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/" rel="alternate" type="text/html" title="[디자인패턴] 커맨드 패턴" /><published>2023-12-10T00:00:00+09:00</published><updated>2023-12-10T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/">&lt;h1 id=&quot;커맨드-패턴&quot;&gt;커맨드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요구사항(요청, 명령)을 객체로 캡슐화하여 서로 다른 요구사항을 가진 클라이언트를 매개변수화시킬 수 있고 요구사항을 큐에 넣어 로그를 남기거나 작업을 취소할 수 있는 기능을 가능하게 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;invoker&quot;&gt;Invoker&lt;/h3&gt;

&lt;p&gt;요청을 받고 이를 실행시키는 역할을 수행한다. Command 인터페이스만 알고 있으며 실제로 Command가 어떻게 실행되는지는 알지 못한다.&lt;/p&gt;

&lt;h3 id=&quot;command&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt; 메소드를 선언한다.&lt;/p&gt;

&lt;h3 id=&quot;concretecommand&quot;&gt;ConcreteCommand&lt;/h3&gt;

&lt;p&gt;Command 인터페이스를 구현하며 맴버 변수로 Receiver를 가지고 있다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Receiver 메소드를 호출하여 로직이 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;receiver&quot;&gt;Receiver&lt;/h3&gt;

&lt;p&gt;실제 명령이 실행되는 부분이다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;h4 id=&quot;1-실제로-실행하는-객체receiver와-실행을-요청하는-객체invoker를-분리하여-결합도를-낮춘다&quot;&gt;1. 실제로 실행하는 객체(Receiver)와 실행을 요청하는 객체(Invoker)를 분리하여 결합도를 낮춘다.&lt;/h4&gt;

&lt;p&gt;Invoker는 Reciver를 알지 못한 채로 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드를 통해 실행을 하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-기존의-코드를-수정하지-않고도-새로운-명령을-추가할-수-있다-ocp-원칙&quot;&gt;2. 기존의 코드를 수정하지 않고도 새로운 명령을 추가할 수 있다. (OCP 원칙)&lt;/h4&gt;

&lt;p&gt;새로운 명령이 추가되도 Invoker를 수정하지 않고 Revicer와  Command만 구현하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;h4 id=&quot;1-새로운-명령이-생길때마다-클래스가-추가되기-때문에-코드-복잡성이-증가할-수-있다&quot;&gt;1. 새로운 명령이 생길때마다 클래스가 추가되기 때문에 코드 복잡성이 증가할 수 있다.&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 이제 예제를 보면서 이해해보자!&lt;/p&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;다음과 같은 기능을 가진 리모컨을 생각해보자.&lt;/p&gt;

&lt;h3 id=&quot;리모컨-기능&quot;&gt;리모컨 기능&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;전등  ON/OFF&lt;/li&gt;
  &lt;li&gt;TV ON/OFF&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 표현하기 위해서는 리모컨, 전등, TV 클래스가 필요할 것이다. 아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;remote-class&quot;&gt;Remote Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리모컨 클래스이다. 불끄기, 불켜기, Tv켜기, Tv끄기 메소드를 가진다.&lt;/p&gt;

&lt;h3 id=&quot;light--tv-class&quot;&gt;Light &amp;amp; Tv Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 이 상황에서 새로운 요구사항이 생겼다고 가정해보자.&lt;/p&gt;

&lt;h4 id=&quot;추가된-요구사항&quot;&gt;추가된 요구사항&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;리모컨을 통해 프로젝트를 켜고 끄는 기능을 추가해주세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 만족시키기 위해서는 Remote 클래스에 맴버 변수로 Project를 추가하고 Project를 켜고 끄는 메소드를 추가해야 한다. 이는 기존 코드인 Remote를 수정하는 것이기 때문에 OCP를 위반하게 된다. 커맨드 패턴을 적용하면 요청을 호출하는 Remote 클래스와 실제 실행이 되는 Tv, Light 클래스 사이의 결합도를 낮추고 새로운 요구사항(프로젝트 Up/Down)이 생겼을 때 기존 코드(Remote 클래스)를 손보지 않고 기능을 추가할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;코드를 통해서 확인해보자!&lt;/p&gt;

&lt;h3 id=&quot;커맨드-패턴을-적용한-코드&quot;&gt;커맨드 패턴을 적용한 코드&lt;/h3&gt;

&lt;h3 id=&quot;command-1&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령을 추상화한 Command 인터페이스이다.&lt;/p&gt;

&lt;h3 id=&quot;project-receiver&quot;&gt;Project (Receiver)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 추가된 명령을 수행하는 Project 클래스이다. 위의 클래스 다이어그램에서 설명했던 Receiver 역할을 수행하는 클래스이다.&lt;/p&gt;

&lt;p&gt;앞서 봤던 Light, Tv도 모두 Receiver이다. (Light, Tv는 코드가 동일하니 위의 코드를 참고하자.)&lt;/p&gt;

&lt;h3 id=&quot;lightoncommandlightoffcommand-concrete-command&quot;&gt;LightOnCommand/LightOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Command 인터페이스를 구현하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Light(Receiver)의 메소드를 호출한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Remote 클래스(Invoker)와 Light 클래스(Receiver) 사이의 결합도를 낮추게 된다.&lt;/p&gt;

&lt;h3 id=&quot;tvoncommandtvoffcommand-concrete-command&quot;&gt;TvOnCommand/TvOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 설명한 Light의 경우와 완전히 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;projectoncommandprojectoffcommand-concrete-command&quot;&gt;ProjectOnCommand/ProjectOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 Light, Tv와 완전히 동일하니 설명은 생략한다.&lt;/p&gt;

&lt;h3 id=&quot;remote-invoker&quot;&gt;Remote (Invoker)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remote 클래스는 Command 인터페이스에만 의존한다. 때문에 실제로 각 ConcreteCommand가 어떤 Recevier를 호출하는지 알지 못한다.&lt;/p&gt;

&lt;p&gt;커맨드를 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setCommand()&lt;/code&gt;, On/Off 버튼을 누르는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onButtonPush()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offButtonPush()&lt;/code&gt;메소드를 가지고 있다.&lt;/p&gt;

&lt;p&gt;이 함수 내부에서는 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 새로운 기능을 추가함에 있어서 기존 코드를 수정할 필요가 없다 (OCP원칙). 그저 새로운 Receiver (여기서는 Project)와 ConcreteCommand(ProjectOnCommand, ProjectOffComand)만 새로 만들면 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;커맨드 패턴을 사용하면 실행을 요청하는 객체와 실제 실행하는 객체 사이의 결합도를 낮출 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 새로운 요구사항이 발생해도 유연하게 대처할 수 있다. 하지만 관리해야 하는 객체의 수가 늘어나기 때문에 무분별한 사용은 코드의 복잡도를 증가시킬 수 있다.&lt;/p&gt;

&lt;p&gt;무작정 적용하기보다는 꼭 필요한 곳에만 사용하도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">커맨드 패턴</summary></entry></feed>