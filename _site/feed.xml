<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-30T21:23:53+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[프로젝트] Spring Interceptor 인증/인가</title><link href="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/spring/67/" rel="alternate" type="text/html" title="[프로젝트] Spring Interceptor 인증/인가" /><published>2024-04-29T00:00:00+09:00</published><updated>2024-04-29T00:00:00+09:00</updated><id>http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/spring/67</id><content type="html" xml:base="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/spring/67/">&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;

&lt;p&gt;이전에는 Spring Security를 사용하여 인증/인가 처리를 해왔는데 이번 프로젝트(talk-talk)에서는 Spring에 대한 이해도 높일겸 interceptor에서 인증/인가를 구현해봤다.&lt;/p&gt;

&lt;h2 id=&quot;인터셉터&quot;&gt;인터셉터&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://mangkyu.tistory.com/173&quot;&gt;https://mangkyu.tistory.com/173&lt;/a&gt; [MangKyu’s Diary:티스토리]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터셉터는 J2EE 표준 스펙인 필터와 달리 Spring에서 제공하는 기술로써, DispatcherServlet이 컨트롤러를 호출하기 전 ,후에 요청과 응답을 참조하거나 조작할 수 있다. DispatcherServlet에서는 핸들러 매핑을 통해서 적절한 컨트롤러를 찾는데 이 응답값으로 HandlerExcurtionChain을 반환한다. 만약 1개 이상의 인터셉터가 등록되어 있다면 순차적으로 인터셉터를 실행하고 컨트롤러를 호출하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DispatcherServlet이 컨트롤러 호출 전후 요청, 응답을 조작할 수 있기 떄문에 인터셉터에서 인증/인가 처리를 하면 깔끔하다. 물론 Spring Security를 사용하여 Filter에서 인증/인가를 구현할 수도 있고 Aop를 사용하여 처리할 수도 있다.&lt;/p&gt;

&lt;p&gt;이제 인터셉터를 등록해보자.&lt;/p&gt;

&lt;h2 id=&quot;인터셉터-등록&quot;&gt;인터셉터 등록&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/68_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인터셉터를 등록하기 위해서는 WebMvcConfigurer를 구현하여 addInterceptors()를 오버라이딩하고 우리가 만든 인터셉터를 추가해주면 된다.&lt;/p&gt;

&lt;p&gt;위의 코드에서는  ArgumentResolver도 추가돼있는 것을 볼 수 있는데 이는 컨트롤러에서 인증된 사용자 정보를 받아서 쓰기 위해서이다. Spring Security의 @AuthenticationPrinciple과 같은 맥락이라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;참고) Spring Security에서는 SecurityContextHolder에 저장한 인증 객체를 컨트롤러에서 @AuthenticationPrinciple 어노테이션을 통해서 가져올 수 있다.&lt;/p&gt;

&lt;p&gt;이제 등록을 완료했으니 인터셉터를 구현해보자.&lt;/p&gt;

&lt;h2 id=&quot;authenticationinterceptor&quot;&gt;AuthenticationInterceptor&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/68_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 커스텀 인터셉터는 HandlerInterceptor를 구현해야 한다. HandlerInterceptor에는 총 3개의 메서드가 있는데 우리는 컨트롤러 이전에 호출되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preHandle()&lt;/code&gt;만 구현하여 인증/인가를 처리할 것이다.&lt;/p&gt;

&lt;p&gt;먼저 isRequiredAuth() 메서드는 로그인이 필요한 API인지 확인하는 메서드이다. 로그인, 회원가입등 로그인이 요구되지 않는 API가 있을 것이다. 이런 API는 인증을 수행할 필요가 없다.&lt;/p&gt;

&lt;p&gt;그리고 요청으로부터 payload를 꺼내서 실제 유저가 존재하는 지 검증하고 setAttribute() 를 통해서 방금 꺼낸 payload 값인 memberId를 request에 넣어준다. 이렇게 해주는 이유는 컨트롤러에 인증 객체를 파라미터로 넘겨주기 위해서다.&lt;/p&gt;

&lt;p&gt;각각의 메서드를 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;isrequiredauth&quot;&gt;isRequiredAuth&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컨트롤러 메서드에 달린 어노테이션중에 @PreAuthorize가 붙은 API에 대해서만 true를 반환한다. 따라서 위에서 로그인이 필요 없으면 그냥 넘어가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;extractmemberidfromrequest&quot;&gt;extractMemberIdFromRequest&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단순히 request 로부터 토큰을 파싱하여 payload를 꺼내는 부분이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;authresolver&quot;&gt;AuthResolver&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AuthResolver에서는 인증된 유저가 요구되는 컨트롤러의 파라미터를 세팅해주기 위해서 필요하다. supportsParameter에서 AuthMember 파라미터를 가진 컨트롤러들에 대해서 해당 리졸버가 동작하게 된다.&lt;/p&gt;

&lt;p&gt;resolveArgument에서는 인터셉터에서 세팅한 유저의 정보(id)를 바탕으로 유저를 찾고 인증 객체를 생성하여 반환한다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 컨트롤러에서 인증 객체(AuthMember)를 파라미터로 꺼내서 사용할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;authmember를-사용하는-컨트롤러&quot;&gt;AuthMember를 사용하는 컨트롤러&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/68_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제 컨트롤러 부분이다. 필자가 커스텀한 어노테이션(@PreAuthorize)가 붙어 있는 것을 확인할 수 있다. @PreAuthorize 어노테이션이 붙어 있으면 위에 설명한 AuthInterceptor에서 isRequiredAuth()가 true를 반환하게 된다.&lt;/p&gt;

&lt;p&gt;그리고 파라미터 부분에 AuthMember가 있는 것을 볼 수 있다. 이는 마찬가지로 바로 위에 설명한 AuthResolver에서 채워지게 된다.&lt;/p&gt;

&lt;p&gt;이로써 Interceptor를 활용한 인증/인가 처리 부분에 대한 설명을 마치겠다.&lt;/p&gt;

&lt;p&gt;전체 코드는 &lt;a href=&quot;https://github.com/jinsu868/talk-talk&quot;&gt;talk-talk&lt;/a&gt; 에서 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mangkyu.tistory.com/173&quot;&gt;https://mangkyu.tistory.com/173&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="프로젝트" /><category term="Spring" /><category term="Spring" /><category term="프로젝트" /><summary type="html">배경</summary></entry><entry><title type="html">[DevOps] Github Action CI/CD</title><link href="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/devops/66/" rel="alternate" type="text/html" title="[DevOps] Github Action CI/CD" /><published>2024-03-28T00:00:00+09:00</published><updated>2024-03-28T00:00:00+09:00</updated><id>http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/devops/66</id><content type="html" xml:base="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/devops/66/">&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;

&lt;p&gt;필자는 palgona 프로젝트에서 배포를 담당하고 있다. 이전까지는 기능을 개발하고 develop 브랜치에 merge한 후 수동으로 서버에 들어가서 재배포를 수행했었다. 매번 수동으로 Docker image를 생성해서 다시 실행시켰었는데 서버 성능도 좋지 않아서 빌드 중에 멈추거나 시간이 오래 걸리는 일이 다반사였다. 그래서 이를 자동화하면 좋겠다고 생각했고 사용하기 간편한 github Action를 통해 CI/CD를 구축했다. CI/CD에 대해서 잘 모른다면 &lt;a href=&quot;https://jinsu868.github.io/devops/48/&quot;&gt;CI/CD &amp;amp; 무중단 배포&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;p&gt;이번 포스팅에서는 필자가 CI/CD를 구축한 과정에 대해서 설명하겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;github-action&quot;&gt;Github Action&lt;/h2&gt;

&lt;p&gt;먼저 Github Action에 대해서 간단하게 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;workflow&quot;&gt;Workflow&lt;/h3&gt;

&lt;p&gt;하나의 자동화된 프로세스로 여러 Job으로 구성되고 특정 Event가 발생했을 때 실행된다. Workflow 파일은 yml 파일로 작성되며 .github/workflows/ 경로에 저장된다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;event&quot;&gt;Event&lt;/h3&gt;

&lt;p&gt;Workflow가 실행되도록 하는 특정한 활동이나 규칙을 의미한다.&lt;/p&gt;

&lt;p&gt;ex) 특정 브랜치에 push가 발생하거나 pull-request가 발생하거나 하는 일련의 과정 등등. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;job&quot;&gt;Job&lt;/h3&gt;

&lt;p&gt;여러 Step으로 구성되며, 가상 환경의 인스턴스(Runner)에서 실행된다.&lt;/p&gt;

&lt;p&gt;다른 Job과 의존 관계를 가질 수도 있고, 독립적으로 병렬 실행될 수도 있다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step&quot;&gt;Step&lt;/h3&gt;

&lt;p&gt;Task들의 집합으로, 커맨드를 실행하거나 Action을 실행할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;action&quot;&gt;Action&lt;/h3&gt;

&lt;p&gt;가장 작은 단위로 Job을 만들기 위해 step들을 연결한다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;runner&quot;&gt;Runner&lt;/h3&gt;

&lt;p&gt;Workflow가 실행되는 인스턴스를 말한다. 간단하게 github에서 빌려주는 작은 서버라고 생각하면 된다. &lt;br /&gt; 위의 개념을 기반으로 palgona 프로젝트에 적용한 workflow 파일을 보자. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;workflowsdevyml&quot;&gt;Workflows/dev.yml&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/67_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;전체 코드는 위와 같다. 하나씩 살펴보자. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-조건-event&quot;&gt;실행 조건 (Event)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에서 설명한 Event 개념을 생각하면 된다. develop 브랜치에 push나 pull-request가 발생하면 해당 workflow 파일이 실행된다는 뜻이다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-환경-runner&quot;&gt;실행 환경 (Runner)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;runs-on은 runner가 어떤 환경으로 실행될지 지정하는 부분이다. 필자는 ubuntu 환경을 설정했다.  &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-1&quot;&gt;step&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Job을 구성하는 step들에 대해서 살펴보자. step은 name을 통해 이름을 어떤 작업인지 이름을 지어줄 수 있다. 그리고  uses와 run이 있는데 uses는 이미 있는 것을 쓰는 것이고 run은 직접 실행한 명령어를 지정하는 것이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actions/checkout@v4&lt;/code&gt; 부분은 chekout을 하는 부분인데 레포지토리의 코드를 runner로 옮기는 부분이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actions/setup-java@v4&lt;/code&gt;에서는 jdk를 설정하는데 이 프로젝트는 jdk-17을 사용하고 있기 때문에 17로 설정했다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;applicationyml-생성&quot;&gt;application.yml 생성&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 부분은 application.yml 파일을 생성해서 넣는 부분이다. github에는 일반적으로 민감한 정보가 들어있는 application.yml 파일을 올리면 안 된다. 하지만 빌드를 하기 위해서는 여러 설정 정보가 들어있는 apllication.yml 파일이 있어야 한다.&lt;/p&gt;

&lt;p&gt;github은 이러한 민감한 설정 정보를 저장하고 불러올 수 있는 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;github repostiroy -&amp;gt; settings -&amp;gt; Secrets and variables에서 이러한 값들을 저장해둘 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 설정한 변수는 workflow 파일에서 $  으로 접근할 수 있다.  &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-빌드&quot;&gt;애플리케이션 빌드&lt;/h3&gt;

&lt;h3&gt;&lt;img src=&quot;/assets/images/67_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/h3&gt;

&lt;p&gt;여기서는 gradlew에 실행 권한을 주고 테스트 없이 빌드를 진행하게 된다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;도커-build-및-push&quot;&gt;도커 build 및 push&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 docker를 빌드하고 docker hub에 푸시하는 부분이다. 마찬가지로 docker username과 password는 민감한 정보이기 때문에 github에 저장해둔 값을 사용했다. &lt;br /&gt; 당연히 도커를 빌드하기 위해서는 Dockerfile이 있어야 한다. (commit 방식은 잘 사용 X) &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_10.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;배포&quot;&gt;배포&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/67_11.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 서버에 배포하는 부분이다. 기존에 ec2 t3 micro를 사용하고 있었는데 Docker build할 때 ec2 멈춤 현상이 자주 발생해서 아직 학교를 다니고 있는 팀원의 학교 서버를 사용해서 배포를 진행했다. 👍 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ssh-action은 ssh로 접근할 때 많이 사용되는 프로젝트이다. 사용법은 간단한데 host에 public IPv4 주소를 넣어주고 username에 접속 대상 Id, password에 private Key를 넣어주면 된다. 물론 이 정보들은 외부에 공개되면 안 되기 때문에 github에 세팅해뒀다.&lt;/p&gt;

&lt;p&gt;그리고 ssh로 서버에 접속한 이후에 이전에 실행하던 컨테이너, 이미지를 삭제한 후 docker hub에서 새로 생성한 이미지를 pull 받아서 실행시켜줬다. &lt;br /&gt; 이로써 CI/CD 파이프라인 구축을 완료했다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/development/2020/06/06/github-action/&quot;&gt;https://zzsza.github.io/development/2020/06/06/github-action/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@sweetchip/Github-Actions-%EC%99%B8%EB%B6%80-%EC%84%9C%EB%B2%84%EC%97%90-SSH%EB%A1%9C-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0&quot;&gt;https://velog.io/@sweetchip/Github-Actions-%EC%99%B8%EB%B6%80-%EC%84%9C%EB%B2%84%EC%97%90-SSH%EB%A1%9C-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="프로젝트" /><category term="DevOps" /><category term="CI/CD" /><category term="프로젝트" /><summary type="html">배경</summary></entry><entry><title type="html">[트러블슈팅] OneToOne 즉시로딩 문제</title><link href="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/65/" rel="alternate" type="text/html" title="[트러블슈팅] OneToOne 즉시로딩 문제" /><published>2024-03-10T00:00:00+09:00</published><updated>2024-03-10T00:00:00+09:00</updated><id>http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/65</id><content type="html" xml:base="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/65/">&lt;h2 id=&quot;문제상황&quot;&gt;문제상황&lt;/h2&gt;

&lt;p&gt;Member와 Application 은 OneToOne 관계이고 지연 로딩 세팅을 했음에도 Member를 조회하면 Application이 즉시 로딩되는 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;이 문제의 원인과 해결한 방법을 공유하고자 글을 쓴다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;domain&quot;&gt;domain&lt;/h2&gt;

&lt;h3 id=&quot;member-유저&quot;&gt;Member (유저)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;application-멘토-인증-신청서&quot;&gt;Application (멘토 인증 신청서)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설명에 필요한 매핑 정보를 제외한 부분은 거둬냈다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;연관관계&quot;&gt;연관관계&lt;/h3&gt;

&lt;p&gt;위의 매핑 정보를 보면 알 수 있듯이 연관관계의 주인은 Application이고 XToOne 관계의 기본 fetch 전략은 EAGER이기 때문에 LAZY 세팅을 해준 모습을 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;즉시-로딩-발생&quot;&gt;즉시 로딩 발생&lt;/h3&gt;

&lt;p&gt;현재 프로젝트는 Jwt 토큰 기반으로 인증/인가 처리를 하고 있기 때문에 요청이 들어올 때마다 JwtAuthenticationFilter에서 access Token을 검증하고 유저의 이메일을 추출한다. 그리고 이메일을 통해 유저 정보를 찾고 SecurityContextHolder에 인증 객체를 저장한다.&lt;/p&gt;

&lt;p&gt;그런데 유저를 찾는 과정에서 Application이 즉시 로딩 돼서 Select 쿼리가 한 번씩 더 나가는 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;member-조회-시-나가는-쿼리&quot;&gt;Member 조회 시 나가는 쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/66_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;분명 지연 로딩 세팅을 했음에도 불구하고 즉시 로딩으로 작동해서 select 쿼리가 한 번 더 나가는 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;→ 연관관계의 주인이 아닌 Member를 조회할 때 Application이 즉시 로딩되는 모습이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;원인-분석&quot;&gt;원인 분석&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;지연 로딩 조회가 가능하기 위해서는 JPA 구현체에서 프록시를 만들어야 된다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;그리고 연관 관계 엔티티는 null 또는 프록시 객체가 할당되어야 한다.
    &lt;ul&gt;
      &lt;li&gt;null은 연관관계에 해당한 엔티티가 존재하지 않음을 의미하고 프록시 객체는 연관관계에 해당하는 엔티티가 존재한다는 의미이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1, 2를 바탕으로 Application과 Member 테이블을 생각해 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;application-관점&quot;&gt;Application 관점&lt;/h3&gt;

&lt;p&gt;Application의 경우 연관관계의 주인이기 때문에 외래키로 member_id를 가지고 있다. 즉 Member의 존재를 파악할 수 있는 필드가 존재하는 것이다.&lt;/p&gt;

&lt;p&gt;만약 member_id가 null이라면 연관된 Member가 없는 것이고 null이 아니라면 프록시 객체를 설정하여 지연 로딩을 할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;member-관점&quot;&gt;Member 관점&lt;/h3&gt;

&lt;p&gt;Member의 경우 연관관계의 주인이 아니기 때문에 Application과 연결할 수 있는 필드 자체가 존재하지 않는다. 때문에 연관된 Application이 존재하지는 지 알 수도 없어서 null, 프록시 객체 중 어떤 값을 세팅할지 결정하기가 어렵다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ OneToOne 양방향 매핑 관계에서 연관관계의 주인이 아닌 Member를 조회하게 되면 프록시 객체를 생성할 수 없기 때문에 즉시 로딩으로 동작된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-해결&quot;&gt;문제 해결&lt;/h2&gt;

&lt;h3 id=&quot;member를-조회할-때-application을-fetch-join-하기&quot;&gt;&lt;strong&gt;Member를 조회할 때 Application을 fetch join 하기&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;모든 로그인이 필요한 API에서 인증을 위해 Member가 조회되고 있는 상황이고 해당 로직에서 Application은 사용되지 않는다. 사용되지도 않는 Application을 모든 요청에 fetch join해서 가져오는 것은 적절하지 않다고 생각돼서 이 방식은 채택하지 않았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;연관관계-재설정-member1---applicationn-최종-채택&quot;&gt;&lt;strong&gt;연관관계 재설정 Member(1) - Application(N) (최종 채택)&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;우리 프로젝트에서는 최종적으로 OneToOne 관계를 OneToMany 관계로 바꿈으로써 문제를 해결했다.&lt;/p&gt;

&lt;h3 id=&quot;onetomany&quot;&gt;OneToMany&lt;/h3&gt;

&lt;p&gt;OneToMany의 경우 지연 로딩이 가능하다. 컬렉션을 사용하면 null을 표현할 수 있기 때문이다. 일단 프록시 객체를 만들어 두고 만약 조회했을 때 size = 0이라면 연관된 객체가 없는 것으로 판단할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;선택-이유&quot;&gt;선택 이유&lt;/h3&gt;

&lt;p&gt;멘토 인증과 같은 경우 사용자가 적절한 명함 사진을 올리지 않는 경우에 관리자가 인증을 거부할 수 있다. 때문에 하나의 Member가 여러 번의 Application (멘토 인증 신청)을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ Member와 Application의 관계는 OneToOne보다는 OneToMany가 더 적절하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;변경-후-member&quot;&gt;변경 후 Member&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;변경-후-application&quot;&gt;변경 후 Application&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;변경-후-쿼리&quot;&gt;변경 후 쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/66_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Member 조회 시 Application이 즉시 로딩되지 않는 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;느낀점&quot;&gt;느낀점&lt;/h3&gt;

&lt;p&gt;사실 처음부터 Member와 Application은 1:1이 아닌 1:N으로 설계하는 것이 맞다. 하지만 잘못된 설계로 인해 지연 로딩이 안되는 문제를 경험할 수 있었고 JPA에 대해서 더 깊게 이해할 수 있었던 것 같다.&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="프로젝트" /><category term="트러블슈팅" /><category term="프로젝트" /><summary type="html">문제상황</summary></entry><entry><title type="html">[트러블슈팅] 좋아요 동시성 처리</title><link href="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/64/" rel="alternate" type="text/html" title="[트러블슈팅] 좋아요 동시성 처리" /><published>2024-03-08T00:00:00+09:00</published><updated>2024-03-08T00:00:00+09:00</updated><id>http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/64</id><content type="html" xml:base="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/64/">&lt;h2 id=&quot;문제-상황&quot;&gt;문제 상황&lt;/h2&gt;

&lt;p&gt;Story - Like는 1:N 관계이고 스토리를 조회할 때 스토리의 좋아요 수를 같이 가져와야 했다.&lt;/p&gt;

&lt;p&gt;이전에는 Story를 가져올 때 Like 테이블을 조인해서 좋아요 수를 같이 가져왔다.&lt;/p&gt;

&lt;p&gt;하지만 좋아요 수가 많아질수록 조인 오버헤드가 점점 커질 것으로 판단됐다.&lt;/p&gt;

&lt;p&gt;성능 개선을 위해 좋아요 수를 비정규화했다. 그런데 여기서 여러 문제가 발생했고 이를 해결한 과정을 공유하고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;domain&quot;&gt;domain&lt;/h2&gt;

&lt;p&gt;설명에 불필요한 부분은 제거하고 필요한 부분만 남겼다.&lt;/p&gt;

&lt;h3 id=&quot;like&quot;&gt;Like&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;story&quot;&gt;Story&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;→ 좋아요 수(likeCount)를 비정규화해서 Story의 필드로 추가했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;storyservice&quot;&gt;StoryService&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스토리 좋아요 로직이다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동시성-테스트&quot;&gt;동시성 테스트&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러 스레드에서 동시에 좋아요 요청을 하는 테스트이다.&lt;/p&gt;

&lt;p&gt;테스트를 실행시키면 &lt;strong&gt;데드락&lt;/strong&gt;이 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;데드락-발생&quot;&gt;데드락 발생&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;데드락-발생-원인&quot;&gt;데드락 발생 원인&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html&quot;&gt;Mysql 공식 사이트&lt;/a&gt;를 참고해보면 데드락의 발생 원인을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;fk를 포함한 데이터의 &lt;strong&gt;insert&lt;/strong&gt;, &lt;strong&gt;delete&lt;/strong&gt;, &lt;strong&gt;update&lt;/strong&gt; 가 일어나면 참조되는 fk의 데이터에 S-Lock이 걸린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;그리고 Mysql에서는 &lt;strong&gt;update&lt;/strong&gt; 쿼리가 나갈 때 X-Lock 을 건다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 두 가지 사실을 기반으로 데드락이 걸리는 이유를 파악할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;img src=&quot;/assets/images/65_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;lt;1&amp;gt;&lt;/strong&gt; 에서 Story에 S-Lock이 걸리고 &lt;strong&gt;&amp;lt;2&amp;gt;&lt;/strong&gt; 에서 Story에 update 쿼리를 날리기 위해 X-Lock을 얻으려고 한다.&lt;/p&gt;

&lt;p&gt;그런데 여러 스레드가 동시에 접근한다면 동시에 여러 트랜잭션에서 S-Lock을 가지고 있을 수 있다. 그리고 여러 트랜잭션에서 Story의 likeCount를 변경하고 Dirty Checking을 통해 update 쿼리를 날리는 시점에 X-Lock을 획득하려고 할 것이다. 이때 서로 S-Lock을 가진 상태에서 X-Lock을 얻으려고 하기 때문에 &lt;strong&gt;데드락&lt;/strong&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;해결-방안&quot;&gt;해결 방안&lt;/h2&gt;

&lt;h3 id=&quot;try-1--optimistic-lock-실패&quot;&gt;Try 1 : Optimistic Lock (실패)&lt;/h3&gt;

&lt;p&gt;사실 좋아요 같은 경우 동시에 누를 확률이 그렇게 높지 않다. 때문에 Optimistic Lock으로 처리하면 괜찮다고 생각했다. 하지만 위에서 데드락이 발생한 이유와 동일한 이유로 데드락이 발생했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;story-version-추가&quot;&gt;Story (Version 추가)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Story 필드에 &lt;strong&gt;version&lt;/strong&gt; 필드를 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;storyrepository&quot;&gt;StoryRepository&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_10.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;story-조회-부분-수정&quot;&gt;Story 조회 부분 수정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_11.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;optimisticlockaspect&quot;&gt;OptimisticLockAspect&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_12.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;충돌이 발생했을 때 Retry 로직은 Aop 로 구현했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-결과&quot;&gt;테스트 결과&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_13.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_14.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예상한 것처럼 Optimistic Lock을 걸어도 &lt;strong&gt;데드락&lt;/strong&gt;이 걸린다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;원인&quot;&gt;원인&lt;/h3&gt;

&lt;p&gt;Optimistic Lock을 사용하더라도 Mysql을 쓰는 이상 Like를 Insert 할 때 Story에 S-lock은 걸리게 되고 Dirty Checking으로 update 쿼리가 나가는 순간 똑같이 데드락이 발생한다. 때문에 이 방법으로는 문제를 해결할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;try-2-pesmistic-lock-성공-but-성능-이슈&quot;&gt;Try 2: Pesmistic Lock (성공 &lt;strong&gt;But&lt;/strong&gt; 성능 이슈)&lt;/h3&gt;

&lt;p&gt;앞서 말한 것처럼 좋아요 같은 경우 &lt;strong&gt;Race Condition&lt;/strong&gt;이 발생할 확률이 그렇게 높지 않을 것으로 예상된다.&lt;/p&gt;

&lt;p&gt;하지만 Optimistic Lock으로는 데드락이 걸리는 문제를 해결할 수 없었다.&lt;/p&gt;

&lt;p&gt;이번에는 Pesmistic Lock을 사용해서 동시성 처리를 해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;storyrepository-1&quot;&gt;StoryRepository&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_15.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조회할 때부터 X-Lock을 가져온다.&lt;/p&gt;

&lt;h3 id=&quot;story-조회-부분-수정-1&quot;&gt;Story 조회 부분 수정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_16.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-결과-1&quot;&gt;테스트 결과&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_17.png&quot; alt=&quot;img1&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;테스트 성공적으로 통과!&lt;/p&gt;

&lt;p&gt;Story를 조회하는 시점에 X-Lock을 걸게 되면 다른 트랜잭션에서 값을 변경할 수 없기 때문에 데이터의 정합성을 보장할 수 있다.&lt;/p&gt;

&lt;p&gt;문제점 : 트랜잭션이 끝날 때까지 다른 트랜잭션에서 대기해야 하기 때문에 성능은 좋지 않다. &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;try-3--redis를-활용한-분산락-최종-선택&quot;&gt;Try 3 : Redis를 활용한 분산락 (최종 선택)&lt;/h3&gt;

&lt;p&gt;redis는 inmemory에서 작동하기 때문에 mysql에 비해서 속도가 훨씬 빠르다. 그리고 현재 프로젝트에서 메일 인증 기능을 구현하면서 redis를 이미 사용하고 있기 때문에 추가적인 인프라 설정 비용은 없었다.&lt;/p&gt;

&lt;p&gt;→ &lt;strong&gt;redis를 사용하여 좋아요 동시성 문제를 처리하기로 결정했다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;redisson-vs-lettuce&quot;&gt;Redisson vs Lettuce&lt;/h3&gt;

&lt;p&gt;Lettuce의 경우 분산락을 직접 구현해야 하고 재시도, 타임아웃도 직접 구현해야 한다. 그리고 스핀락 방식이기 때문에 동시에 여러 스레드에서 요청을 한다면 redis에 부하가 많이 간다.&lt;/p&gt;

&lt;p&gt;Redisson은 pub/sub 구조로 구현되어 있기 때문에 redis의 부하가 적게 가고 Lock 획득 재시도를 기본으로 제공하기 때문에 사용하기 편리하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ Redisson을 사용하기로 결정!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;redisson-라이브러리-추가&quot;&gt;Redisson 라이브러리 추가&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_18.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;redissonlock&quot;&gt;@RedissonLock&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_19.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;redissonlockaop&quot;&gt;RedissonLockAop&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_20.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/65_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;분산락 처리는 횡단 관심사이기 때문에 Aop로 처리했다.&lt;/p&gt;

&lt;p&gt;여기서 중요한 부분은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetTransaction.proceed(joinPoint);&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;targettransaction&quot;&gt;TargetTransaction&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_22.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;타겟 메서드는 부모 트랜잭션과 관계없이 동작하도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Propagation.REQUIRES_NEW&lt;/code&gt; 설정을 해줬다.&lt;/p&gt;

&lt;p&gt;이렇게 해주는 이유는 트랜잭션 커밋 시점이 Lock의 해제 시점 이후일 때 동시성 문제가 발생할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;→ 어떤 이유로 동시성 문제가 생길 수 있는지 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;갱신-분실&quot;&gt;갱신 분실&lt;/h3&gt;

&lt;p&gt;트랜잭션 A(TxA)와 트랜잭션 B(TxB)가 있다고 가정하자. 그리고 현재 likeCount = 0이라고 해보자.&lt;/p&gt;

&lt;p&gt;TxA, TxB가 좋아요 로직을 수행하기 위해서 동시에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;storyLike()&lt;/code&gt; 메서드에 접근한다고 가정하자.&lt;/p&gt;

&lt;p&gt;TxA가 아주 미세한 차이로 먼저 Lock을 획득하고 likeCount를 1 증가시키고 Lock을 해제시켰다. (아직 트랜잭션을 커밋하지 않았다.)&lt;/p&gt;

&lt;p&gt;이 상태에서 TxB가 Lock을 획득하여 Story를 조회했다. (이때 조회된 Story는 TxA가 수정하기 전의 Story이다. 즉 Story의 likeCount = 0이다.)&lt;/p&gt;

&lt;p&gt;다시 TxA에서 트랜잭션 커밋을 한다. 그러면 Story의 likeCount = 1이 된다.&lt;/p&gt;

&lt;p&gt;그리고 다시 TxB에서 Story의 likeCount를 1 증가시키고 트랜잭션을 커밋한다. (이때 TxB에서 조회한 likeCount는 0이었기 때문에 최종적으로 Story의 likeCount는 1이 된다.)&lt;/p&gt;

&lt;p&gt;2번의 좋아요 요청이 있었는데 likeCount는 1만 증가하게 된 것이다.&lt;/p&gt;

&lt;p&gt;→ 위와 같이 새로운 트랜잭션에서 처리하지 않으면 트랜잭션 커밋이 Lock 해제 이후에 일어나서 갱신 분실 문제가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;likeservice&quot;&gt;LikeService&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_23.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스토리 좋아요, 좋아요 취소 로직에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RedissonLock&lt;/code&gt; 에노테이션을 붙여서 Aop를 적용시켰다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-결과-2&quot;&gt;테스트 결과&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/65_24.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 테스트가 통과하는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;느낀점&quot;&gt;느낀점&lt;/h3&gt;

&lt;p&gt;동시성 처리를 위한 여러 방식을 직접 구현해 보고 비교해 봄으로써 각 방식의 장단점을 알 수 있었고 어느 시점에 어떤 방식을 사용하면 좋을지 감을 잡을 수 있었다.&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="프로젝트" /><category term="트러블슈팅" /><category term="프로젝트" /><summary type="html">문제 상황</summary></entry><entry><title type="html">[트러블슈팅] 커서 기반 페이지네이션</title><link href="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/63/" rel="alternate" type="text/html" title="[트러블슈팅] 커서 기반 페이지네이션" /><published>2024-03-02T00:00:00+09:00</published><updated>2024-03-02T00:00:00+09:00</updated><id>http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/63</id><content type="html" xml:base="http://localhost:4000/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/63/">&lt;h2 id=&quot;문제-인식&quot;&gt;문제 인식&lt;/h2&gt;

&lt;p&gt;필자는 &lt;strong&gt;Palgona&lt;/strong&gt; 프로젝트에서 상품 리스트 조회 로직 구현을 맡았다.&lt;/p&gt;

&lt;p&gt;프로젝트 요구사항에 상품을 &lt;strong&gt;최신순&lt;/strong&gt;, &lt;strong&gt;북마크 순&lt;/strong&gt;, &lt;strong&gt;최고 입찰가순&lt;/strong&gt;으로 정렬해서 보여주는 요구사항이 있었다.&lt;/p&gt;

&lt;p&gt;처음 구현했을 때는 오프셋 기반의 페이지네이션을 사용해서 구현했는데 팀원분이 커서 기반 페이지네이션을 적용하면 좋을 것 같다는 피드백을 주셨다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 커서 기반 페이지네이션 적용 과정에 대해서 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기존-방식의-문제점-offset-based&quot;&gt;기존 방식의 문제점 (offset based)&lt;/h2&gt;

&lt;h3 id=&quot;단순한-조회-쿼리-예시&quot;&gt;단순한 조회 쿼리 (예시)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단한 예시로 설명하겠다. 처음에 상품이 5개가 있다고 가정하자. (id = 1, 2, 3, 4, 5)&lt;/p&gt;

&lt;p&gt;(1)에서 쿼리가 나가면 상품 Id가 (5~3)인 상품이 조회될 것이다.&lt;/p&gt;

&lt;p&gt;(2)에서 2개의 상품이 추가될 것이다.&lt;/p&gt;

&lt;p&gt;(3)에서 다음 페이지를 조회하는데 결과는 상품 Id가 (4~2)인 상품이 조회될 것이다.&lt;/p&gt;

&lt;p&gt;→ 데이터가 중복 조회되는 결과가 발생한다. (id = 4, 3 중복 조회)&lt;/p&gt;

&lt;p&gt;(뿐만 아니라 조회 중간에 데이터를 삭제하게 되면 어떤 상품은 조회되지 않는 상황도 발생할 수 있다.)&lt;/p&gt;

&lt;h3 id=&quot;offset-증가에-따른-성능-문제&quot;&gt;offset 증가에 따른 성능 문제&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 쿼리를 보면 알 수 있듯이 원하는 데이터는 3개인데 앞의 백만 개의 데이터를 다 읽고 3개의 데이터를 가져와야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;뒤에 있는 데이터를 읽을수록 점점 조회 성능이 떨어질 것이라는 것은 자명하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;→ &lt;strong&gt;커서 기반 페이지네이션 방식&lt;/strong&gt;을 도입하면 위의 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커서-기반-페이지네이션&quot;&gt;커서 기반 페이지네이션&lt;/h2&gt;

&lt;h3 id=&quot;쿼리-예시&quot;&gt;쿼리 예시&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;커서 기반 페이지네이션 방식은 위와 같이 커서를 기준으로 limit의 개수만큼 조회하는 방식이다.&lt;/p&gt;

&lt;p&gt;오프셋 방식처럼 앞의 데이터를 다 읽을 필요가 없기 때문에 뒤쪽의 데이터를 읽더라도 성능 저하가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;커서 데이터만 중복되지 않는다면&lt;/strong&gt; 성능도 좋고 데이터의 중복도 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;이제 간단한 도메인에 대해 소개하고 커서 기반 페이지네이션 방식을 적용한 방법을 소개하겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;erd&quot;&gt;ERD&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상품 조회에 연관된 Entity만 남겼고 사용되는 필드를 제외하고는 다 걷어냈다.&lt;/p&gt;

&lt;h3 id=&quot;상품-리스트-조회-api-응답값&quot;&gt;상품 리스트 조회 API 응답값&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모바일 앱을 기준으로 개발했기 때문에 Slice 방식을 채택하여 무한 스크롤이 가능하도록 했다. 이를 위해 위와 같은 응답을 정의했다. 여기서 중요한 부분은 커서인데 뒤에서 설명하겠다.&lt;/p&gt;

&lt;h3 id=&quot;productpageresponse&quot;&gt;ProductPageResponse&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ProductPageResponse가 실제 응답 값이고 이를 SliceResponse로 감싸서 나가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 조회 쿼리 최적화 과정과 커서 기반 페이지네이션을 어떻게 적용했는지 살펴보자!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;커서-커스텀-커서&quot;&gt;커서 (커스텀 커서)&lt;/h3&gt;

&lt;p&gt;Palgona 프로젝트에서 상품은 &lt;strong&gt;최신순, 입찰가순, 북마크 순&lt;/strong&gt;으로 정렬할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;여기서 최신순을 제외한 입찰가, 북마크 순의 경우 &lt;strong&gt;커서 데이터에 중복&lt;/strong&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 별도의 커스텀 커서를 만들어줘야 데이터의 중복이 발생하지 않고 정상적으로 페이지네이션 처리를 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최신순의 경우는 product_id를 커서 데이터로 쓰면 되기 때문에 중복 걱정은 안 해도 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;커서-생성-부분&quot;&gt;커서 생성 부분&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정렬 조건에 따라서 커스텀 커서를 생성하는 부분이다.&lt;/p&gt;

&lt;p&gt;CONCAT과 LPAD 함수를 사용하여 &lt;strong&gt;유일한 식별자&lt;/strong&gt;를 만들었다.&lt;/p&gt;

&lt;h3 id=&quot;생성-예시&quot;&gt;생성 예시&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입찰가의 경우 9자리로 패딩하고 8자리로 패딩한 product_id와 조합하여 유일한 식별자를 만든다.&lt;/p&gt;

&lt;p&gt;→ ex) 입찰가가 70만 원이고 상품 Id가 1이라면 00070000000000001 와 같은 커스텀 커서가 만들어진다.&lt;/p&gt;

&lt;p&gt;북마크는 자리수만 다르고 로직은 동일하기 때문에 설명은 생략하겠다.&lt;/p&gt;

&lt;h3 id=&quot;커서-비교-로직-isinsearchrange&quot;&gt;커서 비교 로직 (isInSearchRange)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 조회될 데이터인지 판단하는 부분이다.&lt;/p&gt;

&lt;p&gt;비교를 위해 값을 패딩하고 Id를 조합해서 값을 만든다. 이를 커서와 비교하여 조회 대상인지 판단한다.&lt;/p&gt;

&lt;h3 id=&quot;정렬-기준-createorderspecifier&quot;&gt;정렬 기준 (createOrderSpecifier)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_10.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정렬 기준은 Querydsl의 OrderSpecifier 를 사용했다.&lt;/p&gt;

&lt;h3 id=&quot;상품-리스트-조회-findallbycategoryandsearchword---전체-로직&quot;&gt;상품 리스트 조회 (findAllByCategoryAndSearchWord) - 전체 로직&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_11.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_12.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_13.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상품 리스트는 총 &lt;strong&gt;2번의 쿼리&lt;/strong&gt;를 통해서 가져왔다. 하나씩 살펴보자!&lt;/p&gt;

&lt;h3 id=&quot;1-상품-조회-쿼리&quot;&gt;(1) 상품 조회 쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_14.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 쿼리에서는 Product를 Bookmark, Bidding과 left join해서 최고 입찰가와 북마크 수를 같이 가져온다.&lt;/p&gt;

&lt;p&gt;그냥 조회하게 되면 Product가 Bookmark, Bidding과 모두 1:N 관계라서 튜플수가 늘어나게 되서 제대로 페이징 처리를 할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groupBy(product.id)&lt;/code&gt; 를 통해서 상품 아이디로 묶어주어 페이징 처리가 제대로 이뤄지게 구현했다.&lt;/p&gt;

&lt;p&gt;여기서 상품 이미지를 같이 조회하지 않고 쿼리를 분리한 이유는 대표 사진만 보여줘야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;대표 사진은 image_id가 가장 낮은 이미지로 처음으로 등록되는 이미지를 말한다.&lt;/p&gt;

&lt;p&gt;만약 쿼리를 나누지 않고 이미지를 같이 가져오게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groupBy(product.id)&lt;/code&gt; 를 하면서 최초 이미지를 가져오는 것을 보장할 수 없게 된다.&lt;/p&gt;

&lt;h3 id=&quot;2-이미지-조회-쿼리&quot;&gt;(2) 이미지 조회 쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_15.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 쿼리에서는 첫 번째 쿼리에서 조회된 product_id를 가지고 in 쿼리를 날린다. 이를 통해서 product_id에 속하는 모든 이미지를 가져온다.&lt;/p&gt;

&lt;h3 id=&quot;toproductids&quot;&gt;toProductIds&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_16.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1번 쿼리에서 조회한 product_id를 추출해서 리스트로 반환하는 메서드이다.&lt;/p&gt;

&lt;h3 id=&quot;3-상품---이미지-매핑-작업&quot;&gt;(3) 상품 - 이미지 매핑 작업&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_17.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 이미지 조회 결과를 product_id 키로 묶고 대표 이미지를 뽑아서 최종 상품 리스트 응답 값을 생성한다.&lt;/p&gt;

&lt;h3 id=&quot;convertoslice&quot;&gt;converToSlice&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_18.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 상품 리스트 응답 값을 SliceResponse로 감싸는 부분이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커서-기반-페이지네이션-처리-이후-쿼리-결과&quot;&gt;커서 기반 페이지네이션 처리 이후 쿼리 (결과)&lt;/h2&gt;

&lt;h3 id=&quot;sorttype--latest-최신순-테스트&quot;&gt;SortType = LATEST (최신순) 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_19.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿼리&quot;&gt;쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_20.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;총 2번의 쿼리가 나가고 첫 번째 쿼리에서는 having 절에 커서(product_id)를 기준으로 조회가 되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;두 번째 쿼리에서는 in 쿼리로 이미지가 조회되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sorttype--higest_price-입찰가-높은순-테스트&quot;&gt;SortType = HIGEST_PRICE (입찰가 높은순) 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_22.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿼리-1&quot;&gt;쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_23.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;달라진 부분은 &lt;strong&gt;having절&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_24.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CONCAT과 LPAD를 사용되어 커스텀 식별자가 생성됐고 이를 커서와 비교하는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sorttype--bookmark-북마크순-테스트&quot;&gt;SortType = BOOKMARK (북마크순) 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_25.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쿼리-2&quot;&gt;쿼리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_26.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/64_21.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;북마크도 마찬가지이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_27.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;달라진 점은 패딩을 하는 값에 북마크의 수가 들어간다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-결과&quot;&gt;테스트 결과&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/64_28.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최종적으로 모든 테스트를 통과한 것을 확인할 수 있었다.!!&lt;/p&gt;

&lt;h3 id=&quot;느낀점&quot;&gt;느낀점&lt;/h3&gt;

&lt;p&gt;중간에 키가 중복돼서 중복 조회가 발생하기도 하고 Querydsl에서 SQL 함수를 쓰는 방법을 몰라서 많이 헤매기도 했었다. 힘들었지만 테스트의 녹색불을 확인하니 너무 뿌듯했다!!&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="프로젝트" /><category term="트러블슈팅" /><category term="프로젝트" /><summary type="html">문제 인식</summary></entry><entry><title type="html">[운영체제] 메모리 (진행중)</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6md/" rel="alternate" type="text/html" title="[운영체제] 메모리 (진행중)" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-14T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6md</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6md/">&lt;h2 id=&quot;메모리의-종류&quot;&gt;메모리의 종류&lt;/h2&gt;

&lt;p&gt;CPU에 가까운 순서대로 레지스터, 캐시, 주기억장치, 보조기억장치가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/61_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;

&lt;p&gt;캐시는 CPU와 메모리 사이의 속도 차이를 완화하기 위해서 사용한다.&lt;/p&gt;

&lt;p&gt;캐시는 메모리의 데이터를 미리 가져와 저장해두는 임시 저장소로, 크기는 메인 메모리보다 작기 때문에 앞으로 사용될 것으로 예상되는 데이터를 미리 저장하는 것이 키 포인트이다. 캐시에 있는 데이터를 가져와서 사용하는 것을 캐시 적중이라 하고 적중을 높이기 위해 &lt;strong&gt;지역성의 원리&lt;/strong&gt;가 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;시간-지역성&quot;&gt;시간 지역성&lt;/h3&gt;

&lt;p&gt;최근 사용한 데이터에 다시 접근하려는 특성을 말한다.&lt;/p&gt;

&lt;p&gt;반복문 for문의 인덱스 변수가 여기에 해당한다.&lt;/p&gt;

&lt;h3 id=&quot;공간-지역성&quot;&gt;공간 지역성&lt;/h3&gt;

&lt;p&gt;최근 사용한 데이터의 인접한 주소의 내용을 다시 접근하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;배열의 연속된 원소들이 같이 조회되는 것을 생각하면 된다.&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h2&gt;

&lt;p&gt;메모리에 프로그램을 할당할 때는 시작 메모리의 위치와 메모리 할당 크기를 기반으로 할당한다. 방법에는 연속 할당, 불연속 할당 방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h3&gt;

&lt;p&gt;연속 할당 방식은 프로세스 이미지가 분리되지 않고 온전한 프로세스를 메인 메모리에 적재하는 방식이다.&lt;/p&gt;

&lt;p&gt;연속 할당 방식에는 고정 분할 방식, 가변 분할 방식이 있다.&lt;/p&gt;

&lt;h4 id=&quot;고정-분할-방식&quot;&gt;고정 분할 방식&lt;/h4&gt;

&lt;p&gt;메모리를 고정된 파트로 분리하고, 프로세스를 해당 파트에 삽입한다. 고정된 길이의 파트 내에 프로세스가 들어가기 때문에 여백이 생길 수 있는데 이것을 &lt;strong&gt;내부 단편화&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;가변-분할-방식&quot;&gt;가변 분할 방식&lt;/h4&gt;

&lt;p&gt;메모리를 프로세스의 길이에 알맞게 파트를 분리하고, 해당 프로세스를 적재하는 방식이다. 내부 단편화는 발생하지 않지만 가변적인 길이 할당에 의해서 메모리의 일부분이 남기 때문에 &lt;strong&gt;외부 단편화&lt;/strong&gt;가 발생한다.&lt;/p&gt;

&lt;p&gt;최초 적합 : 메모리의 처음부터 검사하여 크기가 충분한 첫번째 공간에 할당한다.&lt;/p&gt;

&lt;p&gt;최적 적합 : 프로세스의 크기 이상인 공간 중 가장 작은 공간에 할당한다.&lt;/p&gt;

&lt;p&gt;최악 적합 : 프로세스의 크기와 가장 많이 차이가 나는 공간에 할당한다.&lt;/p&gt;

&lt;h3 id=&quot;불연속-할당&quot;&gt;불연속 할당&lt;/h3&gt;

&lt;p&gt;프로세스를 연속된 이미지가 아닌 분리된 이미지로 구성하여 메인 메모리에 적재하는 방식을 말한다. 페이징, 세그멘테이션 방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이징&quot;&gt;페이징&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/62_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리하여 메인 메모리에 불연속적으로 저장하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;내부 단편화&lt;/strong&gt;가 발생할 수 있다. (프로세스의 크기를 페이지의 크기로 나누고 남은 나머지의 크기만큼)&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션&quot;&gt;세그멘테이션&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/62_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 가변적인 크기의 세그먼트로 분리하여 메모리에 적재하는 방식이다. 주로 논리적인 블록 단위로 나누며 Code, Date, Heap, Stack 으로 분리할 수 있다. 세그멘테이션은 &lt;strong&gt;외부 단편화&lt;/strong&gt;가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;내부-외부-단편화&quot;&gt;내부, 외부 단편화&lt;/h2&gt;

&lt;h3 id=&quot;단편화&quot;&gt;단편화&lt;/h3&gt;

&lt;p&gt;단편화란 프로세스들이 차지하는 메모리 사이에 사용하지 못할 만큼의 작은 공간을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;내부-단편화&quot;&gt;내부 단편화&lt;/h3&gt;

&lt;p&gt;내부 단편화는 고정 분할 방식 / 페이지에서 나타나며, 물리 메모리를 고정적인 파트로 잘랐을 때, 해당 파트의 길이보다 더 작은 크기의 조각이 들어가게 되서 생기게 된다.&lt;/p&gt;

&lt;h3 id=&quot;외부-단편화&quot;&gt;외부 단편화&lt;/h3&gt;

&lt;p&gt;메모리가 할당되고 해제되는 과정이 반복될 때, 작은 메모리가 사이사이에 생겨나는 것을 말한다. 이러한 메모리 공간이 많이자면 총 사용 가능한 메모리 공간은 충분하지만 메모리를 할당할 수 없는 상황이 생기는데 이를 외부 단편화라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;가상-메모리&quot;&gt;가상 메모리&lt;/h2&gt;

&lt;p&gt;가상 메모리는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.&lt;/p&gt;

&lt;p&gt;가상 주소 -&amp;gt; MMU -&amp;gt; 실제 주소&lt;/p&gt;

&lt;p&gt;TLB : CPU와 메모리 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하여 CPU가 페이지 테이블까지 가지 않도록 하여 속도를 향상시킨다.&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;가상 메모리를 사용하면 동시에 많은 프로세스를 실행할 수 있고, 응답 시간을 유지하며 CPU 이용률과 처리률을 높일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;물리 메모리로 사용하는 것보다는 느리다.&lt;/p&gt;

&lt;h2 id=&quot;요구-페이징&quot;&gt;요구 페이징&lt;/h2&gt;

&lt;p&gt;요구 페이징은 프로그램을 실행할 때, 프로그램 전체를 물리 메모리에 적재하는 대신 초기에 필요한 부분들만 적재하여 구동시키는 방식이다. 가상 메모리와 페이지 개념을 활용하여 관리된다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체&quot;&gt;페이지 교체&lt;/h3&gt;

&lt;p&gt;요구 페이징 방식을 사용하게 되면 초기에 필요한 페이지들만 메인 메모리에 올라가게 된다. 프로세스 동작 중에, 필요한 페이지가 물리 메모리에 없는 상황이 발생할 수 있는데 이를 &lt;strong&gt;페이지 부재&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;페이지 부재가 발생하면 원하는 페이지를 하드디스크에 스왑 공간으로부터 가져오게 된다. 하지만 물리 메모리가 모두 사용중이라서 원하는 페이지를 가져오지 못한다면 페이지 교체가 일어난다.&lt;/p&gt;

&lt;h3 id=&quot;스와핑&quot;&gt;스와핑&lt;/h3&gt;

&lt;p&gt;메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 사용하는 것을 스와핑이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘&quot;&gt;페이지 교체 알고리즘&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;FIFO&lt;/strong&gt; : 가장 간단한 방식으로 메모리에 올리온 지 가장 오래된 페이지를 교체하는 알고리즘이다. 페이지가 올라온 순서를 큐에 저장하여 구현한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최적 페이지 교체&lt;/strong&gt; &lt;strong&gt;(OPT)&lt;/strong&gt;: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식이다. 프로세스가 앞으로 사용할 페이지를 미리 알아야 하는데 이는 불가능하기 때문에 구현이 불가능하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LRU (Least Recently Used)&lt;/strong&gt; : 가장 오래 사용되지 않은 페이지를 교체하는 방식이다. OPT 알고리즘보다 페이지 교체 횟수가 높지만  FIFO 알고리즘보다는 효율적이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LFU (Least Frequency Used)&lt;/strong&gt; : 참조 횟수가 가장 적은 페이지를 교체하는 방식이다. 만약 대상인 페이지가 여러개일 경우 LRU 알고리즘에 따라 가장 오래 사용되지 않은 페이지를 교체한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MFU (Most Frequency Used)&lt;/strong&gt; : LFU 알고리즘의 반대로 참조 횟수가 가장 많은 페이지를 교체하는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;스레싱&quot;&gt;스레싱&lt;/h2&gt;

&lt;p&gt;페이지 부재율이 높은 상태를 말한다. 페이지 부재가 발생하면 페이지 교체, 페이지 로드가 일어난다. 다양한 프로세스가 메모리에 올라오면서 메모리의 유효 공간은 줄어들고 CPU의 가동 시간은 올라가며 자원을 최대한 사용하게 된다.&lt;/p&gt;

&lt;p&gt;하지만 메모리의 프로세스가 일정 수 이상 올라가면 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령어가 진행될 때마다 페이지 부재가 발생한다. 이 경우 역으로 CPU 사용률이 줄어들게 된다.&lt;/p&gt;

&lt;p&gt;페이지를 교체하는 과정에서는 CPU가 사용되지 않기 때문에 페이지 교체만 계속해서 실행되면 운영체제는 CPU가 놀고 있다고 판단하고 더 많은 프로세스를 메모리에 적재한다. 이렇게 되면 더 많은 페이지 부재가 발생하는 악순환이 반복된다. 이를 &lt;strong&gt;스레싱&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;해결&quot;&gt;해결&lt;/h3&gt;

&lt;h4 id=&quot;작업-세트&quot;&gt;작업 세트&lt;/h4&gt;

&lt;p&gt;프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 메모리에 로드하는 것을 말한다. 미리 메모리에 로드하면 탐색 비용도 줄일 수 있고 스와핑또한 줄일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;pff&quot;&gt;PFF&lt;/h3&gt;

&lt;p&gt;페이지 폴트 빈도를 조절하는 방식으로 상한선과 하한선을 만드는 방식이다. 만약 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; CPU 사용률과 메모리 적재량을 함께 체크해야 스레싱 유무를 확인할 수 있다.&lt;/p&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">메모리의 종류</summary></entry><entry><title type="html">[운영체제] 블로킹/논블로킹 &amp;amp; 동기/비동기</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/61/" rel="alternate" type="text/html" title="[운영체제] 블로킹/논블로킹 &amp;amp; 동기/비동기" /><published>2024-01-11T00:00:00+09:00</published><updated>2024-01-11T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/61</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/61/">&lt;p&gt;동기/비동기, 블로킹/논블로킹는 서로 비슷해 보이지만 이 둘을 구분하는 기준이 다르다. 동기/비동기는 각 작업(함수)들이 서로 시간을 맞춰서 실행되는지를 기준으로 나뉘고 블로킹/논블로킹은 한 작업을 처리하는 동안 다른 작업을 처리할 수 있는지를 기준으로 나눈다.&lt;/p&gt;

&lt;p&gt;하나씩 살펴보자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;블로킹blocking-과-논블로킹non-blocking&quot;&gt;블로킹(Blocking) 과 논블로킹(Non-Blocking)&lt;/h1&gt;

&lt;p&gt;앞서 말한 것처럼 블로킹/논블로킹은 하나의 작업을 처리하고 있는 상태에서 다른 작업을 처리할 수 있는지를 따진다고 했다. 이는 다른 작업(함수)를 호출했을 때, 현재 작업(함수)가 실행이 차단되는지, 아닌지를 따진다는 것이다.&lt;/p&gt;

&lt;p&gt;블로킹/논블로킹을 설명하는데 &lt;strong&gt;제어권&lt;/strong&gt;, &lt;strong&gt;결과값&lt;/strong&gt;이라는 용어가 자주 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;제어권은 함수 내의 명령어를 실행할 수 있는 권한이고 결과값은 함수의 리턴값이다. 이제 이 2가지 개념을 통해서 블로킹과 논블로킹을 구분해보자.&lt;/p&gt;

&lt;h2 id=&quot;블로킹-blocking&quot;&gt;블로킹 (Blocking)&lt;/h2&gt;

&lt;p&gt;블로킹은 함수를 호출할 때, 제어권을 호출된 함수로 넘긴다. 때문에 제어권을 상실한 호출한 쪽은 자신의 로직을 실행할 수 없고 호출된 함수가 제어권을 돌려줄 때까지 기다려야 한다.&lt;/p&gt;

&lt;h2 id=&quot;논블로킹-non-blocking&quot;&gt;논블로킹 (Non-Blocking)&lt;/h2&gt;

&lt;p&gt;논블로킹도 블로킹 방식과 마찬가지고 함수를 호출하면 제어권이 넘어가지만 곧바로 제어권이 다시 돌아온다. 때문에 실행이 블락되지 않고 자신의 로직을 계속 실행하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;동기synchronous-와-비동기asynchronous&quot;&gt;동기(Synchronous) 와 비동기(Asynchronous)&lt;/h1&gt;

&lt;p&gt;동기와 비동기의 경우는 각 작업(함수)들이 서로 시간을 맞춰서 실행하는지를 따져서 구분한다.&lt;/p&gt;

&lt;h2 id=&quot;동기-synchronous&quot;&gt;동기 (Synchronous)&lt;/h2&gt;

&lt;p&gt;동기는 요청한 작업의 완료 여부를 따져서 처리한다. 이는 다른 말로 호출한 쪽에서 호출된 쪽을 계속 신경쓴다는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 함수 A가 함수 B를 호출했다면 함수A는 함수 B의 종료를 확인할 때까지 계속해서 함수 B의 상태를 확인한다.&lt;/p&gt;

&lt;p&gt;동기의 경우 제어권과 결과값이 동시에 반환된다고 말할수도 있다. 호출된 함수가 결과값을 리턴하는 시점에 제어권이 호출하는 함수쪽으로 넘어가기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;비동기-asynchronous&quot;&gt;비동기 (Asynchronous)&lt;/h2&gt;

&lt;p&gt;비동기의 경우 요청한 작업의 완료 여부를 신경쓰지 않는다. 한번 호출하면 호출된 쪽의 상태를 신경쓰지 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어서 함수 A가 함수 B를 호출했을 때, 함수 A는 함수 B의 종료를 신경쓰지 않고 자신의 로직을 수행한다.&lt;/p&gt;

&lt;p&gt;비동기의 경우는 제어권과 결과값이 따로 반환된다. 제어권은 호출하고 거의 바로 돌려 받지만 결과값은 호출된 함수가 종료되는 시점에 돌려주기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;가능한-조합&quot;&gt;가능한 조합&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_12.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;총 4가지 조합이 가능하며 주로 동기-블로킹, 비동기-논블로킹 조합을 구성한다. 여기서는 이 두가지 경우에 대해서만 자세히 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;동기--블로킹&quot;&gt;동기 &amp;amp; 블로킹&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/61_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동기 &amp;amp; 블로킹 조합은 다른 작업이 수행되는 동안에 자신의 작업은 처리하지 않고 다른 작업의 종료 여부를 받아서 순차적으로 작업을 처리하는 방식이다. 이는 다른 작업이 자신의 작업에 영향을 줄 수 있는 경우에 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;비동기--논블로킹&quot;&gt;비동기 &amp;amp; 논블로킹&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/61_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비동기 &amp;amp; 논블로킹 조합은 다른 작업을 수행할 때도 자신의 작업을 처리하고, 다른 작업의 결과를 기다리지 않는 방식이다. 다른 작업이 자신의 작업에 영향을 주지 않는 경우 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC&quot;&gt;https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://joooing.tistory.com/category&quot;&gt;https://joooing.tistory.com/category&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">동기/비동기, 블로킹/논블로킹는 서로 비슷해 보이지만 이 둘을 구분하는 기준이 다르다. 동기/비동기는 각 작업(함수)들이 서로 시간을 맞춰서 실행되는지를 기준으로 나뉘고 블로킹/논블로킹은 한 작업을 처리하는 동안 다른 작업을 처리할 수 있는지를 기준으로 나눈다.</summary></entry><entry><title type="html">[운영체제] 프로세스 스케줄링</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/60/" rel="alternate" type="text/html" title="[운영체제] 프로세스 스케줄링" /><published>2024-01-10T00:00:00+09:00</published><updated>2024-01-10T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/60</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/60/">&lt;h1 id=&quot;cpu-스케줄링&quot;&gt;CPU 스케줄링&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU 스케줄링은 프로세스가 작업을 수행할 때, 언제 어떤 프로세스에게 CPU를 할당할지를 결정하는 작업이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;분류&quot;&gt;분류&lt;/h2&gt;

&lt;h3 id=&quot;비선점형-알고리즘&quot;&gt;비선점형 알고리즘&lt;/h3&gt;

&lt;p&gt;비선점형 알고리즘은 한번 프로세스가 실행되면 해당 프로세스가 종료되거나 CPU를 자진해서 반납하는 상황이 아니라면 계속 실행되게 하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;선점형 알고리즘과 달리 문맥 교환에 따른 오버헤드는 없지만 사용자에게 동시에 작업이 수행되는 느낌을 줄 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;h4 id=&quot;fcfs-first-come-first-served&quot;&gt;FCFS (First Come First Served)&lt;/h4&gt;

&lt;p&gt;말 그대로 준비큐에 먼저 도착한 순서대로 프로세스가 실행된다.&lt;/p&gt;

&lt;p&gt;예시를 보자. (여기서 Burst Time은 CPU 사용 시간이다. 임의로 단위는 T라고 하자)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_1.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세 개의 프로세스 P1, P2, P3가 순서대로 준비큐에 도착했을 때 어떻게 실행되는지 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_2.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 준비큐에 가장 먼저 도착한 P1이 CPU를 24T만큼 사용한다. 그리고 준비큐에 두번째로 도착한 P2가 3T만큼 CPU를 가지고 실행한다. 마지막으로 P3가 3T만큼 실행된다.&lt;/p&gt;

&lt;p&gt;예시에서 볼 수 있듯이 P2, P3는 CPU 실행시간이 짧음에도 불구하고 P1의 실행을 기다려야 하기 때문에 대기시간이 길어지는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 작업 시간이 긴 프로세스가 먼저 큐에 도착하여 다른 프로세스의 실행 시간이 전부 늦어져 효율성이 떨어지는 현상을 &lt;strong&gt;콘보이 효과(Convoy effect)&lt;/strong&gt;라고 한다&lt;/p&gt;

&lt;h4 id=&quot;sjf-shortest-job-first&quot;&gt;SJF (Shortest Job First)&lt;/h4&gt;

&lt;p&gt;SJF는 CPU burst가 가장 낮은  프로세스에게 CPU를 먼저 할당하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;예시를 보자. (여기서는 P1, P2, P3, P4가 전부 메모리에 올라가있는 상태라고 가정하자.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU burst가 짧은 순으로 P4, P1, P3, P2가 실행되는 것을 확인할 수 있다. 위의 경우 평균 대기 시간은 (3 + 16 + 9 + 0) / 4 = 7이 된다.&lt;/p&gt;

&lt;p&gt;SJF는 비선점 알고리즘이기 때문에 중간에 준비큐에 CPU burst가 더 짧은 프로세스가 들어와도 중간에 실행되던 프로세스에게서 CPU를 뺏을 수 없다. 그리고 CPU를 얼만큼 사용할지는 실행 전에는 알 수 없기 때문에 이전에 실행한 로그를 토대로 추측한다.&lt;/p&gt;

&lt;p&gt;기본적으로 CPU burst가 작은 프로세스를 우선적으로 실행하기 때문에 CPU burst가 긴 프로세스는 계속해서 실행이 안될 수 있다. 이를 &lt;strong&gt;기아 현상(starvation)&lt;/strong&gt;이라고 한다. (이는 &lt;strong&gt;Aging&lt;/strong&gt;을 통해 해결할 수 있다.)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Aging : 시간이 지날수록 우선순위를 올려주는 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hrn-highest-response-ratio-next&quot;&gt;HRN (Highest Response Ratio Next)&lt;/h4&gt;

&lt;p&gt;HRN은 대기 시간과 처리 시간을 모두 고려하여 CPU를 할당하는 방식이다.&lt;/p&gt;

&lt;p&gt;우선순위 = (대기 시간 + 처리 시간) / 처리 시간&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;선점형-알고리즘&quot;&gt;선점형 알고리즘&lt;/h3&gt;

&lt;p&gt;선점형 알고리즘은 실행 상태에 있는 프로세스의 작업을 강제로 중지하고 새로운 프로세스에게 CPU가 넘어갈 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;선점형 알고리즘의 경우 문맥 교환으로 인해서 오버헤드가 증가하게 된다. 하지만 사용자에게 동시(Concurrency)에 여러 작업이 수행되는 것처럼 보이게 하기 위해서 대부분의 운영체제는 선점형 알고리즘을 사용하여 스케줄링을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;종류-1&quot;&gt;종류&lt;/h3&gt;

&lt;h4 id=&quot;rr-round-robin&quot;&gt;RR (Round Robin)&lt;/h4&gt;

&lt;p&gt;한 프로세스가 할당 받은 시간(time slice)동안 작업을 수행하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 차례를 기다리는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_6.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림의 경우 time slice = 4이다. 즉 프로세스가 CPU를 4 burst time 실행하면 다른 프로세스로 CPU가 넘어간다는 것이다.&lt;/p&gt;

&lt;p&gt;P1이 우선 4만큼 실행한 시점에서 20만큼의 CPU burst가 남는데 이를 끝마치지 않고 CPU가 P2 프로세스로 넘어가는 것을 볼 수 있다. P2는 CPU를 3만큼 실행하고 자진해서 CPU를 P3에게 넘겨준다. 그리고 P3도 마찬가지로 3만큼 실행하고 P1으로 CPU를 넘긴다.&lt;/p&gt;

&lt;p&gt;이후 준비큐에 P1을 제외한 다른 프로세스가 존재하지 않기 때문에 P1이 계속해서 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;srt-shortest-remaining-time&quot;&gt;SRT (Shortest Remaining Time)&lt;/h3&gt;

&lt;p&gt;앞에서 살펴본  SJF에서 중간에 CPU를 뺏을 수 있다는 것만 추가됬다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_7.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_8.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P1이 0T에 준비큐에 도착한 시점에는 P1을 제외한 다른 프로세스가 없기 때문에 바로 실행된다.&lt;/p&gt;

&lt;p&gt;1T에 P2가 도착했는데 이 때 P2의 Burst Time(4)가 P1의 남은 Burst Time(7)보다 짧기 때문에 사용하던 CPU를 뺏어서 P2가 실행된다.&lt;/p&gt;

&lt;p&gt;2T에 P3가 도착했지만 P2의 남은 Burst Time(3)보다 길기 때문에 P2가 그대로 실행된다.&lt;/p&gt;

&lt;p&gt;3T에 P4가 도착했지만 P2의 남은 Burst Time(2)보다 길기 때문에 P2가 그대로 실행된다.&lt;/p&gt;

&lt;p&gt;이후 5T에 P2의 실행이 끝나서 준비큐에 있는 P1(7), P3(9), P4(5) 중 가장 짧은 P4가 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 SRT에서는 실행중인 프로세스보다 현재 준비큐에 도착한 프로세스의 CPU burst가 더 작은 경우 CPU를 강제로 뺏을 수 있다.&lt;/p&gt;

&lt;p&gt;이 경우도 SJF와 마찬가지로 &lt;strong&gt;기아 현상(starvation)&lt;/strong&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;multi-level-feedback-queue&quot;&gt;Multi-Level Feedback Queue&lt;/h3&gt;

&lt;p&gt;여러 개의 준비 큐를 두고, 각 큐에 우선순위를 부여하여 우선순위가 높은 큐에 있는 프로세스에게 CPU를 할당하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/60_9.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;동작&quot;&gt;동작&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;우선순위가 높은 큐에 있는 프로세스가 먼저 실행된다.&lt;/li&gt;
  &lt;li&gt;우선순위가 같다면 RR 방식으로 처리된다.&lt;/li&gt;
  &lt;li&gt;프로세스는 준비큐에 들어오면 가장 높은 우선순위를 가진 큐로 들어간다.&lt;/li&gt;
  &lt;li&gt;프로세스가 주어진 time-slice를 모두 소진하면 한 단계 우선순위가 낮은 큐로 들어간다.&lt;/li&gt;
  &lt;li&gt;프로세스가 time-slice 시간 안에 CPU를 다른 프로세스에게 양도한다면 같은 레벨의 큐에 들어간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Bf2YAyFbreI&quot;&gt;https://www.youtube.com/watch?v=Bf2YAyFbreI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">CPU 스케줄링</summary></entry><entry><title type="html">[운영체제] 프로세스 동기화</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59/" rel="alternate" type="text/html" title="[운영체제] 프로세스 동기화" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/59/">&lt;p&gt;프로세스 동기화에 대해서 이해하기 위해서는 우선 임계 영역과 경쟁 상태에 대해서 이해해야 한다. 차례대로 살펴보며 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;임계-영역-critical-section&quot;&gt;임계 영역 (Critical Section)&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;임계 영역(Critical Section)이란 프로세스간에 공유자원을 접근함에 있어서 문제가 발생하지 않도록 한번에 하나의 프로세스만 공유자원에 접근하도록 보장해줘야 하는 영역을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;상호 배제 (Mutual Exclusion)&lt;/strong&gt; : 하나의 프로세스가 임계 영역에 들어가 있으면 다른 프로세스는 들어갈 수 없어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;진행 (Progress)&lt;/strong&gt; : 임계 영역에 들어간 프로세스가 없는 상태에서 임계 영역에 들어가려는 프로세스가 여러 개라면 어느 프로세스가 먼저 들어갈 지 결정할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;한정 대기 (Bounded Waiting)&lt;/strong&gt; : 다른 프로세스의 기아를 방지하기 위해, 한번 임계 영역에 들어간 프로세스는 다음 임계 영역에 들어갈 때 제한을 두어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태-race-condition&quot;&gt;경쟁 상태 (Race Condition)&lt;/h2&gt;

&lt;h2 id=&quot;정의-1&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;경쟁 상태 (Race Condition)란 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값이 접근 순서나 접근 시점에 따라 달라질 수 있는 것을 말한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;경쟁-상태가-발생할-수-있는-상황&quot;&gt;경쟁 상태가 발생할 수 있는 상황&lt;/h2&gt;

&lt;h4 id=&quot;커널-작업-수행-중에-인터럽트가-발생하는-경우&quot;&gt;커널 작업 수행 중에 인터럽트가 발생하는 경우&lt;/h4&gt;

&lt;p&gt;해결 방법 : 커널 모드에서 작업을 수행하는 동안 인터럽트를 disable 시켜서 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스가-시스템콜을-호출하여-커널-모드로-진입하여-작업을-수행하는-도중에-문맥교환이-발생한-경우&quot;&gt;프로세스가 시스템콜을 호출하여 커널 모드로 진입하여 작업을 수행하는 도중에 문맥교환이 발생한 경우&lt;/h4&gt;

&lt;p&gt;프로세스가 커널 모드에서 작업하는 경우에는 CPU 허용 시간이 초과되더라도 CPU 제어권을 다른 프로세스로 넘기지 않게 함으로써 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;멀티-프로세스-환경에서-공유-메모리-내의-커널-데이터에-접근할-경우&quot;&gt;멀티 프로세스 환경에서 공유 메모리 내의 커널 데이터에 접근할 경우&lt;/h4&gt;

&lt;p&gt;커널 내부의 공유 메모리에 접근할 때마다 Lock/UnLock을 하여 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;간단한 예를 살펴보며 이해해 보자.&lt;/p&gt;

&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/58_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 코드에서 counter는 공급자와 소비자가 공유하는 부분이다. 만약 공급자에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;을 하는 시점에 소비자에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 동시에 실행하게 되면 어떻게 될까? (여기서의 counter 연산은 원자적이지 않다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;이라는 연산은 원자적인 연산처럼 보이지만 사실 어셈블러로 내려가면 그렇지 않다. 위의 코드를 보면 알 수 있듯이 3개의 연산으로 쪼개진다.  공급자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter++&lt;/code&gt;을 호출한 시점에 소비자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 호출한 상황을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;register1에는 6이 저장되고 counter에 옮기는 작업을 하는 중간에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter--&lt;/code&gt;가 끼어들어서 counter의 값이 6이 되자마자 register2(4)의 값으로 덮어써서 공급자 입장에서 counter값 6을 기대했지만 4가 나오는 결과가 도출된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이러한 문제들을 해결할 수 있을까? 이제부터 이에 대해서 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스-mutex&quot;&gt;뮤텍스 (Mutex)&lt;/h2&gt;

&lt;h3 id=&quot;정의-2&quot;&gt;정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;뮤텍스란 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 매커니즘이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_3.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;연산&quot;&gt;연산&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Acquire&lt;/strong&gt; : 현재의 임계 구역에 들어갈 권한을 가져온다. 만약 다른 프로세스가 임계 구역에 있다면 나올때까지 대기한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Release&lt;/strong&gt; : 현재의 임계 구역을 모두 사용했음을 알린다. Release후에 다른 프로세스가 임계 구역에 접근할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;boolean 타입의 lock 변수를 통해 잠금 여부를 확인할 수 있고 한 개의 프로세스/스레드만 공유자원을 소유하고 해제할 수 있다. 그리고 대기중인 프로세스/스레드가 busy waiting 방식으로 대기하지 않고 대기 큐에 잠들어서 기다린다.(CPU 자원 소비 X)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;busy waiting&lt;/strong&gt; : CPU의 자원을 지속적으로 사용하며 특정 조건이 만족할 때까지 대기하는 방식 (while 문을 계속 돌고있다고 생각하면 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;세마포어-semaphore&quot;&gt;세마포어 (Semaphore)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세마포어는 교착 상태에 대한 해법으로 두 개의 원자적 함수로 제어되는 정수 변수로 멀티프로그래밍 환경에서 공유자원에 대한 접근 제어를 하는 방법으로 사용되며, 1개의 공유되는 자원에 제한된 개수의 프로세스, 또는 스레드만 접근할 수 있도록 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_4.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;흐름&quot;&gt;흐름&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허용되는 공유 자원에 접근할 수 있는 수로 세마포어 값을 초기화한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로세스/스레드가 공유 자원에 접근할 때마다 세마포어 변수의 값을 1감소 시킨다. (세마포어 변수가 0이 되면 꽉찬 것이다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세마포어 변수값이 0이하면 더 이상 접근할 수 없다는 의미이고 세마포어 변수에 절대값을 씌운 값이 현재 대기큐에서 잠들고 있는 프로세스/스레드의 수이다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;뮤텍스와 다르게 한 개 이상의 프로세스/스레드가 공유 자원에 접근할 수 있다. Wait(P) 연산을 통해 공유자원을 획득하고 Signal(V) 연산을 통해 해제한다. 세마포어도 뮤텍스와 마찬가지로 busy waiting 방식이 아닌 대기 큐에서 잠들다가 깨어나는 방식을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;이진 세마포어&lt;/strong&gt; : 세마포어 변수값이 0, 1만 될 수 있으며 최대 한개의 프로세스/스레드가 공유 자원에 접근 가능한 세마포어이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;카운팅 세마포어&lt;/strong&gt; : 최대 n개의 프로세스/스레드가 공유 자원에 접근 가능한 세마포어이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뮤텍스와-세마포어의-차이점&quot;&gt;뮤텍스와 세마포어의 차이점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;뮤텍스는 소유한 프로세스/스레드만 뮤텍스 락을 변경할 수 있다. 반면 세마포어는 여러 프로세스/스레드가 세마포어 변수값을 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;뮤텍스는 세마포어로 사용될 수 없지만 세마포어는 뮤텍스로서 사용될 수 있다.&lt;/li&gt;
  &lt;li&gt;세마포어는 실행순서의 동기화를 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착상태-dead-lock&quot;&gt;교착상태 (dead lock)&lt;/h2&gt;

&lt;h2 id=&quot;정의-3&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;둘 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;교착상태-조건&quot;&gt;교착상태 조건&lt;/h2&gt;

&lt;h3 id=&quot;비선점-non-preemptive&quot;&gt;비선점 (Non Preemptive)&lt;/h3&gt;

&lt;p&gt;다른 프로세스가 사용하고 있는 자원을 선점할 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;순환-대기-circular-wait&quot;&gt;순환 대기 (Circular wait)&lt;/h3&gt;

&lt;p&gt;두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조를 이룬다.&lt;/p&gt;

&lt;h3 id=&quot;점유-대기-hold-and-wait&quot;&gt;점유 대기 (Hold and Wait)&lt;/h3&gt;

&lt;p&gt;공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구한다.&lt;/p&gt;

&lt;h3 id=&quot;상호-배제-mutual-exclusion&quot;&gt;상호 배제 (Mutual Exclusion)&lt;/h3&gt;

&lt;p&gt;한번에 한 프로세스만 공유 자원에 접근이 가능하며, 접근 권한이 제한적이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 위 4가지 조건중에 한 가지라도 만족하지 않으면 데드락은 발생하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;교착상태-예시&quot;&gt;교착상태 예시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/59_5.png&quot; alt=&quot;img1&quot; width=&quot;100%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원 R1을 가진 P1과 자원 R2를 가진 P2가 있다. P1은 R2를 필요로 하고 P2는 R1을 필요로 한다면 두 프로세스는 서로의 자원을 얻기 위해 무한정 기다리는 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착상태-해결&quot;&gt;교착상태 해결&lt;/h2&gt;

&lt;p&gt;위에 설명한 4가지 조건중 하나를 만족시키지 않게 상태를 변경하면 된다. 하지만 변경에 여러 비용이 수반된다. 현대의 운영체제는 교착상태가 발생하면 강제 종료를 시켜서 해결한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NL9JQh5bbZ8&quot;&gt;https://www.youtube.com/watch?v=NL9JQh5bbZ8&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">프로세스 동기화에 대해서 이해하기 위해서는 우선 임계 영역과 경쟁 상태에 대해서 이해해야 한다. 차례대로 살펴보며 이해해보자.</summary></entry><entry><title type="html">[운영체제] 스레드</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58/" rel="alternate" type="text/html" title="[운영체제] 스레드" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/58/">&lt;h1 id=&quot;스레드&quot;&gt;스레드&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드는 프로세스 내의 여러 실행 흐름의 단위이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;p&gt;프로세스내의 스레드끼리는 Stack을 제외한 메모리 공간 (Code, Data, Heap)을 공유한다. 메모리 공간을 공유하기 때문에 하나의 스레드에서 오류가 발생한다면 다른 스레드에서 영향을 받을 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;독립적으로-할당되는-자원&quot;&gt;독립적으로 할당되는 자원&lt;/h3&gt;

&lt;p&gt;그렇다면 스레드마다 별도로 할당되는 자원에는 어떤게 있을까? &lt;strong&gt;Stack&lt;/strong&gt;과 &lt;strong&gt;Reigster&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;각 스레드가 독립적인 Stack을 가지는 이유는 함수의 실행과 연관된다. 독립적으로 Stack을 가진다는 말은 곧 독립적인 함수 호출이 가능하다는 뜻이다. 즉 프로세스 내에서 독립적인 실행 흐름을 만들 수 있다는 것이다. 때문에 Stack은 각 스레드마다 별도로 가지고 있어야 한다.&lt;/p&gt;

&lt;p&gt;그리고 스레드는 별도의 Register를 가지는데 여기서 의문이 있을 것이다. Register는 프로세서에 있는 친구아닌가?&lt;/p&gt;

&lt;p&gt;여기서 말하는 Register란 현재 스레드의 실행 정보가 저장된 상태값이다. 시분할 시스템에서는 문맥교환이 발생하게 되는데 문맥교환이 발생하면 스레드의 경우는 Code, Data, Heap은 공유하기 때문에 자신의 Stack 상태와 어디까지 실행했는지에 대한 정보(PC)만 저장하면 된다. 이 때, 현재 상태가 저장되기 때문에 Register 값이 저장되게 되는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 이유로 각 스레드는 Register를 별도로 가진다고 하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;문맥교환-context-switching&quot;&gt;문맥교환 (Context Switching)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;문맥교환이란 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말한다. 한 프로세스의 문맥은 그 프로세스의 PCB에 저장되어 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;발생-상황&quot;&gt;발생 상황&lt;/h4&gt;

&lt;p&gt;문맥교환은 인터럽트 발생, 실행중인 프로세스의 CPU 허용 시간 초과, 입출력 대기시에 발생하게 된다.&lt;/p&gt;

&lt;p&gt;문맥교환을 하는 동안에 CPU는 아무것도 하지 않게 된다. 그럼에도 불구하고 문맥교환을 하는 이유는 I/O와 같은 작업이 발생하여 CPU가 블록되는 시간이 문맥교환 시간보다 길기 때문에 문맥교환을 하여 다른 프로세스를 실행하는 것이 CPU 사용률을 높일 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레드&quot;&gt;멀티 스레드&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 스레드란 하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하며 작업을 수행하는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;p&gt;멀티 스레드는 하나의 프로세스의 자원을 공유하기 때문에 멀티 프로세스보다 더 적은 메모리를 차지한다.그리고 메모리(Code, Data, Heap)를 공유하기 때문에 문맥교환 속도가 더 빠르다.&lt;/p&gt;

&lt;p&gt;하지만 오류로 인해서 하나의 스레드에 문제가 발생하게 된다면 전체 스레드에 영향을 줄 수도 있다. 그리고 메모리를 공유하기 때문에 동기화에 신경써서 프로그래밍해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레드-vs-멀티-프로세스&quot;&gt;멀티 스레드 vs 멀티 프로세스&lt;/h2&gt;

&lt;p&gt;일반적으로 멀티 스레드 방식을 더 많이 사용한다. 왜 그럴까?&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식의 경우 문맥 교환을 할 때, 스택 영역만 초기화하면 되기 때문에 속도가 빠르다. 그리고 프로세스의 경우 생성할 때 &lt;strong&gt;시스템콜&lt;/strong&gt;을 호출하게 되기 때문에 멀티 스레드 방식에 비해서 비효율적이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템콜 : 사용자나 응용프로그램이 커널에서 제공하는 기능을 사용하기 위한 인터페이스를 의미한다.
    &lt;ul&gt;
      &lt;li&gt;커널이 제공하는 서비스를 시스템콜을 통해서만 접근하게 제한함으로써 컴퓨터 자원을 보호하면서 사용자나 응용프로그램에게 서비스를 제공할 수 있게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;스레드는 프로세스 내의 여러 실행 흐름 단위로서 프로세스의 자원을 사용하게 된다.&lt;/p&gt;

&lt;p&gt;프로세스 내에 여러 스레드가 있을 때, 스레드끼리 메모리(Code, Date, Heap)을 공유하며 Stack, Register는 별도로 가진다.&lt;/p&gt;

&lt;p&gt;일반적으로 멀티 프로세스 방식보다는 멀티 스레드 방식을 많이 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
  &lt;li&gt;Operating System Concepts&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="운영체제" /><category term="운영체제" /><category term="CS" /><summary type="html">스레드</summary></entry></feed>