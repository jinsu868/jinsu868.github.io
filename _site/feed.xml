<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-14T16:13:24+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinsu’s story</title><subtitle>매일 정리하는 습관</subtitle><author><name>Moon JinSu</name></author><entry><title type="html">[디자인패턴] 커맨드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/" rel="alternate" type="text/html" title="[디자인패턴] 커맨드 패턴" /><published>2023-12-10T00:00:00+09:00</published><updated>2023-12-10T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/54/">&lt;h1 id=&quot;커맨드-패턴&quot;&gt;커맨드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요구사항(요청, 명령)을 객체로 캡슐화하여 서로 다른 요구사항을 가진 클라이언트를 매개변수화시킬 수 있고 요구사항을 큐에 넣어 로그를 남기거나 작업을 취소할 수 있는 기능을 가능하게 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;invoker&quot;&gt;Invoker&lt;/h3&gt;

&lt;p&gt;요청을 받고 이를 실행시키는 역할을 수행한다. Command 인터페이스만 알고 있으며 실제로 Command가 어떻게 실행되는지는 알지 못한다.&lt;/p&gt;

&lt;h3 id=&quot;command&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt; 메소드를 선언한다.&lt;/p&gt;

&lt;h3 id=&quot;concretecommand&quot;&gt;ConcreteCommand&lt;/h3&gt;

&lt;p&gt;Command 인터페이스를 구현하며 맴버 변수로 Receiver를 가지고 있다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Receiver 메소드를 호출하여 로직이 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;receiver&quot;&gt;Receiver&lt;/h3&gt;

&lt;p&gt;실제 명령이 실행되는 부분이다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;h4 id=&quot;1-실제로-실행하는-객체receiver와-실행을-요청하는-객체invoker를-분리하여-결합도를-낮춘다&quot;&gt;1. 실제로 실행하는 객체(Receiver)와 실행을 요청하는 객체(Invoker)를 분리하여 결합도를 낮춘다.&lt;/h4&gt;

&lt;p&gt;Invoker는 Reciver를 알지 못한 채로 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드를 통해 실행을 하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-기존의-코드를-수정하지-않고도-새로운-명령을-추가할-수-있다-ocp-원칙&quot;&gt;2. 기존의 코드를 수정하지 않고도 새로운 명령을 추가할 수 있다. (OCP 원칙)&lt;/h4&gt;

&lt;p&gt;새로운 명령이 추가되도 Invoker를 수정하지 않고 Revicer와  Command만 구현하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;h4 id=&quot;1-새로운-명령이-생길때마다-클래스가-추가되기-때문에-코드-복잡성이-증가할-수-있다&quot;&gt;1. 새로운 명령이 생길때마다 클래스가 추가되기 때문에 코드 복잡성이 증가할 수 있다.&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 이제 예제를 보면서 이해해보자!&lt;/p&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;다음과 같은 기능을 가진 리모컨을 생각해보자.&lt;/p&gt;

&lt;h3 id=&quot;리모컨-기능&quot;&gt;리모컨 기능&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;전등  ON/OFF&lt;/li&gt;
  &lt;li&gt;TV ON/OFF&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 표현하기 위해서는 리모컨, 전등, TV 클래스가 필요할 것이다. 아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;remote-class&quot;&gt;Remote Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리모컨 클래스이다. 불끄기, 불켜기, Tv켜기, Tv끄기 메소드를 가진다.&lt;/p&gt;

&lt;h3 id=&quot;light--tv-class&quot;&gt;Light &amp;amp; Tv Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 이 상황에서 새로운 요구사항이 생겼다고 가정해보자.&lt;/p&gt;

&lt;h4 id=&quot;추가된-요구사항&quot;&gt;추가된 요구사항&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;리모컨을 통해 프로젝트를 켜고 끄는 기능을 추가해주세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 만족시키기 위해서는 Remote 클래스에 맴버 변수로 Project를 추가하고 Project를 켜고 끄는 메소드를 추가해야 한다. 이는 기존 코드인 Remote를 수정하는 것이기 때문에 OCP를 위반하게 된다. 커맨드 패턴을 적용하면 요청을 호출하는 Remote 클래스와 실제 실행이 되는 Tv, Light 클래스 사이의 결합도를 낮추고 새로운 요구사항(프로젝트 Up/Down)이 생겼을 때 기존 코드(Remote 클래스)를 손보지 않고 기능을 추가할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;코드를 통해서 확인해보자!&lt;/p&gt;

&lt;h3 id=&quot;커맨드-패턴을-적용한-코드&quot;&gt;커맨드 패턴을 적용한 코드&lt;/h3&gt;

&lt;h3 id=&quot;command-1&quot;&gt;Command&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령을 추상화한 Command 인터페이스이다.&lt;/p&gt;

&lt;h3 id=&quot;project-receiver&quot;&gt;Project (Receiver)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 추가된 명령을 수행하는 Project 클래스이다. 위의 클래스 다이어그램에서 설명했던 Receiver 역할을 수행하는 클래스이다.&lt;/p&gt;

&lt;p&gt;앞서 봤던 Light, Tv도 모두 Receiver이다. (Light, Tv는 코드가 동일하니 위의 코드를 참고하자.)&lt;/p&gt;

&lt;h3 id=&quot;lightoncommandlightoffcommand-concrete-command&quot;&gt;LightOnCommand/LightOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Command 인터페이스를 구현하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;메소드 안에서 Light(Receiver)의 메소드를 호출한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Remote 클래스(Invoker)와 Light 클래스(Receiver) 사이의 결합도를 낮추게 된다.&lt;/p&gt;

&lt;h3 id=&quot;tvoncommandtvoffcommand-concrete-command&quot;&gt;TvOnCommand/TvOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 설명한 Light의 경우와 완전히 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;projectoncommandprojectoffcommand-concrete-command&quot;&gt;ProjectOnCommand/ProjectOffCommand (Concrete Command)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 Light, Tv와 완전히 동일하니 설명은 생략한다.&lt;/p&gt;

&lt;h3 id=&quot;remote-invoker&quot;&gt;Remote (Invoker)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/54_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remote 클래스는 Command 인터페이스에만 의존한다. 때문에 실제로 각 ConcreteCommand가 어떤 Recevier를 호출하는지 알지 못한다.&lt;/p&gt;

&lt;p&gt;커맨드를 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setCommand()&lt;/code&gt;, On/Off 버튼을 누르는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onButtonPush()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offButtonPush()&lt;/code&gt;메소드를 가지고 있다.&lt;/p&gt;

&lt;p&gt;이 함수 내부에서는 Command의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execute()&lt;/code&gt;를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;코드를 보면 알 수 있듯이 새로운 기능을 추가함에 있어서 기존 코드를 수정할 필요가 없다 (OCP원칙). 그저 새로운 Receiver (여기서는 Project)와 ConcreteCommand(ProjectOnCommand, ProjectOffComand)만 새로 만들면 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;커맨드 패턴을 사용하면 실행을 요청하는 객체와 실제 실행하는 객체 사이의 결합도를 낮출 수 있다.&lt;/p&gt;

&lt;p&gt;때문에 새로운 요구사항이 발생해도 유연하게 대처할 수 있다. 하지만 관리해야 하는 객체의 수가 늘어나기 때문에 무분별한 사용은 코드의 복잡도를 증가시킬 수 있다.&lt;/p&gt;

&lt;p&gt;무작정 적용하기보다는 꼭 필요한 곳에만 사용하도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">커맨드 패턴</summary></entry><entry><title type="html">[디자인패턴] 어댑터 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51/" rel="alternate" type="text/html" title="[디자인패턴] 어댑터 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/51/">&lt;h1 id=&quot;어댑터-패턴&quot;&gt;어댑터 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Convert the interface of a class into another interface clients expect. 
Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어댑터 패턴(Adapter Pattern)은 클래스의 인터페이스를 클라이언트가 원하는 형태의 또 다른 인터페이스로 변환해준다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;클라이언트 입장에서는 새로운 기능을 사용하기 위해 Adaptee의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specificRequest()&lt;/code&gt; 써야 되는데 기존에 사용하던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request()&lt;/code&gt;로 접근하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;target&quot;&gt;Target&lt;/h3&gt;

&lt;p&gt;기존에 사용하던 인터페이스라고 생각하면 된다. 새로운 인터페이스(Adaptee)를 어댑터를 사용해서 Target인터페이스를 사용하듯이 하는 것이 목표이다.&lt;/p&gt;

&lt;h3 id=&quot;adapter&quot;&gt;Adapter&lt;/h3&gt;

&lt;p&gt;새로운 인터페이스인 Adaptee를 기존에 사용하던 Target인터페이스처럼 사용할 수 있도록 변환해주는 역할을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;adaptee&quot;&gt;Adaptee&lt;/h3&gt;

&lt;p&gt;새로운 인터페이스로 기존에 사용하던 Target인터페이스와 다르다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;어댑터 패턴을 사용함으로써 기존 클래스를 수정하지 않고도 클라이언트에서 새로운 인터페이스를 사용할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;어댑터 클래스를 새로 작성해야 하기 때문에 소스 코드가 늘어나고 코드의 복잡도가 늘어난다.&lt;/p&gt;

&lt;p&gt;어댑터가 중간에 데이터를 변환하는 과정에서 추가적인 처리 시간과 오버헤드가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 회사의 시스템이 있다고 해보자. 그런데 새로운 기능을 구현하기 위해 다른 업체에서 제공하는 클래스 라이브러리를 사용해야 하는 상황이 생겼다.&lt;/p&gt;

&lt;p&gt;이 상황에서 만약 기존 시스템의 인터페이스와 새로운 업체에서 사용하는 인터페이스가 다르면 호환성 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;이때 어댑터 패턴을 사용하면 이를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;우리는 핸드폰을 사용하고 있다. 이 핸드폰은 두 가지 기능이 있는데 화면을 보여주는 기능과 전원을 종료하는 기능이다.&lt;/p&gt;

&lt;p&gt;이를 코드로 나타내보면 아래와 같다.&lt;/p&gt;

&lt;h4 id=&quot;phone-class-target&quot;&gt;Phone Class (Target)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_3.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;galaxy-phone의-구현-객체&quot;&gt;Galaxy (Phone의 구현 객체)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_4.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;화면 보여주는 기능 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;전원을 종료하는 기능 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutDown()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 상황에서 태블릿 기기를 선물 받았다고 해보자.&lt;/p&gt;

&lt;p&gt;태블릿 클래스 코드는 아래와 같다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tablet-adaptee&quot;&gt;Tablet (Adaptee)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_5.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 우리는 태블릿 기기를 사용하려면 여러가지 기능을 새로 배워야 한다.&lt;/p&gt;

&lt;p&gt;그래서 우리는 태블릿을 기존에 사용하던 핸드폰과 동일한 인터페이스로 사용할 수 있도록 어댑터를 장착하기로 결정했다!&lt;/p&gt;

&lt;h3 id=&quot;phoneadapter-adapter&quot;&gt;PhoneAdapter (Adapter)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/51_6.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PhoneAdapter클래스는 Phone을 구현하고 내부적으로 Tablet을 맴버 변수로 가지고 있다.&lt;/p&gt;

&lt;p&gt;기존에 사용하던 Phone인터페이스를 구현하는 것은 같은데 내부적으로는 Tablet의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;메소드를 호출하게 된다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 우리(Client)는 Tablet클래스를 사용할 때 기존에 사용하던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutDown()&lt;/code&gt;을 통하여 접근할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;어댑터 패턴은 인터페이스 사이에 유연성이 필요한 상황에 효율적으로 사용될 수 있는 디자인 패턴이다.&lt;/p&gt;

&lt;p&gt;하지만 코드의 복잡도가 발생할 수 있고 추가적인 오버헤드가 생길 수 있기 때문에 적절한 상황에만 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://yozm.wishket.com/magazine/detail/2077/&quot;&gt;요즘IT&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">어댑터 패턴</summary></entry><entry><title type="html">[디자인패턴] 상태 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53/" rel="alternate" type="text/html" title="[디자인패턴] 상태 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/53/">&lt;h1 id=&quot;상태-패턴&quot;&gt;상태 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;객체 내부의 상태가 바뀔 때, 객체의 동작을 변경할 수 있도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;context&quot;&gt;Context&lt;/h3&gt;

&lt;p&gt;여러 상태가 존재하는 시스템을 말한다. 시스템은 상태를 나타내는 State를 가지고 있으며 클라이언`로부터 요청을 받으면  State에 실행을 위임한다.&lt;/p&gt;

&lt;h3 id=&quot;state&quot;&gt;State&lt;/h3&gt;

&lt;p&gt;상태를 추상화한 인터페이스이다.&lt;/p&gt;

&lt;p&gt;ConcreteStatus는 이를 구현하여 구체적인 상태를 나타내게 된다.&lt;/p&gt;

&lt;h3 id=&quot;concretestatus&quot;&gt;ConcreteStatus&lt;/h3&gt;

&lt;p&gt;구체적인 상태를 나타내는 클래스이다.&lt;/p&gt;

&lt;p&gt;맴버 변수로 Context를 가지고 있으며 연산에 따라 Context의 상태를 변경한다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;아래와 같은 상태가 존재하는 &lt;strong&gt;뽑기 기계&lt;/strong&gt;를 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뽑기 기계는 상태( 동전 투입 여부, 알맹이 개수)에 따라 동작 방식이 달라진다.&lt;/p&gt;

&lt;p&gt;이를 구현하기 위해서는 &lt;strong&gt;분기 처리&lt;/strong&gt;를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;만약 여기서 새로운 요구사항이 생기면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;예를 들어서 5번에 한 번마다 알맹이가 2개가 나오게 변경한다고 생각해보자.&lt;/p&gt;

&lt;p&gt;그러면 우리는 5번째인지 확인하기 위해 조건문을 모든 메소드에 추가해야 한다.&lt;/p&gt;

&lt;p&gt;매번 요구사항이 추가될 때마다 기존 코드를 변경해야 하는 것은 유지보수 측면에서 좋지 않다. 이를 해결하는 방법 중 하나가 &lt;strong&gt;상태 패턴&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;상태 패턴을 사용하게 되면 상태에 따른 동작을 클래스로 관리할 수 있게 되고 코드의 복잡도도 줄일 수 있게 된다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 상태 패턴의 필요성에 대해서 봤으니 이제 상태 패턴의 장단점에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;상태에 따른 객체의 동작을 클래스로 관리할 수 있게 된다.&lt;/li&gt;
  &lt;li&gt;상태에 관련된 동작을 각 클래스로 분산시켜 코드의 복잡도를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;새로운 요구사항이 생겨서 변경이 발생하더라도 기존의 코드를 그대로 유지할 수 있다. (OCP원칙)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;상태별로 클래스로 관리해야 하기 때문에 클래스의 수가 증가한다.&lt;/li&gt;
  &lt;li&gt;객체의 상태가 몇 개 없거나 상태가 거의 변경되지 않는 경우에 상태 패턴을 적용하는 것은 &lt;strong&gt;오버엔지니어링&lt;/strong&gt;일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;

&lt;p&gt;위에 필요성에서 설명했던 예제인 &lt;strong&gt;뽑기 기계&lt;/strong&gt;를 가지고 상태 패턴을 이해해보자.&lt;/p&gt;

&lt;p&gt;먼저 뽑기 기계의 상태에 대해서 생각해보자. 아래와 같이 4가지 상태가 존재할 것이다.&lt;/p&gt;

&lt;h4 id=&quot;sold_out&quot;&gt;SOLD_OUT&lt;/h4&gt;

&lt;p&gt;머신의 알맹이가 다 떨어진 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;no_coin&quot;&gt;NO_COIN&lt;/h4&gt;

&lt;p&gt;동전이 투입되지 않은 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;has_coin&quot;&gt;HAS_COIN&lt;/h4&gt;

&lt;p&gt;동전이 투입된 상태를 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;sold&quot;&gt;SOLD&lt;/h4&gt;

&lt;p&gt;손잡이를 돌려서 알맹이가 나오고 있는 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;그리고 이런 상태에 4가지 행위가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;뽑기 기계에 코인을 넣는 행위&lt;/li&gt;
  &lt;li&gt;뽑기 기계에서 알맹이를 뽑는 행위&lt;/li&gt;
  &lt;li&gt;뽑기 기계에서 동전을 반환하는 행위&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;-&amp;gt; 이제 이를 상태 패턴 없이 코드로 작성해보겠다.&lt;/p&gt;

&lt;h3 id=&quot;machine-class&quot;&gt;Machine Class&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상태에 따른 동작을 &lt;strong&gt;분기 처리&lt;/strong&gt;를 통해서 구현했다.&lt;/p&gt;

&lt;p&gt;그리고 각 상태(SOLD_OUT, SOLD, HAS_COIN, NO_COIN)를 상태 변수로 처리했다.&lt;/p&gt;

&lt;p&gt;하지만 이 코드에는 여러 단점이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상태 전환을 하기 위해 조건 분기를 해야 한다. 이는 가독성에 좋지 않다.&lt;/li&gt;
  &lt;li&gt;상태에 따른 추가 요구사항이 생기면 메소드를 다 수정해야 한다. &lt;strong&gt;OCP&lt;/strong&gt;를 위반하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그렇다면 이제 상태 패턴을 적용하여 이러한 단점을 보안해보자.&lt;/p&gt;

&lt;p&gt;여기서는 상태 패턴 + 싱글톤 패턴을 같이 적용한 코드를 볼 것이다.&lt;/p&gt;

&lt;p&gt;싱글톤 패턴을 적용한 이유는 상태를 변경할 때마다 새로운 객체를 생성하게 되면 &lt;strong&gt;메모리 낭비&lt;/strong&gt;가 발생하기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;상태-패턴--싱글톤-패턴-적용&quot;&gt;상태 패턴 + 싱글톤 패턴 적용&lt;/h3&gt;

&lt;h4 id=&quot;machine-context&quot;&gt;Machine (Context)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Machine 클래스는 맴버 변수로 상태를 가지고 있다. 그리고 동전 넣기, 동전 반환, 손잡이 돌리기, 뽑기라는 4가지 행위를 가진다.&lt;/p&gt;

&lt;p&gt;각각의 행위는 State에 위임되며 현재 Machine의 상태에 따라 다르게 동작하게 된다.&lt;/p&gt;

&lt;p&gt;그리고 동작이 일어나고 상황에 맞게 State가 변경될 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;state-state&quot;&gt;State (State)&lt;/h4&gt;

&lt;h4&gt;&lt;img src=&quot;/assets/images/53_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/h4&gt;

&lt;p&gt;상태를 추상화한 인터페이스이다.&lt;/p&gt;

&lt;h4 id=&quot;nocoinstate-concretestate&quot;&gt;NoCoinState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_10.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동전이 없는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;p&gt;싱글톤 패턴을 적용하였는데 만약 싱글톤 패턴을 적용하지 않았다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertCoin(Machine machine)&lt;/code&gt; 에서 머신의 상태를 변경할 때, 새로운 객체를 생성해서 넘겼어야 했을 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 상태가 변할때마다 객체가 생성되기 때문에 효율적이지 않다.&lt;/p&gt;

&lt;p&gt;물론  &lt;strong&gt;GC&lt;/strong&gt;가 주기적으로 정리해주긴 하지만 이러한 쓰레기가 늘어나게 되면 제거 과정에서 &lt;strong&gt;Stop-the-world&lt;/strong&gt;가 발생하여 프로그램이 느려질 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;hascoinstate-concretestate&quot;&gt;HasCoinState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_11.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_12.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동전이 들어있는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;p&gt;동전이 들어있을 때는 동전 반환, 손잡이 돌리기를 수행하면 상태가 변하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;soldoutstate-concretestate&quot;&gt;SoldOutState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_13.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_14.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;알맹이가 떨어진 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;h4 id=&quot;soldstate-concretestate&quot;&gt;SoldState (ConcreteState)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/53_15.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;img src=&quot;/assets/images/53_16.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;알맹이가 나가고 있는 상태를 나타내는 ConcreteState이다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;상태 패턴은 상태를 객체화하여 객체의 행동을 상태에 특화된 행위들로 분리할 수 있다.&lt;/p&gt;

&lt;p&gt;상태에 따라 행위가 달라진다면 상태 패턴을 고려해보면 좋을 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%83%81%ED%83%9CState-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">상태 패턴</summary></entry><entry><title type="html">[디자인패턴] 퍼사드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52/" rel="alternate" type="text/html" title="[디자인패턴] 퍼사드 패턴" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/52/">&lt;h1 id=&quot;퍼사드-패턴&quot;&gt;퍼사드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.&lt;/p&gt;

  &lt;p&gt;Wrap a complicated subsystem with a simpler interface.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;퍼사드 패턴은 서브 시스템에 있는 여러 개의 인터페이스를 통합하여 하나의 인터페이스를 제공한다.&lt;/p&gt;

&lt;p&gt;복잡한 서브 시스템을 사용하기 쉽게 고수준의 인터페이스를 정의하는 패턴이다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;클라이언트는 서브 시스템에 바로 접근할 수도 있고 Facade를 통해서 서브 시스템의 기능을 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;facade&quot;&gt;Facade&lt;/h3&gt;

&lt;p&gt;서브 시스템 기능을 묶은 고수준의 인터페이스이다. 이를 통해서 클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;additional-facade&quot;&gt;Additional Facade&lt;/h3&gt;

&lt;p&gt;Facade가 하나라는 규칙은 존재하지 않는다. 다양한 서브 시스템을 묶어서 새로운 Facade를 만들수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 묶인 Facade는 다른 Facade에 포함될 수도 있고 클라이언트에서 바로 사용될 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;subsystem&quot;&gt;SubSystem&lt;/h3&gt;

&lt;p&gt;여러개의 서브 클래스를 나타낸다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;그렇다면 퍼사드 패턴은 언제 사용하면 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;1-시스템이-복잡할-때&quot;&gt;1. 시스템이 복잡할 때&lt;/h4&gt;

&lt;p&gt;시스템이 굉장히 복잡한 경우를 생각해보자. 이런 경우 서브 시스템의 인터페이스를 하나씩 사용하여 로직을 구성해야 하는데 굉장히 복잡할 수 있다.&lt;/p&gt;

&lt;p&gt;이때 퍼사드 패턴을 사용하면 복잡한 서브 시스템 호출을 내부에 감추면서 고수준의 인터페이스 하나로 사용할 수 있게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-의존성을-낮추고-싶을-때&quot;&gt;2. 의존성을 낮추고 싶을 때&lt;/h4&gt;

&lt;p&gt;시스템을 사용하는 클라이언트와 서브 시스템간의 의존성이 높을 때 퍼사드 패턴이 유용하다.&lt;/p&gt;

&lt;p&gt;퍼사드 패턴을 통해 서브 시스템의 기능을 사용하게 되면 &lt;strong&gt;클라이언트와 서브 시스템간의 의존성을 낮출 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;그렇다면 퍼사드 패턴을 사용하는 것이 무조건 좋을까?&lt;/p&gt;

&lt;h4 id=&quot;1-퍼사드-패턴과-서브-시스템-사이의-의존성&quot;&gt;1. 퍼사드 패턴과 서브 시스템 사이의 의존성&lt;/h4&gt;

&lt;p&gt;퍼사드 패턴을 사용하게 되더라도 퍼사드 객체와 서브 시스템 사이의 의존성은 피할 수 없다.&lt;/p&gt;

&lt;h4 id=&quot;2-추가적인-코드&quot;&gt;2. 추가적인 코드&lt;/h4&gt;

&lt;p&gt;퍼사드 패턴을 사용하기 위해서는 퍼사드 객체를 만들어야 한다. 이는 코드의 증가를 유발하고 유지보수 관점에서 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;퍼사드 패턴을 사용하면서 얻을 수 있는 이점과 추가적인 유지보수 비용을 잘 비교하여 사용 여부를 결정하는 것이 중요하다!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;집에서 스크린을 통해서 영화를 보는 상황을 생각해보자.&lt;/p&gt;

&lt;p&gt;방에서 스크린으로 영화를 보기 위해서는 스크린을 내리고 화면도 나오게 세팅해야 한다. 그리고 음향도 적절하게 조절하고 방의 불도 꺼야 한다.&lt;/p&gt;

&lt;p&gt;리모컨 버튼 하나로 이 모든 것이 된다면 얼마나 좋을까??&lt;/p&gt;

&lt;p&gt;이를 실현해주는 것이 퍼사드 패턴이다!&lt;/p&gt;

&lt;p&gt;아래 코드를 보며 이해해보자.&lt;/p&gt;

&lt;h3 id=&quot;screen-speaker-lighter-projector-subsystem&quot;&gt;Screen, Speaker, Lighter, Projector (SubSystem)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크린, 스피커, 라이터, 프로젝터는 위에서 말한 서브 시스템이다. 퍼사드 패턴을 사용하지 않고 영화를 보는 환경을 세팅하기 위해서는 아래와 같이 클라이언트에서 서브 시스템 각각을 호출해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;main-client&quot;&gt;Main (Client)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_3.png&quot; alt=&quot;img3&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트(Main)과 서브 시스템의 의존성이 강한 것을 확인할 수 있다. 그리고 각각의 서브 시스템을 클라이언트에서 호출해야 한다.&lt;/p&gt;

&lt;p&gt;퍼사드 패턴을 사용하면 좀 더 간단한 인터페이스를 사용하여 서브 클래스의 동작을 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;아래 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;moviefacade-facade&quot;&gt;MovieFacade (Facade)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러 서브 시스템을 묶어서 하나의 인터페이스(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMovieEnv()&lt;/code&gt;)를 제공하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이제 MovieFacade를 통해서 클라이언트에서 서브 시스템에 접근하는 코드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;main-client-1&quot;&gt;Main (Client)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/52_5.png&quot; alt=&quot;img5&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트에서 MovieFacade의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMovieEnv()&lt;/code&gt;를 통해서 서브 시스템에 접근하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;물론 여전히 클라이언트는 각 서브 시스템에도 직접 접근할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;지금까지 퍼사드 패턴에 대해서 알아봤다. 퍼사드 패턴은 복잡한 서브 시스템을 묶어서 클라이언트와 서브 시스템의 의존성을 낮추고 좀 더 간단한 인터페이스로 접근할 수 있게 도와준다.&lt;/p&gt;

&lt;p&gt;이렇게 좋은 점도 있지만 추가적인 유지보수 비용도 있기 때문에 득실을 잘 따져서 적절하게 사용하는 것이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤드 퍼스트 디자인 패턴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html">퍼사드 패턴</summary></entry><entry><title type="html">[디자인패턴] 컴포짓 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/50/" rel="alternate" type="text/html" title="[디자인패턴] 컴포짓 패턴" /><published>2023-12-04T00:00:00+09:00</published><updated>2023-12-04T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/50</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/50/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;컴포짓-패턴&quot;&gt;컴포짓 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Composite design pattern comes under &lt;strong&gt;Structural Patterns&lt;/strong&gt; is one of the most important and usable part of design pattern. Developers, in his daily life uses this pattern in somehow but he doesn’t know that its really a &lt;strong&gt;Composite Design Pattern.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴포짓 패턴은 클라이언트로 하여금 각 객체와 객체의 묶음을 동일하게 다룰 수 있게 해준다. 복합 객체와 단일 객체를 동일하게 취급하고 싶을 때 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/50_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;component&quot;&gt;Component&lt;/h3&gt;
&lt;p&gt;Leaf와 Composite을 묶는 상위 인터페이스이다. 여기서 Leaf는 단일 객체, Composite은 복합 객체라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;composite&quot;&gt;Composite&lt;/h3&gt;
&lt;p&gt;다른 Component 를 포함할 수 있는 Component로서 개별 객체 또는 다른 복합 객체를 포함시키 수 있다.&lt;br /&gt;
Component 구현체들을 내부에 리스트로 가지고 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getChild()&lt;/code&gt; 메소드는 내부 리스트에 단일, 복합 객체를 저장, 삭제, 조회한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;operation()&lt;/code&gt;를 복합 객체에서 호출하게 되면 &lt;strong&gt;재귀적&lt;/strong&gt;으로 추가 단일 객체를 저장한 하위 복합 객체를 순회한다.&lt;/p&gt;

&lt;h3 id=&quot;leaf&quot;&gt;Leaf&lt;/h3&gt;
&lt;p&gt;단일 객체로서, 다른 Component를 포함할 수 없다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 결국 Composite 패턴의 핵심은 단일 객체와 복합 객체를 Client 입장에서 동일한 인터페이스를 통해서 다룰 수 있게 해준다는 것이다.
예시 코드를 보면서 이해해보자!&lt;/p&gt;

&lt;h2 id=&quot;예제&quot;&gt;예제&lt;/h2&gt;
&lt;p&gt;저녁에 너무 배고파서 식당에 왔다. 식당 메뉴를 보니 정말 다양하다. 
펜케이크 메뉴, 디저트 메뉴, 카페 메뉴, …&lt;br /&gt;
그리고 한 메뉴 안에서도 또 메뉴가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 경우에 중첩되어 있는 메뉴(Menu)와 메뉴 항목(Menus)을 동일한 구조로 처리할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;예제-코드&quot;&gt;예제 코드&lt;/h3&gt;

&lt;h4 id=&quot;menucomponent-component&quot;&gt;MenuComponent (Component)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;우선 Component부터 살펴보자. Menu와 Menus를 묶는 역할을 한다.
공통으로 사용하는 operation으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getName()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getDescription()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt;가 있다.
이제 이를 구현한 Leaf와 Composite을 살펴보자.&lt;/p&gt;

&lt;h4 id=&quot;menu-leaf&quot;&gt;Menu (Leaf)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;단일 객체인 Menu를 살펴보자. Component에서 정의된 operation들을 구현한 것을 확인할 수 있다.
여기서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 함수가 단순히 자신의 맴버 변수인 price를 리턴한다는 것을 보고 넘어가자. 자세한 것은 아래서 설명하겠다.&lt;/p&gt;

&lt;h4 id=&quot;menus-composite&quot;&gt;Menus (Composite)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;클래스가 길어서 두번에 나눠서 설명하겠다.&lt;br /&gt;
이 부분을 보면 Component 리스트를 저장하고 있는 것을 볼 수 있다. &lt;br /&gt;
위에서 설명한 것처럼 복합 객체는 단일 객체, 복합 객체를 모두 가지고 있을 수 있다.&lt;br /&gt;
그것들이 리스트 형태로 저장된 것이라고 생각하면 된다.&lt;br /&gt;
리스트에 추가(add), 삭제(remove), 조회(getChild)하는 기능이 들어가 있는 것도 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/50_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 가장 주요하게 살펴봐야 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드를 보자.&lt;br /&gt;
이 부분에 어떻게 복합 객체와 단일 객체를 동일하게 사용할 수 있는지에 대한 실마리가 있다. -&amp;gt; 바로 &lt;strong&gt;재귀&lt;/strong&gt;이다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드는 Component 리스트를 순회하면서 각 Component의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드를 호출하게 된다. &lt;br /&gt;
만약 Component 안의 객체가 단일 객체라면 Menu 클래스에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드처럼 단순하게 맴버 변수인 price를 리턴할 것이다.&lt;br /&gt;
그런데 복합 객체라면 Menus의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt; 메소드가 호출되며 제귀적으로 자신의 Component 리스트를 순회하면서 또&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPrice()&lt;/code&gt;를 호출할 것이다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;재귀 동작&lt;/strong&gt;을 통해서 하위 객체에게 작업을 위임하게 함으로써 복합 객체와 단일 객체에 동일한 작업을 적용할 수 있게 돼서 이 둘을 구분할 필요가 없어지게 된다.&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;다시 한번 말하지만 컴포짓 패턴은 단일 객체, 복합 객체를 동일한 인터페이스로 처리하고 싶을 때 사용하면 좋다는 것을 기억하면 좋겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://url.kr/eu6sr9&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html"></summary></entry><entry><title type="html">[디자인패턴] 템플릿 메소드 패턴</title><link href="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49/" rel="alternate" type="text/html" title="[디자인패턴] 템플릿 메소드 패턴" /><published>2023-12-04T00:00:00+09:00</published><updated>2023-12-04T00:00:00+09:00</updated><id>http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49</id><content type="html" xml:base="http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/49/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;템플릿-메소드-패턴&quot;&gt;템플릿 메소드 패턴&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.&lt;/p&gt;

  &lt;p&gt;-GoF design pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;템플릿 메소드 패턴은 알고리즘의 뼈대를 정의하고 서브 클래스마다 세부 동작 사항을 다르게 구현하는 패턴을 말한다.
변하지 않는 템플릿은 상위 클래스에 만들어두고 자주 변경되거나 확장되는 기능은 하위 클래스에서 만들도록 하여, 템플릿 메소드의 동작 순서는 고정하고 세부 실행 내용을 다양화할 때 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;abstract-class&quot;&gt;Abstract Class&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;템플릿 메소드&lt;/code&gt;를 구현하고, 템플릿 메소드에 사용되는 추상 메소드를 선언한다.
이 추상 메소드는 하위 클래스인 Concreate Class에서 구현된다.&lt;/p&gt;

&lt;h3 id=&quot;concreate-class&quot;&gt;Concreate Class&lt;/h3&gt;
&lt;p&gt;Abstract Class를 상속하고 추상 메소드를 구현한다. Concreate Class에서 구현한 메소드는 Abstract Class의 템플릿 메소드에서 호출된다.&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;공통되는 부분을  묶어서 관리하기 때문에 코드의 중복을 줄일 수 있고 관리하기도 편하다.&lt;/li&gt;
  &lt;li&gt;알고리즘의 특정 부분만 재정의하여 변경 사항에 대한 영향을 줄일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;템플릿 메소드에 정의한 골격은 고정돼있기 때문에 유연성이 제한될 수 있다.&lt;/li&gt;
  &lt;li&gt;알고리즘이 복잡하다면 템플릿 메소드를 만들거나 유지하기 어려울 수 있다.&lt;/li&gt;
  &lt;li&gt;추상 메소드가 많아지면 새로운 서브 클래스를 추가하거나 관리하기가 어려울 수 있다.&lt;/li&gt;
  &lt;li&gt;템플릿 메소드의 실행 흐름을 이해해야지만 서브 클래스에서 추상 메소드를 재정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;만약 템플릿 메소드의 알고리즘이 변경된다면 서브 클래스에서 재정의한 추상 메소드를 수정해야 할 수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금까지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;템플릿 메소드 패턴&lt;/code&gt;의 구조와 특징에 대해서 알아봤다.
이제 실제로 어떤식으로 활용될 수 있는지 코드를 통해서 확인하자!&lt;/p&gt;

&lt;h2 id=&quot;예제-코드&quot;&gt;예제 코드&lt;/h2&gt;

&lt;h3 id=&quot;beverage-클래스-abstract-class&quot;&gt;Beverage 클래스 (Abstract Class)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_2.png&quot; alt=&quot;img2&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt;메소드는 템플릿 메소드이다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boilWater()&lt;/code&gt;,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pour()&lt;/code&gt;는 모든 음료가 공통으로 처리해야 하는 로직이라고 생각하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;는 각 음료마다 재료가 다르기 때문에 달라져야 하는 부분이라고 생각해보자.
그러면 공통되는 부분은 나두고 각 음료마다 바뀌는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;를 추상 메소드로 선언하여 서브 클래스에서 구현하게 하면 변경을 최소화하면서 각 서브 클래스로 구현을 미루면서 유연한 확장을 할 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;americano-chocolatelatee-클래스-concreate-class&quot;&gt;Americano, ChocolateLatee 클래스 (Concreate Class)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_3.png&quot; alt=&quot;img3&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Americano와  ChocolateLatte는 Beverage를 상속받아서 각자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCondiments()&lt;/code&gt;메소드를 구현하게 된다. 그리고 템플릿 메소드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt;를 호출하게 되면 전체적인 알고리즘 흐름은 동일하지만 세부 실행 내용을 변경할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;hook-메소드&quot;&gt;hook 메소드&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;hook 메소드&lt;/strong&gt;는 서브 클래스에서 좀 더 유연하게 템플릿 메소드의 알고리즘 로직을 다양화할 수 있게 도와주는 역할을 수행한다.
일반적으로 추상 메소드가 아닌 일반 메소드로 구현을 하게 된다.
그냥 나두게 되면 원래 설정한 기본 흐름대로 실행되고 서브 클래스에서 오버라이딩하게 되면 상황에 맞게 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;간단한 예시 코드를 보면서 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_4.png&quot; alt=&quot;img4&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;템플릿 메소드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepareRecipe()&lt;/code&gt; 안에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCustomerWantsTopping()&lt;/code&gt;가 앞에서 말한 hook 메서드이다.
기본적인 요구사항이 토핑을 추가하여 음료를 제공한다고 생각하고 로직을 작성한 것이다. 그런데 어떤 음료에는 토핑이 들어가지 않아야 할 수 있다. 이런 경우에는 서브 클래스에서 hook 메서드를 선택적으로 오버라이딩하여 템플릿 메소드의 흐름을 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/49_5.png&quot; alt=&quot;img5&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Americano에 기본적으로 토핑이 들어가면 안된다고 할 때, hook 메서드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCustomerWantsTopping()&lt;/code&gt;을 제정의하여 템플릿 메소드 안에있는 로직의 실행 흐름을 제어할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://url.kr/tw2s8o&quot;&gt;인파님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;헤드 퍼스트 디자인 패턴&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="디자인패턴" /><category term="디자인패턴" /><summary type="html"></summary></entry><entry><title type="html">[DevOps] CI/CD &amp;amp; 무중단 배포</title><link href="http://localhost:4000/devops/48/" rel="alternate" type="text/html" title="[DevOps] CI/CD &amp;amp; 무중단 배포" /><published>2023-11-25T00:00:00+09:00</published><updated>2023-11-25T00:00:00+09:00</updated><id>http://localhost:4000/devops/48</id><content type="html" xml:base="http://localhost:4000/devops/48/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;devops&quot;&gt;&lt;em&gt;DevOps&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_8.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Development&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;개발과 운영을 결합시켜 만든 개발 방법론을 의미한다.&lt;/p&gt;

&lt;p&gt;소프트웨어 개발과 운영을 통합하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;효율성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;협력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속도&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정성&lt;/code&gt;을 개선하는 개발 및 운영 방법론이다.&lt;/p&gt;

&lt;h2 id=&quot;장점&quot;&gt;&lt;em&gt;장점&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;속도&lt;/strong&gt;&lt;br /&gt;
애플리케이션 개발 단계를 자동화하여 애플리케이션을 더 짧은 주기로 고객에게 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;신속한 제공&lt;/strong&gt;&lt;br /&gt;
릴리스 빈도와 속도를 개선하여 제품을 더 빠르게 개선할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안정성&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;와 같은 방식을 사용하여 각 변경 사항이 제대로 작동하고 안전한지 테스트를 할 수 있다.&lt;br /&gt;
모니터링과 로깅을 통해 실시간으로 성능에 대한 정보를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확장&lt;/strong&gt;&lt;br /&gt;
자동화와 일관성이 지원되기 때문에 위험을 줄이면서 복합한 시스템을 효율적으로 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;협업 강화&lt;/strong&gt;&lt;br /&gt;
개발자와 운영팀이 긴밀하게 협력하고 많은 책임을 공유한다.&lt;br /&gt;
이를 통해서 비효율성을 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;br /&gt;
자동화된 규정 준수 정책, 세분화된 제어 및 구성 관리 기술을 사용하여 보안을 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;→ 애플리케이션 개발, 배포 단계를 자동화하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD (Continuous Integration/Continuous Delivery)&lt;/code&gt;라고 하는데 이에 대해서 자세히 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cicd&quot;&gt;&lt;em&gt;CI/CD&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt;는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;50%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI&lt;/code&gt; 는 개발자를 위한 자동화 프로세스인 지속적인 통합을 의미하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt;는 지속적인 서비스 제공(Continuous Delivery) 및 지속적인 배포(Continuous Deployment)를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이제 각각에 대해서 알아보자.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;ci-continuous-integration&quot;&gt;CI (Continuous Integration)&lt;/h2&gt;

&lt;p&gt;CI는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 통합&lt;/code&gt;을 의미하는데 간단하게 &lt;strong&gt;빌드와 테스트를 자동화&lt;/strong&gt;하는 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;필요성&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;CI가 없을 때는 여러 개발자가 수정한 변경 사항을 한번에 모아서 Merge를 했었는데 이때 만약 에러가 발생하면 어느 곳에서 에러가 발생한지 디버깅 하는 것이 굉장히 어려웠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ CI를 성공적으로 구축하게 되면 코드를 변경할 때마다 바로 빌드 및 테스트가 진행되기 때문에 위와 같은 문제가 발생하지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;과정&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;개발자가 코드를 수정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI tool&lt;/code&gt;에 병합을 요청한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI tool&lt;/code&gt;에서 변경된 코드를 빌드하고 테스트를 수행한다.&lt;/li&gt;
  &lt;li&gt;문제가 없다면 코드를 병합한다.&lt;/li&gt;
  &lt;li&gt;만약 테스트가 실패하면 바로 개발자에게 피드백을 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cd-continuous-deliverydeployment&quot;&gt;CD (Continuous Delivery/Deployment)&lt;/h2&gt;

&lt;p&gt;CD는 &lt;strong&gt;배포를 자동화하는 과정&lt;/strong&gt;이라고 생각하면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 제공(Continuous Delivery)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 배포(Continuous Deployment)&lt;/code&gt;를 의미하며 이 두 용어는 상호 교환적으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;이 두가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 의미하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;필요성-1&quot;&gt;필요성&lt;/h3&gt;

&lt;p&gt;하나의 서버만 운영한다면 직접 이 서버에 들어가서 배포를 진행하면 된다.&lt;/p&gt;

&lt;p&gt;그런데 서버가 여러대가 있다면?&lt;/p&gt;

&lt;p&gt;하나 하나 서버에 들어가서 수동으로 스크립트를 실행하여 배포해야 한다. 이는 굉장히 비효율적이다.&lt;/p&gt;

&lt;p&gt;→ CD를 구축하게 되면 모든 서버에 자동으로 배포할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-delivery&quot;&gt;Continuous Delivery&lt;/h3&gt;

&lt;p&gt;애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드되는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;리포지토리에 올라온 것을 개발자나 운영팀에서 직접 검증하고 애플리케이션을 실시간으로 프로덕션 환경에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수동&lt;/code&gt; 배포한다.&lt;/p&gt;

&lt;h3 id=&quot;continuous-deployment&quot;&gt;Continuous Deployment&lt;/h3&gt;

&lt;p&gt;개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자동&lt;/code&gt;으로 릴리스하는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적인 서비스 제공(Continuous Delivery)&lt;/code&gt;과의 차이점은 개발자, 운영팀에서 리포지토리에 올라온 릴리스를 확인하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자동&lt;/code&gt;으로 배포까지 수행한다는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;cicd를-위한-대표적인-도구&quot;&gt;CI/CD를 위한 대표적인 도구&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gihub Actions&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circleci&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GitLab CI/CD&lt;/code&gt;등이 있다.&lt;br /&gt;
이 중에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;를 가장 많이 사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;무중단-배포&quot;&gt;&lt;em&gt;무중단 배포&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;다운타임-downtime&quot;&gt;다운타임 (DownTime)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;한대의 서버를 사용하여 서비스를 운영한다고 생각해보자. V1이 실행되고 있는 상황에서 새로운 기능이 추가된 V2가 개발이 완료됐다. 사용자에게 새로운 기능을 제공하기 위해서는 V2를 배포해야 한다.&lt;/p&gt;

&lt;p&gt;하지만 서버를 한대로 운영하고 있기 때문에 V2를 실행하기 위해서는 V1을 종료하고 V2를 실행해야 한다.&lt;/p&gt;

&lt;p&gt;V1을 종료하고 V2를 실행하는 동안에 사용자는 서비스를 이용할 수 없다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다운타임(downTime)&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다운타임&lt;/code&gt; 없이 새로운 기능을 추가하기 위한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무중단 배포&lt;/code&gt;라고 한다. 이를 위해서는 최소한 2대의 서버가 있어야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리버스-프록시-reverse-proxy&quot;&gt;리버스 프록시 (Reverse Proxy)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무중단 배포&lt;/code&gt;를 이해하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리버스 프록시&lt;/code&gt;에 대해서 알아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리버스 프록시&lt;/code&gt;란 클라이언트와 웹 서버 간의 중개자 역할을 하는 서버이다.&lt;/p&gt;

&lt;p&gt;서버 대신에 클라이언트의 요청을 대신 받아서 웹 서버로 전달하고, 웹 서버의 응답을 클라이언트에게 전달하는 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;이를 통해서 &lt;strong&gt;웹 서버의 부하를 분산&lt;/strong&gt;시키고, &lt;strong&gt;보안을 강화&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;로드 밸런싱&lt;/strong&gt;&lt;br /&gt;
웹 서버에 동시에 많은 트래픽이 몰릴 때, 서버에 부하가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;리버스 프록시를 사용하면 클라이언트의 요청을 여러 대의 서버로 분산시켜 각 서버의 부하를 줄이고, 서버의 가용성을 높여 안정적으로 서비스를 운영할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;&lt;br /&gt;
리버스 프록시를 사용하면 외부에서 서버로 바로 접근하지 못하게 된다.&lt;/p&gt;

&lt;p&gt;서버와 클라이언트 사이에서 악성 요청을 필터링하거나, 접근 제한과 같은 역할을 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;캐싱 및 가속화&lt;/strong&gt;&lt;br /&gt;
자주 사용되는 정적 파일(CSS, JS)를 캐시에 저장하여 빠르게 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;이로 인해 서버의 부하를 줄이고 응답 시간을 단축시킬 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추가적인 서버 설정 비용&lt;/strong&gt;&lt;br /&gt;
리버스 프록시를 사용하기 위해서는 추가적인 서버 설정과 관리가 요구된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;네트워크 지연&lt;/strong&gt;&lt;br /&gt;
중간 다리(리버스 프록시)를 거치기 때문에 약간의 네트워크 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;복잡성 증가&lt;/strong&gt;&lt;br /&gt;
아키텍처가 복잡해질 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;→ 리버스 프록시의 장단점은 사실 프록시 패턴의 장단점과 동일하다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;로드-밸런싱&quot;&gt;&lt;em&gt;로드 밸런싱&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;정의-1&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;컴퓨터 네트워크 기술의 일종으로 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 &lt;strong&gt;컴퓨터 자원들에게 작업, 즉 부하를 나누는 것&lt;/strong&gt;을 의미한다.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;필요성-2&quot;&gt;필요성&lt;/h2&gt;

&lt;p&gt;서비스 런칭 단계에서는 고객이 거의 없기 때문에 서버 한대로도 모든 요청을 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 점점 고객의 수가 늘어나고 서비스가 확장되면 서버 한대로는 모든 요청을 처리할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;증가하는 트래픽을 대처하기 위해서 사용할 수 있는 방법은 크게 2가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scale-up&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scale-out&lt;/code&gt; 이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Scale up&lt;/strong&gt; : 서버 자체의 성능을 향상하는 방법으로 비용이 상대적으로 많이 든다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Scale out&lt;/strong&gt; : 서버를 증설하는 방법이다. 이 방법을 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;로드밸런싱&lt;/code&gt;이 필수로 요구된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;L4 로드밸런싱&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송 계층&lt;/code&gt;에서 로드(트래픽)을 분산시킨다.&lt;br /&gt;
IP주소나 포트번호, MAC주소 등에 따라 트래픽을 나누고 분선처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L7 로드밸런싱&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션 계층&lt;/code&gt;에서 로드를 분산시킨다.&lt;br /&gt;
HTTP, SMTP, FTP 등을 바탕으로 로드를 분산 처리할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;로드밸런싱-알고리즘&quot;&gt;로드밸런싱 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;라운드로빈-방식&quot;&gt;라운드로빈 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;단순히 서버로 요청이 들어온 순서를 바탕으로 처리하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트의 요청 순서에 따라 처리되기 때문에 여러 대의 서버가 동일한 스펙을 가지고 있고, 서버와의 연결이 오래 지속되지 않을 때 사용하면 좋다.&lt;/p&gt;

&lt;h3 id=&quot;가중-라운드로빈-방식&quot;&gt;가중 라운드로빈 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버마다 가중치를 설정하고 가중치가 높은 서버에 클라이언트의 요청을 우선적으로 배분하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 서버의 트래픽 처리 능력이 다를 때 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;ip-해시-방식&quot;&gt;IP 해시 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트의  IP 주소를 바탕으로 해시함수를 돌려서 항상 동일한 서버에 도달하게 만드는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라이언트는 항상 동일한 서버로부터 서비스를 받을 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;최소-연결-방식&quot;&gt;최소 연결 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클라이언트 요청이 들어올 때를 기준으로 가장 트래픽이 적은 서버로 연결하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서버에 분산된 트래픽이 일정하지 않을 때 적합하다.&lt;/p&gt;

&lt;h3 id=&quot;최소-리스폰타임&quot;&gt;최소 리스폰타임&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버의 연결 상태와 응답 시간을 모두 고려하여 트래픽을 분산하는 방식이다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;무중단-배포-방식&quot;&gt;&lt;em&gt;무중단 배포 방식&lt;/em&gt;&lt;/h1&gt;

&lt;h2 id=&quot;롤링rolling-배포&quot;&gt;롤링(Rolling) 배포&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ 여기서의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nginx&lt;/code&gt;는 로드밸런서 역할을 하는 리버스 프록시라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;롤링 배포 방식은 사용중인 인스턴스 내에서 새로운 버전을 점진적으로 교체해 나가는 방식으로 무중단 배포의 가장 기본적인 방법이다.&lt;/p&gt;

&lt;p&gt;위에서부터 차례대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버3&lt;/code&gt;이라고 해보자.&lt;/p&gt;

&lt;h3 id=&quot;과정-1&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;로드밸런서(Nginx)에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;로 라우팅되지 않게 설정한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;에 새로운 버전을 배포한다.&lt;/li&gt;
  &lt;li&gt;로드밸런서에서 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버1&lt;/code&gt;로 라우팅될 수 있도록 변경한다.&lt;/li&gt;
  &lt;li&gt;이 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버3&lt;/code&gt;에 점진적으로 적용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;장점-2&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;차례대로 배포를 진행하기 때문에 상황에 따라서 롤백이 어렵지 않다.&lt;/p&gt;

&lt;p&gt;추가적인 인스턴스를 늘리지 않아도 된다.&lt;/p&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;새로운 버전을 배포할 때마다 처리할 수 있는 서버가 줄어들기 때문에 트래픽이 몰릴 수 있다.&lt;/p&gt;

&lt;p&gt;배포가 진행될 때 구버전과 신버전이 동시에 존재하기 때문에 &lt;strong&gt;호환성 문제&lt;/strong&gt;가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;blue-green-배포-방식&quot;&gt;Blue Green 배포 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블루&lt;/code&gt;는 구버전을, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그린&lt;/code&gt;은 신버전을 의미한다.&lt;/p&gt;

&lt;p&gt;운영중인 구버전과 동일하게 신버전 인스턴스를 구성하고 로드밸런서를 사용하여 모든 트래픽을 한번에 신버전으로 전환하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;장점-3&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;구버전의 인스턴스가 그대로 남아있기 때문에 롤백이 쉽다.&lt;/p&gt;

&lt;p&gt;한번에 라우팅을 변경하기 때문에 배포하는 속도가 빠르다.&lt;/p&gt;

&lt;p&gt;구버전 환경을 다음 배포에 재사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단점-2&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;구버전과 신버전을 가지고 있어야 하기 때문에 시스템 자원이 2배로 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;카나리-배포-방식&quot;&gt;카나리 배포 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/48_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;과정-2&quot;&gt;과정&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;신버전을 소수의 유저들에게 배포하고 문제가 없는지 확인한다.&lt;/li&gt;
  &lt;li&gt;만약 문제가 없다면 점차 많은 유저에게 배포한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블루 그린 방식&lt;/code&gt;과 유사하지만 트래픽을 한번에 바꾸는 것이 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단계적으로 바꾸는 것&lt;/code&gt;이 차이점이다.&lt;/p&gt;

&lt;h3 id=&quot;장점-4&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;성능 모니터링에 유용하다.&lt;/p&gt;

&lt;p&gt;A/B 테스트로 활용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A/B 테스트란?
    &lt;blockquote&gt;
      &lt;p&gt;A/B 테스팅이란 웹 사이트 방문자를 임의로 두 집단으로 나누고, 한 집단에게는 기존 사이트를 보여주고 다른 집단에게는 새로운 사이트를 보여준 다음, 두 집단 중 어떤 집단이 더 높은 성과를 보이는지 측정하여, 새 사이트가 기존 사이트에 비해 좋은지를 정량적으로 평가하는 방식을 말한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점-3&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;네트워크 트래픽을 제어하는 부담이 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://aws.amazon.com/ko/devops/what-is-devops/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.redhat.com/ko/topics/devops&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://velog.io/@lee2302/Deploy-CICD%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%B0%ED%8F%AC&quot;&gt;https://velog.io/@lee2302/Deploy-CICD자동화-배포&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://seosh817.tistory.com/104&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://hudi.blog/zero-downtime-deployment/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.youtube.com/watch?v=sIPU_VkrguI&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://narup.tistory.com/238&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://aday7.tistory.com/entry/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9CReverse-Proxy-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%ED%95%84%EC%9A%94%EC%84%B1-%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EC%86%94%EB%A3%A8%EC%85%98%EA%B9%8C%EC%A7%80&quot;&gt;https://aday7.tistory.com/entry/리버스-프록시Reverse-Proxy-쉽게-이해하기-개념부터-필요성-오픈-소스-솔루션까지&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://velog.io/@yanghl98/OS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-Load-Balancing-%EC%A0%95%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98&quot;&gt;https://velog.io/@yanghl98/OS운영체제-로드밸런싱-Load-Balancing-정의-종류-알고리즘&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://bruno-jang.tistory.com/34&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="DevOps" /><category term="DevOps" /><category term="CI/CD" /><category term="리버스 프록시" /><category term="무중단 배포" /><summary type="html"></summary></entry><entry><title type="html">[DB] 트랜잭션</title><link href="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/47/" rel="alternate" type="text/html" title="[DB] 트랜잭션" /><published>2023-11-20T00:00:00+09:00</published><updated>2023-11-20T00:00:00+09:00</updated><id>http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/47</id><content type="html" xml:base="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/47/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 의미한다.&lt;/p&gt;

&lt;p&gt;여러 쿼리를 하나로 묶는 단위를 말한다.&lt;/p&gt;

&lt;h2 id=&quot;속성&quot;&gt;속성&lt;/h2&gt;

&lt;h3 id=&quot;원자성atomicity&quot;&gt;원자성(Atomicity)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;원자성은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;All or Nothing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;중간에 취소된 경우에 완전히 처음 상태로 돌아가는 것을 보장한다.&lt;/p&gt;

&lt;h4 id=&quot;commit-rollback&quot;&gt;Commit, Rollback&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Commit&lt;/code&gt; : 트랜잭션 단위로 수행되며 변경된 모든 내용이 영구적으로 저장되는 것을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rollback&lt;/code&gt; : 트랜젝션으로 처리한 하나의 과정을 일어나기 전의 상태로 돌리는 것을 의미한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일관성consistency&quot;&gt;일관성(Consistency)&lt;/h3&gt;

&lt;p&gt;허용된 방식으로만 데이터를 변경할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;내가 500원이 있는데 1000원을 전송할 수 있으면 X&lt;/p&gt;

&lt;h3 id=&quot;격리성isolation&quot;&gt;격리성(Isolation)&lt;/h3&gt;

&lt;p&gt;격리성이란 트랜잭션 수행 시에 서로 끼어들지 못하는 정도를 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/47_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;격리-수준-isolation-level&quot;&gt;격리 수준 (Isolation Level)&lt;/h4&gt;

&lt;h5 id=&quot;read-uncommited&quot;&gt;READ UNCOMMITED&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션에서 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;가장 낮은 수준의 격리성을 보장하지만 성능이 좋다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반복 가능하지 않은 조회&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;더티 리드&lt;/code&gt;가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터베이스의 일관성을 유지할 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;read_commited&quot;&gt;READ_COMMITED&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;커밋이 완료된 데이터에 대해서만 조회가 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반복 가능하지 않은 조회&lt;/code&gt;가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;대부분의 SQL 서버가 기본으로 사용하는 Isolation Level 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;repeatable_read&quot;&gt;REPEATABLE_READ&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정하지 못하도록 한다.&lt;/li&gt;
  &lt;li&gt;새로운 행을 추가하는 것은 막지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션을 순차적으로 진행시키는 것을 말한다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;교착상태가 발생할 확률이 높고 가장 성능이 떨어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가장 높은 수준의 격리성을 보장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;격리성으로-인해-발생할-수-있는-문제&quot;&gt;격리성으로 인해 발생할 수 있는 문제&lt;/h4&gt;

&lt;h5 id=&quot;팬텀-리드-phantom-read&quot;&gt;팬텀 리드 (Phantom Read)&lt;/h5&gt;

&lt;p&gt;한 트랜잭션 내에서 동일한 쿼리를 했을 때, 해당 조회 결과가 다른 경우&lt;/p&gt;

&lt;h5 id=&quot;반복-가능하지-않은-조회-non-repeatable-read&quot;&gt;반복 가능하지 않은 조회 (Non-Repeatable Read)&lt;/h5&gt;

&lt;p&gt;한 트랜잭션 내의 같은 행에 대해서 두 번 이상의 조회가 발생할 때, 그 값이 다른 경우&lt;/p&gt;

&lt;p&gt;→ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팬텀 리드&lt;/code&gt;의 경우 조회 결과 다른 행이 선택될 수 있는 것이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반복 가능하지 않은 조회&lt;/code&gt;는 동일한 행을 조회할 때 다른 값으로 조회될 수 있는 것을 말한다.&lt;/p&gt;

&lt;h5 id=&quot;더티-리드-dirty-read&quot;&gt;더티 리드 (Dirty Read)&lt;/h5&gt;

&lt;p&gt;한 트랜잭션이 실행중일 때 다른 트랜잭션에 의해 값이 수정됐는데 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;영구성durability&quot;&gt;영구성(Durability)&lt;/h3&gt;

&lt;p&gt;성공적으로 수행된 트랜잭션은 영원히 반영돼야 한다.&lt;br /&gt;
데이터베이스 시스템에 장애가 발생해도 원래 상태로 복구가 가능해야 함을 뜻하며 체크섬, 저널링, 롤백 등의 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;면접을 위한 CS 전공지식 노트&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://velog.io/@yu-jin-song/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80Transaction-Isolation-Level&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="데이터베이스" /><category term="트랜잭션" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[DB] 이상현상과 정규화</title><link href="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/46/" rel="alternate" type="text/html" title="[DB] 이상현상과 정규화" /><published>2023-11-19T00:00:00+09:00</published><updated>2023-11-19T00:00:00+09:00</updated><id>http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/46</id><content type="html" xml:base="http://localhost:4000/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/46/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;이상현상-anomaly&quot;&gt;이상현상 (Anomaly)&lt;/h1&gt;

&lt;h2 id=&quot;삽입이상&quot;&gt;삽입이상&lt;/h2&gt;

&lt;p&gt;불필요한 데이터를 추가해야지만 삽입이 가능한 상황&lt;/p&gt;

&lt;h2 id=&quot;갱신이상&quot;&gt;갱신이상&lt;/h2&gt;

&lt;p&gt;같아야 하는 정보가 복수 개의 행에 표현될 경우, 데이터를 수정할 때 일부 정보만 갱신되고 일부는 변하지 않아 데이터 오류가 발생하는 현상&lt;/p&gt;

&lt;h2 id=&quot;삭제이상&quot;&gt;삭제이상&lt;/h2&gt;

&lt;p&gt;의도하지 않은 데이터까지 삭제해야만 지우고자 하는 데이터를 지울 수 있는 현상&lt;/p&gt;

&lt;p&gt;→ &lt;strong&gt;이러한 이상 현상들을 없애기 위해서 정규화를 수행한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;정규화&quot;&gt;정규화&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터의 일관성&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소한의 중복&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최대한의 데이터 유연성&lt;/code&gt;을 위한 방법으로, 데이터를 분해하는 과정을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_1.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 1~5 정규화가 있으며, 제3정규화까지만 수행한다.&lt;/p&gt;

&lt;h2 id=&quot;함수-종속성&quot;&gt;함수 종속성&lt;/h2&gt;

&lt;p&gt;X, Y가 있고 X가 변할 때, Y도 같이 변한다면 Y는 X에 함수적으로 종속된다고 표현한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;X→Y이면 Y는 X에 함수적으로 종속&lt;/li&gt;
  &lt;li&gt;X : 결정자, Y : 종속자&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;

&lt;h4 id=&quot;완전-함수-종속&quot;&gt;완전 함수 종속&lt;/h4&gt;

&lt;p&gt;종속자가 기본키에만 종속되고, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에  종속된 경우&lt;/p&gt;

&lt;h4 id=&quot;부분-함수적-종속&quot;&gt;부분 함수적 종속&lt;/h4&gt;

&lt;p&gt;릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부에만 종속된 경우&lt;/p&gt;

&lt;h4 id=&quot;이행적-함수-종속&quot;&gt;이행적 함수 종속&lt;/h4&gt;

&lt;p&gt;릴레이션에서 X, Y, Z라는 3개의 속성이 있을 때, X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때 이행적 함수 종속이라고 한다.&lt;/p&gt;

&lt;p&gt;X를 알면 Y를 알고, Y를 알면 Z를 알 수 있는 경우&lt;/p&gt;

&lt;h3 id=&quot;정규화-종류&quot;&gt;정규화 종류&lt;/h3&gt;

&lt;h4 id=&quot;제1-정규화&quot;&gt;제1 정규화&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속성의 원자성&lt;/code&gt;을 만족시키도록 비정규형 테이블을 제1 정규형 테이블로 구조화하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;릴레이션의 속성 값 중에서 한 개의 기본키에 대해서 두 개 이상의 값을 가지는 반복집합을 제거한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_2.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 테이블를 보면 A가 좋아하는 음식이 2개이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_3.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;→ 위 테이블과 같이 반복집합이 제거된 테이블을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제1 정규형&lt;/code&gt;이라고 한다. 그리고 이러한 정규화 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제1 정규화&lt;/code&gt; 라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;제2-정규화&quot;&gt;제2 정규화&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 함수 종속성&lt;/code&gt;을 제거하는 과정을 말한다.&lt;/li&gt;
  &lt;li&gt;부분 함수 종속성은 기본키가 2개 이상의 Column 으로 구성되는 경우에만 발생한다.
    &lt;ul&gt;
      &lt;li&gt;기본키가 1개의 Column 으로 구성된다면 제2 정규화는 건너뛴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_4.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 테이블의 기본키가 회원ID와 은행이라고 가정하자.&lt;/p&gt;

&lt;p&gt;계좌번호는 회원ID와 은행에 종속된다. 하지만 회원 이름은 은행에 상관없이 회원ID에만 종속된다.&lt;/p&gt;

&lt;p&gt;이렇게 기본키가 2개 이상의 Column (회원ID, 은행)으로 구성될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 함수 종속성&lt;/code&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;테이블 분리를 통해서 이를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_5.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_6.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;회원ID, 이름을 속성으로 가지는 새로운 테이블을 도출했다. 이렇게 테이블 분리를 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제2 정규형&lt;/code&gt;을 구성하는 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제2 정규화&lt;/code&gt;라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;제3-정규화&quot;&gt;제3 정규화&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행적 함수 종속&lt;/code&gt;을 제거하는 과정을 말한다.&lt;/li&gt;
  &lt;li&gt;기본키가 아닌 Column 이 다른 Column을 결정하는 결정할 수 없도록 한다.&lt;/li&gt;
  &lt;li&gt;제3 정규화는 제1, 2 정규화를 마친 제2 정규형에 대해서 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_7.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 테이블에서 회원ID와 계좌번호가 기본키라고 가정하자. 그런데 관리점 Column 을 보면 기본키에 종속되는 것이 아니라 관리점 코드에 종속되는 것을 볼 수 있다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행 함수 종속&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;관리점 코드를 기본키로 하는 새로운 테이블을 도출하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행 함수 종속성&lt;/code&gt;을 제거할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_8.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/46_9.png&quot; alt=&quot;img1&quot; width=&quot;90%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 2개의 테이블로 분리하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행 함수 종속&lt;/code&gt;을 제거하였다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;반정규화&quot;&gt;반정규화&lt;/h1&gt;

&lt;p&gt;성능 향상을 위해서 데이터의 중복을 허용하고, 조인 연산을 줄여 데이터베이스 성능 향상을 하는 방법&lt;/p&gt;

&lt;h2 id=&quot;정규화의-단점&quot;&gt;정규화의 단점&lt;/h2&gt;

&lt;p&gt;정규화된 데이터를 조회할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join&lt;/code&gt;이 많이 발생하기 때문에 CPU와 메모리를 많이 사용하고 성능도 떨어진다. 이러한 성능 문제를 해결하기 위해서 반정규화를 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;정규화↔반정규화 사이에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trade off&lt;/code&gt;가 있다.&lt;/p&gt;

&lt;p&gt;정규화를 수행하면 데이터의 중복이 줄고 데이터 모델의 유연성이 높아지지만 반대로 성능이 내려간다.&lt;/p&gt;

&lt;p&gt;반정규화를 수행하면 성능은 좋아지지만 유연성이 떨어지고 데이터의 중복이 많아져서 관리하기 어렵다.&lt;/p&gt;

&lt;h2 id=&quot;반정규화를-수행하는-경우&quot;&gt;반정규화를 수행하는 경우&lt;/h2&gt;

&lt;p&gt;특정 범위의 데이터만 자주 조회하는 경우&lt;/p&gt;

&lt;p&gt;요약/집계 정보가 자주 요구되는 경우&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;면접을 위한 CS 전공지식 노트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="데이터베이스" /><category term="정규화" /><category term="DB" /><summary type="html"></summary></entry><entry><title type="html">[테스트] 다양한 테스트 방법</title><link href="http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/45/" rel="alternate" type="text/html" title="[테스트] 다양한 테스트 방법" /><published>2023-11-07T00:00:00+09:00</published><updated>2023-11-07T00:00:00+09:00</updated><id>http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/45</id><content type="html" xml:base="http://localhost:4000/%ED%85%8C%EC%8A%A4%ED%8A%B8/45/">&lt;h2 id=&quot;동기&quot;&gt;동기&lt;/h2&gt;

&lt;p&gt;2주차 미션 피드백을 읽으면서 유용한 테스트 방법이 있어서 소개하고자 한다. &lt;br /&gt;
바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;이다. 바로 사용 방법을 알아보자! 
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;parameterizedtest&quot;&gt;ParameterizedTest&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ParameterizedTest&lt;/code&gt;를 사용하면 여러 개의 파라미터에 대한 테스트를 하나에 테스트 메소드로 처리할 수 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Test&lt;/code&gt;만을 사용했을 때와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ParameterizedTest&lt;/code&gt;를 사용했을 때의 차이점을 코드로 확인해보자! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;기존의-테스트&quot;&gt;기존의 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_1.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;를 사용하지 않으면 테스트하고 싶은 매개변수가 있을 때마다 테스트 메소드를 작성해야 한다. &lt;br /&gt;
코드를 보면 알 수 있다싶이 중복되는 부분이 많고 테스트 케이스마다 메소드를 작성해야 하기 때문에 관리하기 어렵다. &lt;br /&gt;
그렇다면 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;를 사용한 코드를 보자 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;parameterizedtest를-사용한-테스트&quot;&gt;ParameterizedTest를 사용한 테스트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_2.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 코드를 실행하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test3&lt;/code&gt;가 총 5번 호출되며 실행할 때, 5, 4, 3, 2, 1이 순서대로 들어간다. &lt;br /&gt;
여러 경우에 대한 테스트를 단 하나의 메소드로 처리할 수 있는 것이다! &lt;br /&gt;
아마 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ValueSoource&lt;/code&gt;가 무엇인지 궁금할 것이다! 이는 파라미터에 값을 넣는 에노테이션으로 이제부터 설명하겠다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;argument-sources&quot;&gt;Argument sources&lt;/h2&gt;

&lt;p&gt;앞서 봤듯이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTest&lt;/code&gt;는 서로 다른 인수를 사용하여 동일한 테스트를 여러 번 실행시킨다. &lt;br /&gt;
그런데 단순한 인수만 넣을 수 있다면 조금만 복잡한 값이 들어오더라도 테스트할 수 없을 것이다.&lt;br /&gt;
이제부터 여러가지 인수를 넣는 방법에 대해서 살펴보자!&lt;/p&gt;

&lt;h3 id=&quot;valuesource&quot;&gt;@ValueSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ValueSource&lt;/code&gt;를 사용하면 단순한 리터럴 값 배열을 테스트 메서드에 전달할 수 있게된다.&lt;br /&gt; 
사용법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ValueSource&lt;/code&gt;안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shorts&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strings&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ints&lt;/code&gt;와 같이 타입을 적어주고 뒤에 값을 넣어주면 된다.&lt;br /&gt;
코드 예시를 보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_4.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;test3은 총 3번 실행되며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;에 순서대로 “aaa”, “bbb”, “ccc” 값이 들어간다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Test&lt;/code&gt;만 사용한다면 총 3번개의 테스트 메소드를 작성해야 하는데 하나의 메소드로 처리한 것을 볼 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;넘겨줄-수-있는-자료형은-다음과-같다&quot;&gt;넘겨줄 수 있는 자료형은 다음과 같다!&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/45_3.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nullsource&quot;&gt;@NullSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@NullSource&lt;/code&gt;는 파라미터 값으로 null을 넣어준다. &lt;br /&gt;
바로 예시를 보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_5.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_6.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과를 보면 알 수 있듯이 data에 null이 들어간 것을 확인할 수 있다 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;emptysource&quot;&gt;@EmptySource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EmptySource&lt;/code&gt;도 이름 그대로 빈 값을 파라미터에 주입해준다. &lt;br /&gt;
코드로 바로 확인해보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_7.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_8.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;data에 empty값이 들어간 것을 확인할 수 있다! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;enumsource&quot;&gt;@EnumSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnumSource&lt;/code&gt;도 느낌이 오지 않는가? 그냥 Enum을 넣어준다 ㅎㅎ.. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_9.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_10.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 잘 통과하는 것을 확인할 수 있다 &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;methodsource&quot;&gt;@MethodSource&lt;/h3&gt;

&lt;p&gt;지금까지 살펴본 테스트들은 단순하고 하나의 파라미터밖에 넘기지 못한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;는 좀 더 복잡한 인수를 가지고 테스트를 제공한다. &lt;br /&gt;
바로 예시를 보자! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_11.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;차례대로 input, expected에 `provideStringForBlank에서 생성한 값들이 들어가는 것을 확인할 수 있다.&lt;br /&gt;
이렇게 여러 복잡한 인자를 넘겨서 테스트가 가능하다! &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;이-방식을-사용하려면-몇-가지-규칙이-있다&quot;&gt;이 방식을 사용하려면 몇 가지 규칙이 있다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;로 지정한 메소드는 반드시 &lt;strong&gt;static&lt;/strong&gt;이어야 한다.&lt;/li&gt;
  &lt;li&gt;그리고 메소드 이름과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;에 들어가는 메서드 이름이 일치해야 한다.
    &lt;ul&gt;
      &lt;li&gt;단, TestInstance를 사용하여 클래스 단위의 생성주기를 가지는 경우에 인스턴스 메소드가 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MethodSource&lt;/code&gt;에 메소드 이름을 작성하지 않으면 JUnit이 테스트 메소드 네임과 같은 메소드를 찾아서 인수로 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 방식을 사용하면 복잡한 인수를 자동으로 주입해서 테스트할 수 있다!! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;csvsource&quot;&gt;@CsvSource&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@CsvSource&lt;/code&gt;를 사용하면 인자와 테스트 값을 동시에 주입할 수 있다 &lt;br /&gt;
바로 코드로 확인해보자 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_12.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/45_13.png&quot; alt=&quot;img1&quot; width=&quot;70%&amp;quot;&amp;quot;, height=&amp;quot;40%&amp;quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@CsvSource&lt;/code&gt;에 값을 넣을때는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉼표(,)&lt;/code&gt;로 구분된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delimeter&lt;/code&gt;를 따로 설정할 수도 있다! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 다양한 테스트 방법에 대해서 알아봤다.&lt;br /&gt;
테스트 코드를 작성하는 것도 서비스 로직을 작성하는 것만큼 중요하다. &lt;br /&gt;
다양한 테스트 방법에 대해서 숙지해두자! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://ebabby.tistory.com/21&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.baeldung.com/parameterized-tests-junit-5&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://velog.io/@ohzzi/junit5-parameterizedtest&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Moon JinSu</name></author><category term="테스트" /><category term="Junit5" /><category term="우테코" /><summary type="html">동기</summary></entry></feed>